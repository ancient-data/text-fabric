<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.advanced.helpers API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.advanced.helpers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L1-L651" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import os
import re

from IPython.display import display, Markdown, HTML

from ..parameters import backendRep, TEMP_DIR
from ..core.helpers import mdEsc, htmlEsc, expanduser, unexpanduser, QUAD, console
from ..core.text import DEFAULT_FORMAT


NORMAL = &#34;normal&#34;
ORIG = &#34;orig&#34;

RESULT = &#34;result&#34;
NB = &#34;\u00a0&#34;
EM = &#34;*empty*&#34;

SEQ_TYPES1 = {tuple, list}
SEQ_TYPES2 = {tuple, list, set, frozenset}


def runsInNotebook():
    &#34;&#34;&#34;Determines whether the program runs in an interactive shell.

    From https://stackoverflow.com/questions/15411967/how-can-i-check-if-code-is-executed-in-the-ipython-notebook/24937408
    &#34;&#34;&#34;
    try:
        runcontext = get_ipython()
        shell = runcontext.__class__.__name__
        if shell == &#34;ZMQInteractiveShell&#34;:
            return True  # Jupyter notebook or qtconsole
        elif shell == &#34;TerminalInteractiveShell&#34;:
            return False  # Terminal running IPython
        else:
            return False  # Other type (?)
    except NameError:
        return False  # Probably standard Python interpreter


def _getLtr(app, options):
    aContext = app.context
    direction = aContext.direction

    fmt = options.fmt or DEFAULT_FORMAT

    return (
        &#34;rtl&#34;
        if direction == &#34;rtl&#34; and (f&#34;{ORIG}-&#34; in fmt or f&#34;-{ORIG}&#34; in fmt)
        else (&#34;&#34; if direction == &#34;ltr&#34; else &#34;ltr&#34;)
    )


def dm(md, inNb=True):
    &#34;&#34;&#34;Display markdown.

    Parameters
    ----------
    md: string
        Raw markdown string.
    inNb: boolean, optional True
        Whether the program runs in a notebook

    Returns
    -------
    None
        The formatted markdown is rendered in the output cell if `inNb`
        else the raw markdown is printed to the output.
    &#34;&#34;&#34;

    if inNb:
        display(Markdown(unexpanduser(md)))
    else:
        console(md)


def dh(html, inNb=True):
    &#34;&#34;&#34;Display HTML.

    Parameters
    ----------
    html: string
        Raw html string.
    inNb: boolean, optional True
        Whether the program runs in a notebook

    Returns
    -------
    None
        The formatted HTML is rendered in the output cell if `inNb`
        else the raw HTML is printed to the output.
    &#34;&#34;&#34;

    if inNb:
        display(HTML(unexpanduser(html)))
    else:
        console(html)


# MODULE REFERENCES

BACKEND_RE = re.compile(r&#34;&lt;([^/&gt;]*)&gt;&#34;)


thisBackend = []


def backendRepl(match):
    thisBackend.append(match.group(1))
    return &#34;&#34;


def splitModRef(moduleRef):
    thisBackend.clear()
    theBackend = None
    bareModuleRef = BACKEND_RE.sub(backendRepl, moduleRef)
    if len(thisBackend):
        theBackend = thisBackend[0]
        if len(thisBackend) &gt; 1:
            console(
                f&#34;Multiple &lt;backend&gt; in {moduleRef}: &#34;
                f&#34;{&#39;, &#39;.join(thisBackend)}; using &lt;{theBackend}&gt; only &#34;,
                error=True,
            )

    bRep = f&#34;&lt;{theBackend}&gt;&#34; if theBackend else &#34;&#34;

    parts = bareModuleRef.split(&#34;:&#34;, 1)
    if len(parts) == 1:
        parts.append(&#34;&#34;)
    (ref, specifier) = parts
    parts = ref.split(&#34;/&#34;, 2)

    if len(parts) &lt; 2:
        console(
            f&#34;&#34;&#34;
Module ref &#34;{bRep}{bareModuleRef}&#34; is not &#34;{{org}}/{{repo}}/{{path}}&#34;
&#34;&#34;&#34;,
            error=True,
        )
        return None

    if len(parts) == 2:
        parts.append(&#34;&#34;)

    return [*parts, specifier, theBackend]


# COLLECT CONFIG SETTINGS IN A DICT


def getLocalDir(backend, cfg, local, version):
    provenanceSpec = cfg.get(&#34;provenanceSpec&#34;, {})
    org = provenanceSpec.get(&#34;org&#34;, None)
    repo = provenanceSpec.get(&#34;repo&#34;, None)
    relative = provenanceSpec.get(&#34;relative&#34;, &#34;tf&#34;)
    version = provenanceSpec.get(&#34;version&#34;, None) if version is None else version
    base = hasData(backend, local, org, repo, version, relative)

    if not base:
        base = backendRep(backend, &#34;cache&#34;)

    return expanduser(f&#34;{base}/{org}/{repo}/{TEMP_DIR}&#34;)


def hasData(backend, local, org, repo, version, relative):
    versionRep = f&#34;/{version}&#34; if version else &#34;&#34;
    if local == &#34;clone&#34;:
        cloneBase = backendRep(backend, &#34;clone&#34;)
        ghTarget = f&#34;{cloneBase}/{org}/{repo}/{relative}{versionRep}&#34;
        if os.path.exists(ghTarget):
            return cloneBase

    cacheBase = backendRep(backend, &#34;cache&#34;)
    cacheTarget = f&#34;{cacheBase}/{org}/{repo}/{relative}{versionRep}&#34;
    if os.path.exists(cacheTarget):
        return cacheBase
    return False


def tupleEnum(tuples, start, end, limit, item, inNb):
    if start is None:
        start = 1
    i = -1
    if not hasattr(tuples, &#34;__len__&#34;):
        if end is None or end - start + 1 &gt; limit:
            end = start - 1 + limit
        for tup in tuples:
            i += 1
            if i &lt; start - 1:
                continue
            if i &gt;= end:
                break
            yield (i + 1, tup)
    else:
        if end is None or end &gt; len(tuples):
            end = len(tuples)
        rest = 0
        if end - (start - 1) &gt; limit:
            rest = end - (start - 1) - limit
            end = start - 1 + limit
        for i in range(start - 1, end):
            yield (i + 1, tuples[i])
        if rest:
            dh(
                f&#34;&lt;b&gt;{rest} more {item}s skipped&lt;/b&gt; because we show a maximum of&#34;
                f&#34; {limit} {item}s at a time&#34;,
                inNb=inNb,
            )


def parseFeatures(features):
    if (
        type(features) in SEQ_TYPES1
        and len(features) == 2
        and type(features[0]) in SEQ_TYPES2
        and type(features[1]) is dict
    ):
        return features

    bare = []
    indirect = {}
    feats = (
        ()
        if not features
        else features.split()
        if type(features) is str
        else tuple(features)
    )
    for feat in feats:
        if not feat:
            continue
        parts = feat.split(&#34;:&#34;, 1)
        feat = parts[-1]
        bare.append(feat)
        if len(parts) &gt; 1:
            indirect[feat] = parts[0]
    return (bare, indirect)


def transitiveClosure(relation, reflexiveExceptions):
    &#34;&#34;&#34;Produce the reflexive transitive closure of a relation.

    The transitive closure of a relation R is the relation TR
    such that aTRb if and only if there is a chain of c1, c2, ..., cn
    such that ARc1, c1Rc2, ..., cnRb.

    If we allow the chain to have length zero, we effectively have that
    aTRa for all elements. That is the reflexive, transitive closure.

    This function builds the latter, but we allow for exceptions to the
    reflexivity.

    Parameters
    ----------
    relation: dict
        The input relation, keyed by elements, valued by the set of
        elements that stand in relation to the key.
    reflexiveExceptions: set
        The set of elements that will not be reflexively closed.

    Returns
    -------
    dict
        The transitive reflexive closure (with possible exceptions to
        the reflexivity) of the given relation.

    Notes
    -----
    We use this function to build the closure of the childType relation
    between node types. We want to exclude the slot type from the
    reflexivity. The closure of the childType relation is the descendant type
    relation.
    The display algorithm uses this to unravel nodes.

    See also
    --------
    tf.advanced.display: Display algorithm
    &#34;&#34;&#34;

    descendants = {parent: set(children) for (parent, children) in relation.items()}

    changed = True
    while changed:
        changed = False
        for (parent, children) in relation.items():
            for child in children:
                if child in descendants:
                    for grandChild in descendants[child]:
                        if grandChild not in descendants[parent]:
                            descendants[parent].add(grandChild)
                            changed = True
    for parent in relation:
        if parent not in reflexiveExceptions:
            descendants[parent].add(parent)
    return descendants


def htmlSafe(text, isHtml):
    return text if isHtml else htmlEsc(text)


def getText(
    app, isPretty, n, nType, outer, first, last, level, passage, descend, options=None
):
    display = app.display
    dContext = display.distill(options or {})
    ltr = _getLtr(app, dContext) or &#34;ltr&#34;
    T = app.api.T
    sectionTypeSet = T.sectionTypeSet
    structureTypeSet = T.structureTypeSet

    aContext = app.context
    templates = aContext.labels if isPretty else aContext.templates

    fmt = None if options is None else options.fmt
    standardFeatures = True if options is None else options.standardFeatures
    isHtml = False if options is None else options.isHtml
    suppress = set() if options is None else options.suppress

    (tpl, feats) = templates[nType]
    x = &#34;&#34; if isPretty else &#34; &#34;

    tplFilled = (
        (
            (
                f&#34;&#34;&#34;&lt;span class=&#34;tfsechead {ltr}&#34;&gt;&lt;span class=&#34;ltr&#34;&gt;&#34;&#34;&#34;
                + (NB if passage else app.sectionStrFromNode(n))
                + &#34;&lt;/span&gt;&lt;/span&gt;&#34;
            )
            if nType in sectionTypeSet
            else f&#39;&lt;span class=&#34;structure&#34;&gt;{app.structureStrFromNode(n)}&lt;/span&gt;&#39;
            if nType in structureTypeSet
            else htmlSafe(
                T.text(
                    n,
                    fmt=fmt,
                    descend=descend,
                    outer=outer,
                    first=first,
                    last=last,
                    level=level,
                ),
                isHtml,
            )
        )
        if tpl is True
        else (
            (
                tpl.format(
                    **{feat: getValue(app, n, nType, feat, suppress) for feat in feats}
                )
                + x
            )
            if standardFeatures
            else &#34;&#34;
        )
    )
    return tplFilled


def getValue(app, n, nType, feat, suppress):
    F = app.api.F
    Fs = app.api.Fs

    customMethods = app.customMethods
    transform = customMethods.transform
    if feat in suppress:
        val = &#34;&#34;
    else:
        featObj = Fs(feat) if hasattr(F, feat) else None
        val = htmlEsc(featObj.v(n)) if featObj else None
        modifier = transform.get(nType, {}).get(feat, None)
        if modifier:
            val = modifier(n, val)
    return f&#39;&lt;span title=&#34;{feat}&#34;&gt;{val}&lt;/span&gt;&#39;


# COMPOSE TABLES FOR CSV EXPORT


def isUniform(app, tuples):
    &#34;&#34;&#34;Whether the members of tuples are uniform.

    An iterable of tuples of nodes is uniform, if each
    tuple has the same number of nodes,
    and if the type of a node at position *i* in the tuple
    is the same for all tuples.
    &#34;&#34;&#34;
    api = app.api
    F = api.F
    fOtype = F.otype.v

    uniform = True
    fixedLength = None
    fixedTypes = None

    for tup in tuples:
        thisLength = len(tup)
        theseTypes = tuple(fOtype(n) for n in tup)

        if fixedLength is None:
            fixedLength = thisLength
        if fixedTypes is None:
            fixedTypes = theseTypes

        if thisLength != fixedLength or theseTypes != fixedTypes:
            uniform = False
            break

    return uniform


def getRowsX(app, tuples, features, condenseType, fmt=None):
    &#34;&#34;&#34;Transform an iterable of nodes into a table with extra information.

    If the tuples are uniform (`isUniform`), the formatting will
    be richer then when the tuples are not uniform.
    &#34;&#34;&#34;

    return (
        getResultsX(app, tuples, features, condenseType, fmt=fmt)
        if isUniform(app, tuples)
        else getTuplesX(app, tuples, condenseType, fmt=fmt)
    )


def getResultsX(app, results, features, condenseType, fmt=None):
    &#34;&#34;&#34;Transform a uniform iterable of nodes into a table with extra information.

    Parameters
    ----------
    results: iterable of tuple of int
        A uniform `isUniform` sequence of tuples of nodes
    features: key value pairs
        features per index position of the tuples.
        It specifies for some positions `i` which features for the nodes at that
        position should be looked up. For each `i` it should be an iterable
        or comma-separated list of feature names.
    condenseType: string
        A node type. Types smaller or equal than this type will have their text
        displayed in the result.
    fmt: string, optional `None`
        A text format. If text has to be displayed, this format is used.
        If not passed, a default is used.
    &#34;&#34;&#34;

    api = app.api
    F = api.F
    Fs = api.Fs
    T = api.T
    N = api.N
    fOtype = F.otype.v
    otypeRank = N.otypeRank
    sectionTypeSet = T.sectionTypeSet

    aContext = app.context
    noDescendTypes = aContext.noDescendTypes

    sectionDepth = len(sectionTypeSet)
    if len(results) == 0:
        return ()
    firstResult = results[0]
    nTuple = len(firstResult)
    refColumns = [
        i for (i, n) in enumerate(firstResult) if fOtype(n) not in sectionTypeSet
    ]
    refColumn = refColumns[0] if refColumns else nTuple - 1
    header = [&#34;R&#34;] + [f&#34;S{i}&#34; for i in range(1, sectionDepth + 1)]
    emptyA = []

    featureDict = {i: tuple(f.split()) if type(f) is str else f for (i, f) in features}

    def withText(nodeType):
        return (
            condenseType is None
            and nodeType not in sectionTypeSet
            or otypeRank[nodeType] &lt;= otypeRank[condenseType]
        )

    noDescendTypes = noDescendTypes

    for j in range(nTuple):
        i = j + 1
        n = firstResult[j]
        nType = fOtype(n)
        header.extend([f&#34;NODE{i}&#34;, f&#34;TYPE{i}&#34;])
        if withText(nType):
            header.append(f&#34;TEXT{i}&#34;)
        header.extend(f&#34;{feature}{i}&#34; for feature in featureDict.get(j, emptyA))
    rows = [tuple(header)]
    for (rm, r) in enumerate(results):
        rn = rm + 1
        row = [rn]
        refN = r[refColumn]
        sparts = T.sectionFromNode(refN)
        nParts = len(sparts)
        section = sparts + ((None,) * (sectionDepth - nParts))
        row.extend(section)
        for j in range(nTuple):
            n = r[j]
            nType = fOtype(n)
            row.extend((n, nType))
            if withText(nType):
                text = T.text(n, fmt=fmt, descend=nType not in noDescendTypes)
                row.append(text)
            row.extend(Fs(feature).v(n) for feature in featureDict.get(j, emptyA))
        rows.append(tuple(row))
    return tuple(rows)


def getTuplesX(app, results, condenseType, fmt=None):
    &#34;&#34;&#34;Transform a non-uniform iterable of nodes into a table with extra information.

    Parameters
    ----------
    results: iterable of tuple of int
        A uniform `isUniform` sequence of tuples of nodes
    condenseType: string
        A node type. Types smaller or equal than this type will have their text
        displayed in the result.
    fmt: string, optional `None`
        A text format. If text has to be displayed, this format is used.
        If not passed, a default is used.
    &#34;&#34;&#34;

    api = app.api
    F = api.F
    T = api.T
    N = api.N
    fOtype = F.otype.v
    otypeRank = N.otypeRank
    sectionTypeSet = T.sectionTypeSet

    aContext = app.context
    noDescendTypes = aContext.noDescendTypes

    sectionDepth = len(sectionTypeSet)
    if len(results) == 0:
        return ()

    def withText(nodeType):
        return (
            condenseType is None
            and nodeType not in sectionTypeSet
            or otypeRank[nodeType] &lt;= otypeRank[condenseType]
        )

    noDescendTypes = noDescendTypes

    rows = []

    for (tm, tup) in enumerate(results):
        tn = tm + 1
        row = [tn]
        for n in tup:
            sparts = T.sectionFromNode(n)
            nParts = len(sparts)
            section = sparts + ((None,) * (sectionDepth - nParts))
            row.extend(section)
            nType = fOtype(n)
            row.extend((n, nType))
            if withText(nType):
                text = T.text(n, fmt=fmt, descend=nType not in noDescendTypes)
                row.append(text)
        rows.append(tuple(row))
    return tuple(rows)


def eScalar(x, level):
    if type(x) is str and &#34;\n&#34; in x:
        indent = QUAD * level
        return (
            f&#34;\n{indent}```\n{indent}&#34;
            + f&#34;\n{indent}&#34;.join(x.split(&#34;\n&#34;))
            + f&#34;\n{indent}```\n&#34;
        )
    return f&#34;`{mdEsc(str(x))}`&#34; if x else EM


def eEmpty(x):
    return EM if type(x) is str else str(x)


def eList(x, level):
    tpv = type(x)
    indent = QUAD * level
    md = &#34;\n&#34;
    for (i, v) in enumerate(sorted(x, key=lambda y: str(y)) if tpv is set else x):
        item = f&#34;{i + 1}.&#34; if level == 0 else &#34;*&#34;
        md += f&#34;{indent}{item:&lt;4}{eData(v, level + 1)}&#34;
    return md


def eDict(x, level):
    indent = QUAD * level
    md = &#34;\n&#34;
    for (k, v) in sorted(x.items(), key=lambda y: str(y)):
        item = &#34;*&#34;
        md += f&#34;{indent}{item:&lt;4}**{eScalar(k, level)}**:&#34; f&#34; {eData(v, level + 1)}&#34;
    return md


def eRest(x, level):
    indent = QUAD * level
    return &#34;\n&#34; + indent + eScalar(x, level) + &#34;\n&#34;


def eData(x, level):
    if not x:
        return eEmpty(x) + &#34;\n&#34;
    tpv = type(x)
    if tpv is str or tpv is float or tpv is int or tpv is bool:
        return eScalar(x, level) + &#34;\n&#34;
    if tpv is list or tpv is tuple or tpv is set:
        return eList(x, level)
    if tpv is dict:
        return eDict(x, level)
    return eRest(x, level)


def showDict(title, data, inNb, *keys):
    &#34;&#34;&#34;Shows selected keys of a dictionary in a pretty way.

    Parameters
    ----------
    inNb: boolean
        Whether we run in a notebook.
    keys: iterable of string
        For each key passed to this function, the information for that key
        will be displayed. If no keys are passed, all keys will be displayed.

    Returns
    -------
    displayed HTML
        An expandable list of the key-value pair for the requested keys.
    &#34;&#34;&#34;

    keys = set(keys)

    openRep1 = &#34;open&#34; if len(keys) else &#34;&#34;
    openRep2 = &#34;open&#34; if len(keys) == 1 else &#34;&#34;
    md = [f&#34;&lt;details {openRep1}&gt;&#34; f&#34;&lt;summary&gt;{title}&lt;/summary&gt;\n\n&#34;]
    for (i, (k, v)) in enumerate(sorted(data.items(), key=lambda y: str(y))):
        if len(keys) and k not in keys:
            continue
        md.append(
            f&#34;&lt;details {openRep2}&gt;&#34;
            f&#34;&lt;summary&gt;{i + 1}. {k}&lt;/summary&gt;\n\n{eData(v, 0)}\n&lt;/details&gt;\n&#34;
        )
    md.append(&#34;&lt;/details&gt;\n&#34;)
    dm(&#34;&#34;.join(md), inNb=inNb)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.advanced.helpers.backendRepl"><code class="name flex">
<span>def <span class="ident">backendRepl</span></span>(<span>match)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L107-L109" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def backendRepl(match):
    thisBackend.append(match.group(1))
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.dh"><code class="name flex">
<span>def <span class="ident">dh</span></span>(<span>html, inNb=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Display HTML.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>html</code></strong> :&ensp;<code>string</code></dt>
<dd>Raw html string.</dd>
<dt><strong><code>inNb</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether the program runs in a notebook</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>The formatted HTML is rendered in the output cell if <code>inNb</code>
else the raw HTML is printed to the output.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L76-L96" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh(html, inNb=True):
    &#34;&#34;&#34;Display HTML.

    Parameters
    ----------
    html: string
        Raw html string.
    inNb: boolean, optional True
        Whether the program runs in a notebook

    Returns
    -------
    None
        The formatted HTML is rendered in the output cell if `inNb`
        else the raw HTML is printed to the output.
    &#34;&#34;&#34;

    if inNb:
        display(HTML(unexpanduser(html)))
    else:
        console(html)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.dm"><code class="name flex">
<span>def <span class="ident">dm</span></span>(<span>md, inNb=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Display markdown.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>md</code></strong> :&ensp;<code>string</code></dt>
<dd>Raw markdown string.</dd>
<dt><strong><code>inNb</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether the program runs in a notebook</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>The formatted markdown is rendered in the output cell if <code>inNb</code>
else the raw markdown is printed to the output.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L53-L73" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dm(md, inNb=True):
    &#34;&#34;&#34;Display markdown.

    Parameters
    ----------
    md: string
        Raw markdown string.
    inNb: boolean, optional True
        Whether the program runs in a notebook

    Returns
    -------
    None
        The formatted markdown is rendered in the output cell if `inNb`
        else the raw markdown is printed to the output.
    &#34;&#34;&#34;

    if inNb:
        display(Markdown(unexpanduser(md)))
    else:
        console(md)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.eData"><code class="name flex">
<span>def <span class="ident">eData</span></span>(<span>x, level)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L608-L618" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def eData(x, level):
    if not x:
        return eEmpty(x) + &#34;\n&#34;
    tpv = type(x)
    if tpv is str or tpv is float or tpv is int or tpv is bool:
        return eScalar(x, level) + &#34;\n&#34;
    if tpv is list or tpv is tuple or tpv is set:
        return eList(x, level)
    if tpv is dict:
        return eDict(x, level)
    return eRest(x, level)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.eDict"><code class="name flex">
<span>def <span class="ident">eDict</span></span>(<span>x, level)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L594-L600" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def eDict(x, level):
    indent = QUAD * level
    md = &#34;\n&#34;
    for (k, v) in sorted(x.items(), key=lambda y: str(y)):
        item = &#34;*&#34;
        md += f&#34;{indent}{item:&lt;4}**{eScalar(k, level)}**:&#34; f&#34; {eData(v, level + 1)}&#34;
    return md</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.eEmpty"><code class="name flex">
<span>def <span class="ident">eEmpty</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L580-L581" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def eEmpty(x):
    return EM if type(x) is str else str(x)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.eList"><code class="name flex">
<span>def <span class="ident">eList</span></span>(<span>x, level)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L584-L591" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def eList(x, level):
    tpv = type(x)
    indent = QUAD * level
    md = &#34;\n&#34;
    for (i, v) in enumerate(sorted(x, key=lambda y: str(y)) if tpv is set else x):
        item = f&#34;{i + 1}.&#34; if level == 0 else &#34;*&#34;
        md += f&#34;{indent}{item:&lt;4}{eData(v, level + 1)}&#34;
    return md</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.eRest"><code class="name flex">
<span>def <span class="ident">eRest</span></span>(<span>x, level)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L603-L605" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def eRest(x, level):
    indent = QUAD * level
    return &#34;\n&#34; + indent + eScalar(x, level) + &#34;\n&#34;</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.eScalar"><code class="name flex">
<span>def <span class="ident">eScalar</span></span>(<span>x, level)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L569-L577" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def eScalar(x, level):
    if type(x) is str and &#34;\n&#34; in x:
        indent = QUAD * level
        return (
            f&#34;\n{indent}```\n{indent}&#34;
            + f&#34;\n{indent}&#34;.join(x.split(&#34;\n&#34;))
            + f&#34;\n{indent}```\n&#34;
        )
    return f&#34;`{mdEsc(str(x))}`&#34; if x else EM</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.getLocalDir"><code class="name flex">
<span>def <span class="ident">getLocalDir</span></span>(<span>backend, cfg, local, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L151-L162" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getLocalDir(backend, cfg, local, version):
    provenanceSpec = cfg.get(&#34;provenanceSpec&#34;, {})
    org = provenanceSpec.get(&#34;org&#34;, None)
    repo = provenanceSpec.get(&#34;repo&#34;, None)
    relative = provenanceSpec.get(&#34;relative&#34;, &#34;tf&#34;)
    version = provenanceSpec.get(&#34;version&#34;, None) if version is None else version
    base = hasData(backend, local, org, repo, version, relative)

    if not base:
        base = backendRep(backend, &#34;cache&#34;)

    return expanduser(f&#34;{base}/{org}/{repo}/{TEMP_DIR}&#34;)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.getResultsX"><code class="name flex">
<span>def <span class="ident">getResultsX</span></span>(<span>app, results, features, condenseType, fmt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform a uniform iterable of nodes into a table with extra information.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>results</code></strong> :&ensp;<code>iterable</code> of <code>tuple</code> of <code>int</code></dt>
<dd>A uniform <code><a title="tf.advanced.helpers.isUniform" href="#tf.advanced.helpers.isUniform">isUniform()</a></code> sequence of tuples of nodes</dd>
<dt><strong><code>features</code></strong> :&ensp;<code>key value pairs</code></dt>
<dd>features per index position of the tuples.
It specifies for some positions <code>i</code> which features for the nodes at that
position should be looked up. For each <code>i</code> it should be an iterable
or comma-separated list of feature names.</dd>
<dt><strong><code>condenseType</code></strong> :&ensp;<code>string</code></dt>
<dd>A node type. Types smaller or equal than this type will have their text
displayed in the result.</dd>
<dt><strong><code>fmt</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>A text format. If text has to be displayed, this format is used.
If not passed, a default is used.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L427-L508" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getResultsX(app, results, features, condenseType, fmt=None):
    &#34;&#34;&#34;Transform a uniform iterable of nodes into a table with extra information.

    Parameters
    ----------
    results: iterable of tuple of int
        A uniform `isUniform` sequence of tuples of nodes
    features: key value pairs
        features per index position of the tuples.
        It specifies for some positions `i` which features for the nodes at that
        position should be looked up. For each `i` it should be an iterable
        or comma-separated list of feature names.
    condenseType: string
        A node type. Types smaller or equal than this type will have their text
        displayed in the result.
    fmt: string, optional `None`
        A text format. If text has to be displayed, this format is used.
        If not passed, a default is used.
    &#34;&#34;&#34;

    api = app.api
    F = api.F
    Fs = api.Fs
    T = api.T
    N = api.N
    fOtype = F.otype.v
    otypeRank = N.otypeRank
    sectionTypeSet = T.sectionTypeSet

    aContext = app.context
    noDescendTypes = aContext.noDescendTypes

    sectionDepth = len(sectionTypeSet)
    if len(results) == 0:
        return ()
    firstResult = results[0]
    nTuple = len(firstResult)
    refColumns = [
        i for (i, n) in enumerate(firstResult) if fOtype(n) not in sectionTypeSet
    ]
    refColumn = refColumns[0] if refColumns else nTuple - 1
    header = [&#34;R&#34;] + [f&#34;S{i}&#34; for i in range(1, sectionDepth + 1)]
    emptyA = []

    featureDict = {i: tuple(f.split()) if type(f) is str else f for (i, f) in features}

    def withText(nodeType):
        return (
            condenseType is None
            and nodeType not in sectionTypeSet
            or otypeRank[nodeType] &lt;= otypeRank[condenseType]
        )

    noDescendTypes = noDescendTypes

    for j in range(nTuple):
        i = j + 1
        n = firstResult[j]
        nType = fOtype(n)
        header.extend([f&#34;NODE{i}&#34;, f&#34;TYPE{i}&#34;])
        if withText(nType):
            header.append(f&#34;TEXT{i}&#34;)
        header.extend(f&#34;{feature}{i}&#34; for feature in featureDict.get(j, emptyA))
    rows = [tuple(header)]
    for (rm, r) in enumerate(results):
        rn = rm + 1
        row = [rn]
        refN = r[refColumn]
        sparts = T.sectionFromNode(refN)
        nParts = len(sparts)
        section = sparts + ((None,) * (sectionDepth - nParts))
        row.extend(section)
        for j in range(nTuple):
            n = r[j]
            nType = fOtype(n)
            row.extend((n, nType))
            if withText(nType):
                text = T.text(n, fmt=fmt, descend=nType not in noDescendTypes)
                row.append(text)
            row.extend(Fs(feature).v(n) for feature in featureDict.get(j, emptyA))
        rows.append(tuple(row))
    return tuple(rows)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.getRowsX"><code class="name flex">
<span>def <span class="ident">getRowsX</span></span>(<span>app, tuples, features, condenseType, fmt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform an iterable of nodes into a table with extra information.</p>
<p>If the tuples are uniform (<code><a title="tf.advanced.helpers.isUniform" href="#tf.advanced.helpers.isUniform">isUniform()</a></code>), the formatting will
be richer then when the tuples are not uniform.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L413-L424" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getRowsX(app, tuples, features, condenseType, fmt=None):
    &#34;&#34;&#34;Transform an iterable of nodes into a table with extra information.

    If the tuples are uniform (`isUniform`), the formatting will
    be richer then when the tuples are not uniform.
    &#34;&#34;&#34;

    return (
        getResultsX(app, tuples, features, condenseType, fmt=fmt)
        if isUniform(app, tuples)
        else getTuplesX(app, tuples, condenseType, fmt=fmt)
    )</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.getText"><code class="name flex">
<span>def <span class="ident">getText</span></span>(<span>app, isPretty, n, nType, outer, first, last, level, passage, descend, options=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L302-L358" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getText(
    app, isPretty, n, nType, outer, first, last, level, passage, descend, options=None
):
    display = app.display
    dContext = display.distill(options or {})
    ltr = _getLtr(app, dContext) or &#34;ltr&#34;
    T = app.api.T
    sectionTypeSet = T.sectionTypeSet
    structureTypeSet = T.structureTypeSet

    aContext = app.context
    templates = aContext.labels if isPretty else aContext.templates

    fmt = None if options is None else options.fmt
    standardFeatures = True if options is None else options.standardFeatures
    isHtml = False if options is None else options.isHtml
    suppress = set() if options is None else options.suppress

    (tpl, feats) = templates[nType]
    x = &#34;&#34; if isPretty else &#34; &#34;

    tplFilled = (
        (
            (
                f&#34;&#34;&#34;&lt;span class=&#34;tfsechead {ltr}&#34;&gt;&lt;span class=&#34;ltr&#34;&gt;&#34;&#34;&#34;
                + (NB if passage else app.sectionStrFromNode(n))
                + &#34;&lt;/span&gt;&lt;/span&gt;&#34;
            )
            if nType in sectionTypeSet
            else f&#39;&lt;span class=&#34;structure&#34;&gt;{app.structureStrFromNode(n)}&lt;/span&gt;&#39;
            if nType in structureTypeSet
            else htmlSafe(
                T.text(
                    n,
                    fmt=fmt,
                    descend=descend,
                    outer=outer,
                    first=first,
                    last=last,
                    level=level,
                ),
                isHtml,
            )
        )
        if tpl is True
        else (
            (
                tpl.format(
                    **{feat: getValue(app, n, nType, feat, suppress) for feat in feats}
                )
                + x
            )
            if standardFeatures
            else &#34;&#34;
        )
    )
    return tplFilled</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.getTuplesX"><code class="name flex">
<span>def <span class="ident">getTuplesX</span></span>(<span>app, results, condenseType, fmt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform a non-uniform iterable of nodes into a table with extra information.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>results</code></strong> :&ensp;<code>iterable</code> of <code>tuple</code> of <code>int</code></dt>
<dd>A uniform <code><a title="tf.advanced.helpers.isUniform" href="#tf.advanced.helpers.isUniform">isUniform()</a></code> sequence of tuples of nodes</dd>
<dt><strong><code>condenseType</code></strong> :&ensp;<code>string</code></dt>
<dd>A node type. Types smaller or equal than this type will have their text
displayed in the result.</dd>
<dt><strong><code>fmt</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>A text format. If text has to be displayed, this format is used.
If not passed, a default is used.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L511-L566" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getTuplesX(app, results, condenseType, fmt=None):
    &#34;&#34;&#34;Transform a non-uniform iterable of nodes into a table with extra information.

    Parameters
    ----------
    results: iterable of tuple of int
        A uniform `isUniform` sequence of tuples of nodes
    condenseType: string
        A node type. Types smaller or equal than this type will have their text
        displayed in the result.
    fmt: string, optional `None`
        A text format. If text has to be displayed, this format is used.
        If not passed, a default is used.
    &#34;&#34;&#34;

    api = app.api
    F = api.F
    T = api.T
    N = api.N
    fOtype = F.otype.v
    otypeRank = N.otypeRank
    sectionTypeSet = T.sectionTypeSet

    aContext = app.context
    noDescendTypes = aContext.noDescendTypes

    sectionDepth = len(sectionTypeSet)
    if len(results) == 0:
        return ()

    def withText(nodeType):
        return (
            condenseType is None
            and nodeType not in sectionTypeSet
            or otypeRank[nodeType] &lt;= otypeRank[condenseType]
        )

    noDescendTypes = noDescendTypes

    rows = []

    for (tm, tup) in enumerate(results):
        tn = tm + 1
        row = [tn]
        for n in tup:
            sparts = T.sectionFromNode(n)
            nParts = len(sparts)
            section = sparts + ((None,) * (sectionDepth - nParts))
            row.extend(section)
            nType = fOtype(n)
            row.extend((n, nType))
            if withText(nType):
                text = T.text(n, fmt=fmt, descend=nType not in noDescendTypes)
                row.append(text)
        rows.append(tuple(row))
    return tuple(rows)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.getValue"><code class="name flex">
<span>def <span class="ident">getValue</span></span>(<span>app, n, nType, feat, suppress)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L361-L375" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getValue(app, n, nType, feat, suppress):
    F = app.api.F
    Fs = app.api.Fs

    customMethods = app.customMethods
    transform = customMethods.transform
    if feat in suppress:
        val = &#34;&#34;
    else:
        featObj = Fs(feat) if hasattr(F, feat) else None
        val = htmlEsc(featObj.v(n)) if featObj else None
        modifier = transform.get(nType, {}).get(feat, None)
        if modifier:
            val = modifier(n, val)
    return f&#39;&lt;span title=&#34;{feat}&#34;&gt;{val}&lt;/span&gt;&#39;</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.hasData"><code class="name flex">
<span>def <span class="ident">hasData</span></span>(<span>backend, local, org, repo, version, relative)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L165-L177" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hasData(backend, local, org, repo, version, relative):
    versionRep = f&#34;/{version}&#34; if version else &#34;&#34;
    if local == &#34;clone&#34;:
        cloneBase = backendRep(backend, &#34;clone&#34;)
        ghTarget = f&#34;{cloneBase}/{org}/{repo}/{relative}{versionRep}&#34;
        if os.path.exists(ghTarget):
            return cloneBase

    cacheBase = backendRep(backend, &#34;cache&#34;)
    cacheTarget = f&#34;{cacheBase}/{org}/{repo}/{relative}{versionRep}&#34;
    if os.path.exists(cacheTarget):
        return cacheBase
    return False</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.htmlSafe"><code class="name flex">
<span>def <span class="ident">htmlSafe</span></span>(<span>text, isHtml)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L298-L299" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def htmlSafe(text, isHtml):
    return text if isHtml else htmlEsc(text)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.isUniform"><code class="name flex">
<span>def <span class="ident">isUniform</span></span>(<span>app, tuples)</span>
</code></dt>
<dd>
<div class="desc"><p>Whether the members of tuples are uniform.</p>
<p>An iterable of tuples of nodes is uniform, if each
tuple has the same number of nodes,
and if the type of a node at position <em>i</em> in the tuple
is the same for all tuples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L381-L410" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isUniform(app, tuples):
    &#34;&#34;&#34;Whether the members of tuples are uniform.

    An iterable of tuples of nodes is uniform, if each
    tuple has the same number of nodes,
    and if the type of a node at position *i* in the tuple
    is the same for all tuples.
    &#34;&#34;&#34;
    api = app.api
    F = api.F
    fOtype = F.otype.v

    uniform = True
    fixedLength = None
    fixedTypes = None

    for tup in tuples:
        thisLength = len(tup)
        theseTypes = tuple(fOtype(n) for n in tup)

        if fixedLength is None:
            fixedLength = thisLength
        if fixedTypes is None:
            fixedTypes = theseTypes

        if thisLength != fixedLength or theseTypes != fixedTypes:
            uniform = False
            break

    return uniform</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.parseFeatures"><code class="name flex">
<span>def <span class="ident">parseFeatures</span></span>(<span>features)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L211-L237" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parseFeatures(features):
    if (
        type(features) in SEQ_TYPES1
        and len(features) == 2
        and type(features[0]) in SEQ_TYPES2
        and type(features[1]) is dict
    ):
        return features

    bare = []
    indirect = {}
    feats = (
        ()
        if not features
        else features.split()
        if type(features) is str
        else tuple(features)
    )
    for feat in feats:
        if not feat:
            continue
        parts = feat.split(&#34;:&#34;, 1)
        feat = parts[-1]
        bare.append(feat)
        if len(parts) &gt; 1:
            indirect[feat] = parts[0]
    return (bare, indirect)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.runsInNotebook"><code class="name flex">
<span>def <span class="ident">runsInNotebook</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines whether the program runs in an interactive shell.</p>
<p>From <a href="https://stackoverflow.com/questions/15411967/how-can-i-check-if-code-is-executed-in-the-ipython-notebook/24937408">https://stackoverflow.com/questions/15411967/how-can-i-check-if-code-is-executed-in-the-ipython-notebook/24937408</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L22-L37" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def runsInNotebook():
    &#34;&#34;&#34;Determines whether the program runs in an interactive shell.

    From https://stackoverflow.com/questions/15411967/how-can-i-check-if-code-is-executed-in-the-ipython-notebook/24937408
    &#34;&#34;&#34;
    try:
        runcontext = get_ipython()
        shell = runcontext.__class__.__name__
        if shell == &#34;ZMQInteractiveShell&#34;:
            return True  # Jupyter notebook or qtconsole
        elif shell == &#34;TerminalInteractiveShell&#34;:
            return False  # Terminal running IPython
        else:
            return False  # Other type (?)
    except NameError:
        return False  # Probably standard Python interpreter</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.showDict"><code class="name flex">
<span>def <span class="ident">showDict</span></span>(<span>title, data, inNb, *keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows selected keys of a dictionary in a pretty way.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inNb</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether we run in a notebook.</dd>
<dt><strong><code>keys</code></strong> :&ensp;<code>iterable</code> of <code>string</code></dt>
<dd>For each key passed to this function, the information for that key
will be displayed. If no keys are passed, all keys will be displayed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>displayed HTML</code></dt>
<dd>An expandable list of the key-value pair for the requested keys.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L621-L651" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showDict(title, data, inNb, *keys):
    &#34;&#34;&#34;Shows selected keys of a dictionary in a pretty way.

    Parameters
    ----------
    inNb: boolean
        Whether we run in a notebook.
    keys: iterable of string
        For each key passed to this function, the information for that key
        will be displayed. If no keys are passed, all keys will be displayed.

    Returns
    -------
    displayed HTML
        An expandable list of the key-value pair for the requested keys.
    &#34;&#34;&#34;

    keys = set(keys)

    openRep1 = &#34;open&#34; if len(keys) else &#34;&#34;
    openRep2 = &#34;open&#34; if len(keys) == 1 else &#34;&#34;
    md = [f&#34;&lt;details {openRep1}&gt;&#34; f&#34;&lt;summary&gt;{title}&lt;/summary&gt;\n\n&#34;]
    for (i, (k, v)) in enumerate(sorted(data.items(), key=lambda y: str(y))):
        if len(keys) and k not in keys:
            continue
        md.append(
            f&#34;&lt;details {openRep2}&gt;&#34;
            f&#34;&lt;summary&gt;{i + 1}. {k}&lt;/summary&gt;\n\n{eData(v, 0)}\n&lt;/details&gt;\n&#34;
        )
    md.append(&#34;&lt;/details&gt;\n&#34;)
    dm(&#34;&#34;.join(md), inNb=inNb)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.splitModRef"><code class="name flex">
<span>def <span class="ident">splitModRef</span></span>(<span>moduleRef)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L112-L145" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def splitModRef(moduleRef):
    thisBackend.clear()
    theBackend = None
    bareModuleRef = BACKEND_RE.sub(backendRepl, moduleRef)
    if len(thisBackend):
        theBackend = thisBackend[0]
        if len(thisBackend) &gt; 1:
            console(
                f&#34;Multiple &lt;backend&gt; in {moduleRef}: &#34;
                f&#34;{&#39;, &#39;.join(thisBackend)}; using &lt;{theBackend}&gt; only &#34;,
                error=True,
            )

    bRep = f&#34;&lt;{theBackend}&gt;&#34; if theBackend else &#34;&#34;

    parts = bareModuleRef.split(&#34;:&#34;, 1)
    if len(parts) == 1:
        parts.append(&#34;&#34;)
    (ref, specifier) = parts
    parts = ref.split(&#34;/&#34;, 2)

    if len(parts) &lt; 2:
        console(
            f&#34;&#34;&#34;
Module ref &#34;{bRep}{bareModuleRef}&#34; is not &#34;{{org}}/{{repo}}/{{path}}&#34;
&#34;&#34;&#34;,
            error=True,
        )
        return None

    if len(parts) == 2:
        parts.append(&#34;&#34;)

    return [*parts, specifier, theBackend]</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.transitiveClosure"><code class="name flex">
<span>def <span class="ident">transitiveClosure</span></span>(<span>relation, reflexiveExceptions)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce the reflexive transitive closure of a relation.</p>
<p>The transitive closure of a relation R is the relation TR
such that aTRb if and only if there is a chain of c1, c2, &hellip;, cn
such that ARc1, c1Rc2, &hellip;, cnRb.</p>
<p>If we allow the chain to have length zero, we effectively have that
aTRa for all elements. That is the reflexive, transitive closure.</p>
<p>This function builds the latter, but we allow for exceptions to the
reflexivity.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>relation</code></strong> :&ensp;<code>dict</code></dt>
<dd>The input relation, keyed by elements, valued by the set of
elements that stand in relation to the key.</dd>
<dt><strong><code>reflexiveExceptions</code></strong> :&ensp;<code>set</code></dt>
<dd>The set of elements that will not be reflexively closed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The transitive reflexive closure (with possible exceptions to
the reflexivity) of the given relation.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>We use this function to build the closure of the childType relation
between node types. We want to exclude the slot type from the
reflexivity. The closure of the childType relation is the descendant type
relation.
The display algorithm uses this to unravel nodes.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="tf.advanced.display" href="display.html">tf.advanced.display</a></code></dt>
<dd>Display algorithm</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L240-L295" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def transitiveClosure(relation, reflexiveExceptions):
    &#34;&#34;&#34;Produce the reflexive transitive closure of a relation.

    The transitive closure of a relation R is the relation TR
    such that aTRb if and only if there is a chain of c1, c2, ..., cn
    such that ARc1, c1Rc2, ..., cnRb.

    If we allow the chain to have length zero, we effectively have that
    aTRa for all elements. That is the reflexive, transitive closure.

    This function builds the latter, but we allow for exceptions to the
    reflexivity.

    Parameters
    ----------
    relation: dict
        The input relation, keyed by elements, valued by the set of
        elements that stand in relation to the key.
    reflexiveExceptions: set
        The set of elements that will not be reflexively closed.

    Returns
    -------
    dict
        The transitive reflexive closure (with possible exceptions to
        the reflexivity) of the given relation.

    Notes
    -----
    We use this function to build the closure of the childType relation
    between node types. We want to exclude the slot type from the
    reflexivity. The closure of the childType relation is the descendant type
    relation.
    The display algorithm uses this to unravel nodes.

    See also
    --------
    tf.advanced.display: Display algorithm
    &#34;&#34;&#34;

    descendants = {parent: set(children) for (parent, children) in relation.items()}

    changed = True
    while changed:
        changed = False
        for (parent, children) in relation.items():
            for child in children:
                if child in descendants:
                    for grandChild in descendants[child]:
                        if grandChild not in descendants[parent]:
                            descendants[parent].add(grandChild)
                            changed = True
    for parent in relation:
        if parent not in reflexiveExceptions:
            descendants[parent].add(parent)
    return descendants</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.tupleEnum"><code class="name flex">
<span>def <span class="ident">tupleEnum</span></span>(<span>tuples, start, end, limit, item, inNb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ca87a0b6d3aa3ca0a1013b3db5a195eaef7b5ace/tf/advanced/helpers.py#L180-L208" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tupleEnum(tuples, start, end, limit, item, inNb):
    if start is None:
        start = 1
    i = -1
    if not hasattr(tuples, &#34;__len__&#34;):
        if end is None or end - start + 1 &gt; limit:
            end = start - 1 + limit
        for tup in tuples:
            i += 1
            if i &lt; start - 1:
                continue
            if i &gt;= end:
                break
            yield (i + 1, tup)
    else:
        if end is None or end &gt; len(tuples):
            end = len(tuples)
        rest = 0
        if end - (start - 1) &gt; limit:
            rest = end - (start - 1) - limit
            end = start - 1 + limit
        for i in range(start - 1, end):
            yield (i + 1, tuples[i])
        if rest:
            dh(
                f&#34;&lt;b&gt;{rest} more {item}s skipped&lt;/b&gt; because we show a maximum of&#34;
                f&#34; {limit} {item}s at a time&#34;,
                inNb=inNb,
            )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.advanced" href="index.html">tf.advanced</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tf.advanced.helpers.backendRepl" href="#tf.advanced.helpers.backendRepl">backendRepl</a></code></li>
<li><code><a title="tf.advanced.helpers.dh" href="#tf.advanced.helpers.dh">dh</a></code></li>
<li><code><a title="tf.advanced.helpers.dm" href="#tf.advanced.helpers.dm">dm</a></code></li>
<li><code><a title="tf.advanced.helpers.eData" href="#tf.advanced.helpers.eData">eData</a></code></li>
<li><code><a title="tf.advanced.helpers.eDict" href="#tf.advanced.helpers.eDict">eDict</a></code></li>
<li><code><a title="tf.advanced.helpers.eEmpty" href="#tf.advanced.helpers.eEmpty">eEmpty</a></code></li>
<li><code><a title="tf.advanced.helpers.eList" href="#tf.advanced.helpers.eList">eList</a></code></li>
<li><code><a title="tf.advanced.helpers.eRest" href="#tf.advanced.helpers.eRest">eRest</a></code></li>
<li><code><a title="tf.advanced.helpers.eScalar" href="#tf.advanced.helpers.eScalar">eScalar</a></code></li>
<li><code><a title="tf.advanced.helpers.getLocalDir" href="#tf.advanced.helpers.getLocalDir">getLocalDir</a></code></li>
<li><code><a title="tf.advanced.helpers.getResultsX" href="#tf.advanced.helpers.getResultsX">getResultsX</a></code></li>
<li><code><a title="tf.advanced.helpers.getRowsX" href="#tf.advanced.helpers.getRowsX">getRowsX</a></code></li>
<li><code><a title="tf.advanced.helpers.getText" href="#tf.advanced.helpers.getText">getText</a></code></li>
<li><code><a title="tf.advanced.helpers.getTuplesX" href="#tf.advanced.helpers.getTuplesX">getTuplesX</a></code></li>
<li><code><a title="tf.advanced.helpers.getValue" href="#tf.advanced.helpers.getValue">getValue</a></code></li>
<li><code><a title="tf.advanced.helpers.hasData" href="#tf.advanced.helpers.hasData">hasData</a></code></li>
<li><code><a title="tf.advanced.helpers.htmlSafe" href="#tf.advanced.helpers.htmlSafe">htmlSafe</a></code></li>
<li><code><a title="tf.advanced.helpers.isUniform" href="#tf.advanced.helpers.isUniform">isUniform</a></code></li>
<li><code><a title="tf.advanced.helpers.parseFeatures" href="#tf.advanced.helpers.parseFeatures">parseFeatures</a></code></li>
<li><code><a title="tf.advanced.helpers.runsInNotebook" href="#tf.advanced.helpers.runsInNotebook">runsInNotebook</a></code></li>
<li><code><a title="tf.advanced.helpers.showDict" href="#tf.advanced.helpers.showDict">showDict</a></code></li>
<li><code><a title="tf.advanced.helpers.splitModRef" href="#tf.advanced.helpers.splitModRef">splitModRef</a></code></li>
<li><code><a title="tf.advanced.helpers.transitiveClosure" href="#tf.advanced.helpers.transitiveClosure">transitiveClosure</a></code></li>
<li><code><a title="tf.advanced.helpers.tupleEnum" href="#tf.advanced.helpers.tupleEnum">tupleEnum</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>