<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tf.advanced.repo API documentation</title>
<meta name="description" content="Auto downloading from GitHub â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.advanced.repo</code></h1>
</header>
<section id="section-intro">
<h1 id="auto-downloading-from-github">Auto downloading from GitHub</h1>
<pre><code class="language-python">from tf.advanced.repo import checkoutRepo

checkoutRepo(
  org='annotation'
  repo='tutorials',
  folder='text-fabric/examples/banks/tf',
  version='',
  checkout='',
  source=None,
  dest=None,
  withPaths=True,
  keep=True,
  silent=False,
  label='data',
)
</code></pre>
<h2 id="description">Description</h2>
<p>Maintain a local copy of a subfolder <em>folder</em> in GitHub repository <em>repo</em> of <em>org</em>.
The copy may be taken from any point in the commit history of the online repo.</p>
<p>If you call this function, it will check whether the requested data is already
on your computer in the expected location.
If not, it may check whether the data is online and if so, download it to the
expected location.</p>
<h2 id="result">Result</h2>
<p>The result of a call to checkoutRepo() is a tuple:</p>
<pre><code class="language-python">    (commitOffline, releaseOffline, kindLocal, localBase, localDir)
</code></pre>
<p>Here is the meaning:</p>
<ul>
<li><em>commitOffline</em> is the commit hash of the data you have offline afterwards</li>
<li><em>releaseOffline</em> is the release tag of the data you have offline afterwards</li>
<li><em>kindLocal</em> indicates whether an online check has been performed:
it is <code>None</code> if there has been an online check. Otherwise it is
<code>clone</code> if the data is in your <code>~/github</code> directory else it is <code>local</code>.</li>
<li><em>localBase</em> where the data is under: <code>~/github</code> or <code>~/text-fabric-data</code>,
or whatever you have passed as <em>source</em> and <em>dest</em>, see below.</li>
<li><em>localDir</em> releative path from <em>localBase</em> to your data.
If your data has versions, <em>localDir</em> points to directory that has the versions,
not to a specific version.</li>
</ul>
<p>Your local copy can be found under your <code>~/github</code> or <code>~/text-fabric-data</code>
directory using a relative path <em>org/repo/folder</em> if there is a <em>version</em>, else
<em>org/repo/folder/version</em>.</p>
<h2 id="checkout-source-and-dest">checkout, source and dest</h2>
<p>The <em>checkout</em> parameter determines from which point in the history the copy
will be taken and where it will be placed.
That will be either your <code>~/github</code> or your <code>~/text-fabric-data</code> directories.</p>
<p>You can override the hard-coded <code>~/github</code> and <code>~/text-fabric-data</code> directories
by passing <em>source</em> and <em>dest</em> respectively.</p>
<p>See the
<a href="https://nbviewer.jupyter.org/github/annotation/tutorials/blob/master/banks/repo.ipynb">repo</a>
notebook for an exhaustive demo of all the checkout options.</p>
<h2 id="other-parameters">other parameters</h2>
<p><em>withPaths=False</em> will loose the directory structure of files that are being
downloaded.</p>
<p><em>keep=False</em> will destroy the destination directory before a download takes place.</p>
<p><em>silent=True</em> will suppress non-error messages.</p>
<p>*label='something' will change the word "data" in log messages to what you choose.
We use <code>label='TF-app'</code> when we use this function to checkout the code
of a TF-app.</p>
<h2 id="rate-limiting">Rate limiting</h2>
<p>The <code>checkRepo()</code> function uses the GitHub API.
GitHub has a rate limiting policy for its API of max 60 calls per hour.
See below to deal with this if it becomes a problem.</p>
<h1 id="github">GitHub</h1>
<p>GitHub has a rate limiting policy for its API of max 60 calls per hour.
This can be too restrictive, and here are two ways to keep working nevertheless.</p>
<h2 id="increase-the-rate-limit">Increase the rate limit</h2>
<p>If you use this function in an application of yours that uses it very often,
you can increase the limit to 5000 calls per hour by making yourself known.</p>
<ul>
<li><a href="https://github.com/settings/tokens">create a personal access token</a></li>
<li>Copy your token and put it in an environment variable named <code>GHPERS</code>
on the system where your app runs.
See below how to do that.</li>
<li>If <code><a title="tf.advanced.repo.checkoutRepo" href="#tf.advanced.repo.checkoutRepo">checkoutRepo()</a></code> finds this variable, it will add the
token to every GitHub API call it makes, and that will
increase the rate.</li>
<li>Never pass your personal credentials on to others, let them obtain their own!</li>
</ul>
<p>You might want to read this:</p>
<ul>
<li><a href="https://developer.github.com/v3/#rate-limiting">Read more about rate limiting on Github</a></li>
</ul>
<p>How to put your personal access token into an environment variable?</p>
<div class="admonition note">
<p class="admonition-title">What is an environment variable?</p>
<p>It is a setting on your system that various programs/processes can read.
On Windows it is part of the <code>Registry</code>.</p>
<p>In this particular case, you put a personal token that you obtain from GitHub
in such an environment variable.
When Text-Fabric accesses GitHub, it will look up this token
first, and pass it to the GitHub API. GitHub then knows who you are and
will give you more privileges.</p>
</div>
<h3 id="on-mac-and-linux">On Mac and Linux</h3>
<p>Find the file that contains your terminal settings. In many cases that is
<code>.bash_profile</code> in your home directory.</p>
<p>Some people put commands like these in their <code>~/.bashrc</code> file, which is also fine.
If you do not see a <code>.bashrc</code> file, put it into your <code>.bash_profile</code> file.</p>
<p>A slightly more advanced shell than <code>bash</code> is <code>zsh</code> and it is the default on newer
Macs. If that is your case, look for a file <code>.zshrc</code> in your home directory or
create one.</p>
<p>Whatever is your case, pick the file indicated above and edit it.</p>
<div class="admonition hint">
<p class="admonition-title">How to edit a file in your terminal?</p>
<p>If you are already familiar with <code>vi</code>, <code>vim</code>, <code>emacs</code>, or <code>nano</code>
you already know how to do it.</p>
<p>If not, <code>nano</code> is simple editor that is useful for tasks like this.
Assuming that you want to edit the <code>.zshrc</code> in your home directory,
go to your terminal and say this:</p>
<pre><code>nano ~/.zshrc
</code></pre>
<p>Then you get a view on your file. Then</p>
<ul>
<li>press <code>Ctrl V</code> a number of times till you are at the end of the file,</li>
<li>type the two lines lines of text (specified in the next step), or
copy them from the clipboard</li>
<li>type <code>Ctrl X</code> to exit; nano will ask you to save changes, type <code>Y</code>,
it will then verify the file name, type <code>Enter</code> and you're done</li>
</ul>
</div>
<p>Put the following lines in this file:</p>
<pre><code class="language-sh">GHPERS=&quot;xxx&quot;
export GHPERS
</code></pre>
<p>where the <code>xxx</code> are replaced by your actual token.</p>
<p>Then restart your terminal or say in an existing terminal</p>
<pre><code class="language-sh">source ~/.zshrc
</code></pre>
<h3 id="on-windows">On Windows</h3>
<p>Click on the Start button and type in <code>environment variable</code> into the search box.</p>
<p>Click on <code>Edit the system environment variables</code>.</p>
<p>This will
open up the System Properties dialog to the Advanced tab.</p>
<p>Click on the <code>Environment Variables button</code> at the bottom.</p>
<p>Click on <code>New &hellip;</code> under <code>User environment variables</code>.</p>
<p>Then fill in <code>GHPERS</code> under <em>name</em> and the token string under <em>value</em>.</p>
<p>Then quit the command prompt and start a new one.</p>
<h3 id="result_1">Result</h3>
<p>With this done, you will automatically get the good rate limit,
whenever you fire up Text-Fabric in the future.</p>
<h2 id="minimize-accessing-github">Minimize accessing Github</h2>
<p>Another way te avoid being bitten by the rate limit is to reduce the number
of your access actions to GitHub.</p>
<p>There are two instances where Text-Fabric wants to access GitHub:</p>
<ol>
<li>when you start the Text-Fabric browser from the command line</li>
<li>when you give the <code>use()</code> command in your Python program (or in a Jupyter Notebook).</li>
</ol>
<h3 id="using-a-corpus-for-the-first-time-within-the-rate-limit">Using a corpus for the first time, within the rate limit</h3>
<p>If you are still within the rate limit, just give the usual commands, such as</p>
<pre><code class="language-sh">text-fabric corpus
</code></pre>
<p>or</p>
<pre><code class="language-python">use('corpus', hoist=globals())
</code></pre>
<p>where <code>corpus</code> should be replaced with the real name of your corpus.</p>
<p>The data will be downloaded to your computer and stored in your
<code>~/text-fabric-data</code> directory tree.</p>
<h3 id="using-a-corpus-for-the-first-time-after-hitting-the-rate-limit">Using a corpus for the first time, after hitting the rate limit</h3>
<p>If you want to load a new corpus after having passed the rate limit, and not
wanting to wait an hour, you could directly clone the repos from GitHub:</p>
<p>Open your terminal, and go to (or create) directory <code>~/github</code> (in your
home directory).</p>
<p>Inside that directory, go to or create directory <code>annotation</code>.
Go to that directory.</p>
<p>Then do</p>
<pre><code class="language-sh">git clone https://github.com/annotation/app-corpus
</code></pre>
<p>(replacing <code>corpus</code> with the name of your corpus).</p>
<p>This will fetch the Text-Fabric <em>app</em> for that corpus.</p>
<p>Now the corpus data itself:</p>
<p>Find out where on GitHub it is (organization/corpus), e.g.
<code>Nino-cunei/oldbabylonian</code> or <code>etcbc/bhsa</code>.</p>
<p>Under your local <code>~/github</code>, find or create directory <code>organization</code>.
Then go to that directory and say:</p>
<pre><code class="language-sh">git clone https://github.com/organization/corpus
</code></pre>
<p>(replacing <code>organization</code> with the name of the organization where the corpus resides
and <code>corpus</code> with the name of your corpus).
Now you have all data you need on your system.</p>
<p>If you want to see by example how to use this data, have a look at
<a href="https://nbviewer.jupyter.org/github/annotation/tutorials/blob/master/banks/repo.ipynb">repo</a>,
especially when it discusses <code>clone</code>.</p>
<p>In order to run Text-Fabric without further access to GitHub, say</p>
<pre><code class="language-sh">text-fabric corpus:clone checkout=clone
</code></pre>
<p>or, in a program,</p>
<pre><code class="language-python">A = use('corpus:clone', checkData='clone', hoist=globals())
</code></pre>
<p>This will instruct Text-Fabric to use the app and data from within your <code>~/github</code>
directory tree.</p>
<h3 id="using-a-corpus-that-you-already-have">Using a corpus that you already have</h3>
<p>Depending on how you got the corpus, it is in your
<code>~/github</code> or in your <code>~/text-fabric-data</code> directory tree.</p>
<p>If you cloned it from GitHub or created it yourself, it is in your <code>~/github</code> tree;
if you used the autoload of Text-Fabric it is in your <code>~/text-fabric-data</code>.</p>
<p>In the first case, do this:</p>
<pre><code class="language-sh">text-fabric corpus:clone checkout=clone
</code></pre>
<p>or, in a program,</p>
<pre><code class="language-python">A = use('corpus:clone', checkData='clone', hoist=globals())
</code></pre>
<p>In the second case, do just this:</p>
<pre><code class="language-sh">text-fabric corpus
</code></pre>
<p>or, in a program,</p>
<pre><code class="language-python">A = use('corpus', hoist=globals())
</code></pre>
<p>See also <code><a title="tf.advanced.app.App" href="app.html#tf.advanced.app.App">App</a></code>.</p>
<h3 id="updating-a-corpus-that-you-already-have">Updating a corpus that you already have</h3>
<p>If you cloned it from GitHub (or created it yourself in your <code>~/github</code> tree):</p>
<p>In your terminal:</p>
<pre><code class="language-sh">cd ~/github/organization/repo
git pull origin master
</code></pre>
<p>(replacing <code>organization</code> with the name of the organization where the corpus resides
and <code>corpus</code> with the name of your corpus).</p>
<p>Now you have the newest corpus data on your system. and you can use it as follows:</p>
<pre><code class="language-sh">text-fabric corpus:clone checkout=clone
</code></pre>
<p>or, in a program,</p>
<pre><code class="language-python">A = use('corpus:clone', checkData='clone', hoist=globals())
</code></pre>
<p>If you have autoloaded it from GitHub, you have to add the <code>latest</code> or <code>hot</code> specifier:</p>
<pre><code class="language-sh">text-fabric corpus:latest checkout=latest
</code></pre>
<p>or, in a program,</p>
<pre><code class="language-python">A = use('corpus:latest', checkData='latest', hoist=globals())
</code></pre>
<p>And after that, you can omit <code>latest</code> or <code>hot</code> again, until you need new data again.</p>
<div class="admonition hint">
<p class="admonition-title">App versus data</p>
<p>The checkout specifiers such as <code>latest</code>, <code>hot</code>, <code>clone</code> apply to either the corpus data
or the TF App.</p>
<p>If the specifier follows the app name, separated with a colon, it directs how the app code
is being obtained.</p>
<p>If it is the value of the <code>checkout</code> parameter, it directs how the corpus data
is being obtained.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L0-L1308" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Auto downloading from GitHub

```python
from tf.advanced.repo import checkoutRepo

checkoutRepo(
  org=&#39;annotation&#39;
  repo=&#39;tutorials&#39;,
  folder=&#39;text-fabric/examples/banks/tf&#39;,
  version=&#39;&#39;,
  checkout=&#39;&#39;,
  source=None,
  dest=None,
  withPaths=True,
  keep=True,
  silent=False,
  label=&#39;data&#39;,
)
```

## Description

Maintain a local copy of a subfolder *folder* in GitHub repository *repo* of *org*.
The copy may be taken from any point in the commit history of the online repo.

If you call this function, it will check whether the requested data is already
on your computer in the expected location.
If not, it may check whether the data is online and if so, download it to the
expected location.

## Result

The result of a call to checkoutRepo() is a tuple:

```python
    (commitOffline, releaseOffline, kindLocal, localBase, localDir)
```

Here is the meaning:

*   *commitOffline* is the commit hash of the data you have offline afterwards
*   *releaseOffline* is the release tag of the data you have offline afterwards
*   *kindLocal* indicates whether an online check has been performed:
    it is `None` if there has been an online check. Otherwise it is
    `clone` if the data is in your `~/github` directory else it is `local`.
*   *localBase* where the data is under: `~/github` or `~/text-fabric-data`,
    or whatever you have passed as *source* and *dest*, see below.
*   *localDir* releative path from *localBase* to your data.
    If your data has versions, *localDir* points to directory that has the versions,
    not to a specific version.


Your local copy can be found under your `~/github` or `~/text-fabric-data`
directory using a relative path *org/repo/folder* if there is a *version*, else
*org/repo/folder/version*.

## checkout, source and dest

The *checkout* parameter determines from which point in the history the copy
will be taken and where it will be placed.
That will be either your `~/github` or your `~/text-fabric-data` directories.

You can override the hard-coded `~/github` and `~/text-fabric-data` directories
by passing *source* and *dest* respectively.

See the
[repo](https://nbviewer.jupyter.org/github/annotation/tutorials/blob/master/banks/repo.ipynb)
notebook for an exhaustive demo of all the checkout options.

## other parameters

*withPaths=False* will loose the directory structure of files that are being
downloaded.

*keep=False* will destroy the destination directory before a download takes place.

*silent=True* will suppress non-error messages.

*label=&#39;something&#39; will change the word &#34;data&#34; in log messages to what you choose.
We use `label=&#39;TF-app&#39;` when we use this function to checkout the code
of a TF-app.

## Rate limiting

The `checkRepo()` function uses the GitHub API.
GitHub has a rate limiting policy for its API of max 60 calls per hour.
See below to deal with this if it becomes a problem.

# GitHub

GitHub has a rate limiting policy for its API of max 60 calls per hour.
This can be too restrictive, and here are two ways to keep working nevertheless.

## Increase the rate limit

If you use this function in an application of yours that uses it very often,
you can increase the limit to 5000 calls per hour by making yourself known.

* [create a personal access token](https://github.com/settings/tokens)
* Copy your token and put it in an environment variable named `GHPERS`
  on the system where your app runs.
  See below how to do that.
* If `checkoutRepo` finds this variable, it will add the
  token to every GitHub API call it makes, and that will
  increase the rate.
* Never pass your personal credentials on to others, let them obtain their own!

You might want to read this:

* [Read more about rate limiting on Github](https://developer.github.com/v3/#rate-limiting)

How to put your personal access token into an environment variable?

!!! note &#34;What is an environment variable?&#34;
    It is a setting on your system that various programs/processes can read.
    On Windows it is part of the `Registry`.

    In this particular case, you put a personal token that you obtain from GitHub
    in such an environment variable.
    When Text-Fabric accesses GitHub, it will look up this token
    first, and pass it to the GitHub API. GitHub then knows who you are and
    will give you more privileges.

### On Mac and Linux

Find the file that contains your terminal settings. In many cases that is
`.bash_profile` in your home directory.

Some people put commands like these in their `~/.bashrc` file, which is also fine.
If you do not see a `.bashrc` file, put it into your `.bash_profile` file.

A slightly more advanced shell than `bash` is `zsh` and it is the default on newer
Macs. If that is your case, look for a file `.zshrc` in your home directory or
create one.

Whatever is your case, pick the file indicated above and edit it.

!!! hint &#34;How to edit a file in your terminal?&#34;
    If you are already familiar with `vi`, `vim`, `emacs`, or `nano`
    you already know how to do it.

    If not, `nano` is simple editor that is useful for tasks like this.
    Assuming that you want to edit the `.zshrc` in your home directory,
    go to your terminal and say this:

        nano ~/.zshrc

    Then you get a view on your file. Then

    *   press `Ctrl V` a number of times till you are at the end of the file,
    *   type the two lines lines of text (specified in the next step), or
        copy them from the clipboard
    *   type `Ctrl X` to exit; nano will ask you to save changes, type `Y`,
        it will then verify the file name, type `Enter` and you&#39;re done

Put the following lines in this file:

``` sh
GHPERS=&#34;xxx&#34;
export GHPERS
```

where the `xxx` are replaced by your actual token.

Then restart your terminal or say in an existing terminal

```  sh
source ~/.zshrc
```

### On Windows

Click on the Start button and type in `environment variable` into the search box.

Click on `Edit the system environment variables`.

This will  open up the System Properties dialog to the Advanced tab.

Click on the `Environment Variables button` at the bottom.

Click on `New ...` under `User environment variables`.

Then fill in `GHPERS` under *name* and the token string under *value*.

Then quit the command prompt and start a new one.

### Result

With this done, you will automatically get the good rate limit,
whenever you fire up Text-Fabric in the future.

## Minimize accessing Github

Another way te avoid being bitten by the rate limit is to reduce the number
of your access actions to GitHub.

There are two instances where Text-Fabric wants to access GitHub:

1. when you start the Text-Fabric browser from the command line
2. when you give the `use()` command in your Python program (or in a Jupyter Notebook).

### Using a corpus for the first time, within the rate limit

If you are still within the rate limit, just give the usual commands, such as

``` sh
text-fabric corpus
```

or

``` python
use(&#39;corpus&#39;, hoist=globals())
```

where `corpus` should be replaced with the real name of your corpus.

The data will be downloaded to your computer and stored in your
`~/text-fabric-data` directory tree.

### Using a corpus for the first time, after hitting the rate limit

If you want to load a new corpus after having passed the rate limit, and not
wanting to wait an hour, you could directly clone the repos from GitHub:

Open your terminal, and go to (or create) directory `~/github` (in your
home directory).

Inside that directory, go to or create directory `annotation`.
Go to that directory.

Then do

``` sh
git clone https://github.com/annotation/app-corpus
```

(replacing `corpus` with the name of your corpus).

This will fetch the Text-Fabric *app* for that corpus.

Now the corpus data itself:

Find out where on GitHub it is (organization/corpus), e.g.
`Nino-cunei/oldbabylonian` or `etcbc/bhsa`.

Under your local `~/github`, find or create directory `organization`.
Then go to that directory and say:

``` sh
git clone https://github.com/organization/corpus
```

(replacing `organization` with the name of the organization where the corpus resides
and `corpus` with the name of your corpus).
Now you have all data you need on your system.

If you want to see by example how to use this data, have a look at
[repo](https://nbviewer.jupyter.org/github/annotation/tutorials/blob/master/banks/repo.ipynb),
especially when it discusses `clone`.

In order to run Text-Fabric without further access to GitHub, say

``` sh
text-fabric corpus:clone checkout=clone
```

or, in a program,

``` python
A = use(&#39;corpus:clone&#39;, checkData=&#39;clone&#39;, hoist=globals())
```

This will instruct Text-Fabric to use the app and data from within your `~/github`
directory tree.

### Using a corpus that you already have

Depending on how you got the corpus, it is in your
`~/github` or in your `~/text-fabric-data` directory tree.

If you cloned it from GitHub or created it yourself, it is in your `~/github` tree;
if you used the autoload of Text-Fabric it is in your `~/text-fabric-data`.

In the first case, do this:

``` sh
text-fabric corpus:clone checkout=clone
```

or, in a program,

``` python
A = use(&#39;corpus:clone&#39;, checkData=&#39;clone&#39;, hoist=globals())
```

In the second case, do just this:

``` sh
text-fabric corpus
```

or, in a program,

``` python
A = use(&#39;corpus&#39;, hoist=globals())
```

See also `tf.advanced.app.App`.

### Updating a corpus that you already have

If you cloned it from GitHub (or created it yourself in your `~/github` tree):

In your terminal:

``` sh
cd ~/github/organization/repo
git pull origin master
```

(replacing `organization` with the name of the organization where the corpus resides
and `corpus` with the name of your corpus).

Now you have the newest corpus data on your system. and you can use it as follows:

``` sh
text-fabric corpus:clone checkout=clone
```

or, in a program,

``` python
A = use(&#39;corpus:clone&#39;, checkData=&#39;clone&#39;, hoist=globals())
```

If you have autoloaded it from GitHub, you have to add the `latest` or `hot` specifier:

``` sh
text-fabric corpus:latest checkout=latest
```

or, in a program,

``` python
A = use(&#39;corpus:latest&#39;, checkData=&#39;latest&#39;, hoist=globals())
```

And after that, you can omit `latest` or `hot` again, until you need new data again.

!!! hint &#34;App versus data&#34;
    The checkout specifiers such as `latest`, `hot`, `clone` apply to either the corpus data
    or the TF App.

    If the specifier follows the app name, separated with a colon, it directs how the app code
    is being obtained.

    If it is the value of the `checkout` parameter, it directs how the corpus data
    is being obtained.
&#34;&#34;&#34;

import os
import io
import re
from shutil import rmtree
import requests
import base64
from zipfile import ZipFile

from github import Github, GithubException, UnknownObjectException

from ..parameters import (
    URL_GH,
    URL_TFDOC,
    GH_BASE,
    EXPRESS_BASE,
    EXPRESS_SYNC,
    EXPRESS_SYNC_LEGACY,
    DOWNLOADS,
)
from ..core.helpers import console, htmlEsc
from .helpers import dh
from .zipdata import zipData


class Repo:
    def __init__(
        self,
        org,
        repo,
        folder,
        version,
        increase,
        source=GH_BASE,
        dest=DOWNLOADS,
    ):
        self.org = org
        self.repo = repo
        self.folder = folder
        self.version = version
        self.increase = increase
        self.source = os.path.expanduser(source)
        self.dest = os.path.expanduser(dest)

        self.repoOnline = None
        self.ghConn = None

    def newRelease(self):
        if not self.makeZip():
            return False

        self.connect()
        if not self.ghConn:
            return False

        if not self.fetchInfo():
            return False

        if not self.bumpRelease():
            return False

        if not self.makeRelease():
            return False

        if not self.uploadZip():
            return False

        return True

    def makeZip(self):
        source = self.source
        dest = self.dest
        org = self.org
        repo = self.repo
        folder = self.folder
        version = self.version

        dataIn = f&#34;{source}/{org}/{repo}/{folder}/{version}&#34;

        if not os.path.exists(dataIn):
            console(f&#34;No data found in {dataIn}&#34;, error=True)
            return False

        zipData(org, repo, version=version, relative=folder, source=source, dest=dest)
        return True

    def connect(self):
        warning = self.warning

        if not self.ghConn:
            ghPerson = os.environ.get(&#34;GHPERS&#34;, None)
            if ghPerson:
                self.ghConn = Github(ghPerson)
            else:
                ghClient = os.environ.get(&#34;GHCLIENT&#34;, None)
                ghSecret = os.environ.get(&#34;GHSECRET&#34;, None)
                if ghClient and ghSecret:
                    self.ghConn = Github(client_id=ghClient, client_secret=ghSecret)
                else:
                    self.ghConn = Github()
        try:
            rate = self.ghConn.get_rate_limit().core
            self.log(
                f&#34;rate limit is {rate.limit} requests per hour,&#34;
                f&#34; with {rate.remaining} left for this hour&#34;
            )
            if rate.limit &lt; 100:
                warning(f&#34;To increase the rate,&#34; f&#34;see {URL_TFDOC}/advanced/repo.html/&#34;)

            self.log(
                f&#34;\tconnecting to online GitHub repo {self.org}/{self.repo} ... &#34;,
                newline=False,
            )
            self.repoOnline = self.ghConn.get_repo(f&#34;{self.org}/{self.repo}&#34;)
            self.log(&#34;connected&#34;)
        except GithubException as why:
            warning(&#34;failed&#34;)
            warning(f&#34;GitHub says: {why}&#34;)
        except IOError:
            warning(&#34;no internet&#34;)

    def fetchInfo(self):
        g = self.repoOnline
        if not g:
            return False
        self.commitOn = None
        self.releaseOn = None
        self.releaseCommitOn = None
        result = self.getRelease()
        if result:
            self.releaseOn = result
        result = self.getCommit()
        if result:
            self.commitOn = result
        return True

    def bumpRelease(self):
        increase = self.increase

        latestR = self.releaseOn
        if latestR:
            console(f&#34;Latest release = {latestR}&#34;)
        else:
            latestR = &#34;v0.0.0&#34;
            console(&#34;No releases yet&#34;)

        # bump the release version

        v = &#34;&#34;
        if latestR.startswith(&#34;v&#34;):
            v = &#34;v&#34;
            r = latestR[1:] if latestR.startswith(&#34;v&#34;) else latestR
        parts = [int(p) for p in r.split(&#34;.&#34;)]
        nParts = len(parts)
        if nParts &lt; increase:
            for i in range(nParts, increase):
                parts.append(0)
        parts[increase - 1] += 1
        parts[increase:] = []
        newTag = f&#34;{v}{&#39;.&#39;.join(str(p) for p in parts)}&#34;
        console(f&#34;New release = {newTag}&#34;)
        self.newTag = newTag
        return True

    def makeRelease(self):
        commit = self.commitOn
        newTag = self.newTag

        g = self.repoOnline
        if not g:
            return False

        tag_message = &#34;data update&#34;
        release_name = &#34;data update&#34;
        release_message = &#34;data update&#34;

        try:
            newReleaseObj = g.create_git_tag_and_release(
                newTag,
                tag_message,
                release_name,
                release_message,
                commit,
                &#34;commit&#34;,
            )
        except Exception as e:
            self.error(&#34;\tcannot create release&#34;, newline=True)
            console(str(e), error=True)
            return False

        self.newReleaseObj = newReleaseObj
        return True

    def uploadZip(self):
        newTag = self.newTag
        newReleaseObj = self.newReleaseObj
        dest = self.dest
        org = self.org
        repo = self.repo
        folder = self.folder
        version = self.version
        dataFile = f&#34;{folder}-{version}.zip&#34;
        dataDir = f&#34;{dest}/{org}-release/{repo}&#34;
        dataPath = f&#34;{dataDir}/{dataFile}&#34;

        if not os.path.exists(dataPath):
            console(f&#34;No release data found: {dataPath}&#34;, error=True)
            return False

        try:
            newReleaseObj.upload_asset(dataPath, label=&#39;&#39;, content_type=&#34;application/zip&#34;, name=dataFile)
            console(f&#34;{dataFile} attached to release {newTag}&#34;)
        except Exception as e:
            self.error(&#34;\tcannot attach zipfile to release&#34;, newline=True)
            console(str(e), error=True)
            return False

        return True

    def getRelease(self):
        r = self.getReleaseObj()
        if not r:
            return None
        return r.tag_name

    def getReleaseObj(self):
        g = self.repoOnline
        if not g:
            return None

        r = None

        try:
            r = g.get_latest_release()
        except UnknownObjectException:
            self.error(&#34;\tno releases&#34;, newline=True)
        except Exception:
            self.error(&#34;\tcannot find releases&#34;, newline=True)
        return r

    def getCommit(self):
        c = self.getCommitObj()
        if not c:
            return None
        return c.sha

    def getCommitObj(self):
        error = self.error

        g = self.repoOnline
        if not g:
            return None

        c = None

        try:
            cs = g.get_commits()
            if cs.totalCount:
                c = cs[0]
            else:
                error(&#34;\tno commits&#34;)
        except Exception:
            error(&#34;\tcannot find commits&#34;)
        return c

    def log(self, msg, newline=True):
        console(msg, newline=newline)

    def warning(self, msg, newline=True):
        console(msg, newline=newline)

    def error(self, msg, newline=True):
        console(msg, error=True, newline=newline)


def releaseData(org, repo, folder, version, increase, source=GH_BASE, dest=DOWNLOADS):
    &#34;&#34;&#34;
    increase:
    1 = bump major version;
    2 = bump intermediate version;
    3 = bump minor version
    &#34;&#34;&#34;
    R = Repo(org, repo, folder, version, increase, source=source, dest=dest)
    return R.newRelease()


class Checkout(object):
    @staticmethod
    def fromString(string):
        commit = None
        release = None
        local = None
        if not string:
            commit = &#34;&#34;
            release = &#34;&#34;
        elif string == &#34;latest&#34;:
            commit = None
            release = &#34;&#34;
        elif string == &#34;hot&#34;:
            commit = &#34;&#34;
            release = None
        elif string in {&#34;local&#34;, &#34;clone&#34;}:
            commit = None
            release = None
            local = string
        elif &#34;.&#34; in string or len(string) &lt; 12:
            commit = None
            release = string
        else:
            commit = string
            release = None
        return (commit, release, local)

    @staticmethod
    def toString(commit, release, local, source=GH_BASE, dest=EXPRESS_BASE):
        extra = &#34;&#34;
        if local:
            baseRep = source if local == &#34;clone&#34; else dest
            extra = f&#34; offline under {baseRep}&#34;
        if local == &#34;clone&#34;:
            result = &#34;repo clone&#34;
        elif commit and release:
            result = f&#34;r{release}=#{commit}&#34;
        elif commit:
            result = f&#34;#{commit}&#34;
        elif release:
            result = f&#34;r{release}&#34;
        elif commit is None and release is None:
            result = &#34;unknown release or commit&#34;
        elif commit is None:
            result = &#34;latest release&#34;
        elif release is None:
            result = &#34;latest commit&#34;
        else:
            result = &#34;latest release or commit&#34;
        return f&#34;{result}{extra}&#34;

    def isClone(self):
        return self.local == &#34;clone&#34;

    def isOffline(self):
        return self.local in {&#34;clone&#34;, &#34;local&#34;}

    def __init__(
        self,
        org,
        repo,
        relative,
        checkout,
        source,
        dest,
        keep,
        withPaths,
        silent,
        _browse,
        version=None,
        label=&#34;data&#34;,
    ):
        self._browse = _browse
        self.label = label
        self.org = org
        self.repo = repo
        self.source = source
        self.dest = dest
        (self.commitChk, self.releaseChk, self.local) = self.fromString(checkout)
        clone = self.isClone()
        offline = self.isOffline()

        self.relative = relative
        self.version = version
        versionRep = f&#34;/{version}&#34; if version else &#34;&#34;
        self.versionRep = versionRep
        relativeRep = f&#34;/{relative}&#34; if relative else &#34;&#34;
        relativeGh = f&#34;/tree/master/{relative}&#34; if relative else &#34;&#34;
        self.baseGh = f&#34;{URL_GH}/{org}/{repo}{relativeGh}{versionRep}&#34;
        self.dataDir = f&#34;{relative}{versionRep}&#34;

        self.baseLocal = os.path.expanduser(self.dest)
        self.dataRelLocal = f&#34;{org}/{repo}{relativeRep}&#34;
        self.dirPathSaveLocal = f&#34;{self.baseLocal}/{org}/{repo}&#34;
        self.dirPathLocal = f&#34;{self.baseLocal}/{self.dataRelLocal}{versionRep}&#34;
        self.dataPathLocal = f&#34;{self.dataRelLocal}{versionRep}&#34;
        self.filePathLocal = f&#34;{self.dirPathLocal}/{EXPRESS_SYNC}&#34;

        self.baseClone = os.path.expanduser(self.source)
        self.dataRelClone = f&#34;{org}/{repo}{relativeRep}&#34;
        self.dirPathClone = f&#34;{self.baseClone}/{self.dataRelClone}{versionRep}&#34;
        self.dataPathClone = f&#34;{self.dataRelClone}{versionRep}&#34;

        self.dataPath = self.dataRelClone if clone else self.dataRelLocal

        self.keep = keep
        self.withPaths = withPaths
        self.ghConn = None

        self.commitOff = None
        self.releaseOff = None
        self.commitOn = None
        self.releaseOn = None
        self.releaseCommitOn = None

        self.silent = silent

        self.repoOnline = None
        self.localBase = False
        self.localDir = None

        if clone:
            self.commitOff = None
            self.releaseOff = None
        else:
            self.fixInfo()
            self.readInfo()

        if not offline:
            self.connect()
            self.fetchInfo()

    def log(self, msg, newline=True):
        silent = self.silent
        if not silent:
            console(msg, newline=newline)

    def warning(self, msg, newline=True):
        silent = self.silent
        if not silent == &#34;deep&#34;:
            console(msg, newline=newline)

    def error(self, msg, newline=True):
        console(msg, error=True, newline=newline)

    def possibleError(self, msg, showErrors, again=False, indent=&#34;\t&#34;, newline=False):
        error = self.error
        warning = self.warning

        if showErrors:
            error(msg, newline=newline)
        else:
            warning(msg, newline=newline)
            if again:
                warning(f&#34;{indent}Will try something else&#34;)

    def makeSureLocal(self, attempt=False):
        _browse = self._browse
        label = self.label
        offline = self.isOffline()
        clone = self.isClone()

        error = self.error
        warning = self.warning

        cOff = self.commitOff
        rOff = self.releaseOff
        cChk = self.commitChk
        rChk = self.releaseChk
        cOn = self.commitOn
        rOn = self.releaseOn
        rcOn = self.releaseCommitOn

        askExact = rChk or cChk
        askExactRelease = rChk
        askExactCommit = cChk
        askLatest = not askExact and (rChk == &#34;&#34; or cChk == &#34;&#34;)
        askLatestAny = rChk == &#34;&#34; and cChk == &#34;&#34;
        askLatestRelease = rChk == &#34;&#34; and cChk is None
        askLatestCommit = cChk == &#34;&#34; and rChk is None

        isExactReleaseOff = rChk and rChk == rOff
        isExactCommitOff = cChk and cChk == cOff
        isExactReleaseOn = rChk and rChk == rOn
        isExactCommitOn = cChk and cChk == cOn
        isLatestRelease = rOff and rOff == rOn or cOff and cOff == rcOn
        isLatestCommit = cOff and cOff == cOn

        isLocal = (
            askExactRelease
            and isExactReleaseOff
            or askExactCommit
            and isExactCommitOff
            or askLatestAny
            and (isLatestRelease or isLatestCommit)
            or askLatestRelease
            and isLatestRelease
            or askLatestCommit
            and isLatestCommit
        )
        mayLocal = (
            askLatestAny
            and (rOff or cOff)
            or askLatestRelease
            and rOff
            or askLatestCommit
            and cOff
        )
        canOnline = self.repoOnline
        isOnline = canOnline and (
            askExactRelease
            and isExactReleaseOn
            or askExactCommit
            and isExactCommitOn
            or askLatestAny
            or askLatestRelease
            or askLatestCommit
        )

        if offline:
            if clone:
                dirPath = self.dirPathClone
                self.localBase = self.baseClone if os.path.exists(dirPath) else False
            else:
                self.localBase = (
                    self.baseLocal
                    if (
                        cChk
                        and cChk == cOff
                        or cChk is None
                        and cOff
                        or rChk
                        and rChk == rOff
                        or rChk is None
                        and rOff
                    )
                    else False
                )
            if not self.localBase:
                method = self.warning if attempt else self.error
                method(f&#34;The requested {label} is not available offline&#34;)
                base = self.baseClone if clone else self.baseLocal
                method(f&#34;\t{base}/{self.dataPath} not found&#34;)
        else:
            if isLocal:
                self.localBase = self.baseLocal
            else:
                if not canOnline:
                    if askLatest:
                        if mayLocal:
                            warning(f&#34;The offline {label} may not be the latest&#34;)
                            self.localBase = self.baseLocal
                        else:
                            error(f&#34;The requested {label} is not available offline&#34;)
                    else:
                        warning(f&#34;The requested {label} is not available offline&#34;)
                        error(&#34;No online connection&#34;)
                elif not isOnline:
                    error(f&#34;The requested {label} is not available online&#34;)
                else:
                    self.localBase = self.baseLocal if self.download() else False

        if self.localBase:
            self.localDir = self.dataPath
            state = (
                &#34;requested&#34;
                if askExact
                else &#34;latest release&#34;
                if rChk == &#34;&#34; and canOnline and self.releaseOff
                else &#34;latest? release&#34;
                if rChk == &#34;&#34; and not canOnline and self.releaseOff
                else &#34;latest commit&#34;
                if cChk == &#34;&#34; and canOnline and self.commitOff
                else &#34;latest? commit&#34;
                if cChk == &#34;&#34; and not canOnline and self.commitOff
                else &#34;local release&#34;
                if self.local == &#34;local&#34; and self.releaseOff
                else &#34;local commit&#34;
                if self.local == &#34;local&#34; and self.commitOff
                else &#34;local github&#34;
                if self.local == &#34;clone&#34;
                else &#34;for whatever reason&#34;
            )
            offString = self.toString(
                self.commitOff,
                self.releaseOff,
                self.local,
                dest=self.dest,
                source=self.source,
            )
            labelEsc = htmlEsc(label)
            stateEsc = htmlEsc(state)
            offEsc = htmlEsc(offString)
            locEsc = htmlEsc(f&#34;{self.localBase}/{self.localDir}{self.versionRep}&#34;)
            if _browse:
                self.log(
                    f&#34;Using {label} in {self.localBase}/{self.localDir}{self.versionRep}:&#34;
                )
                self.log(f&#34;\t{offString} ({state})&#34;)
            else:
                dh(
                    f&#39;&lt;b title=&#34;{stateEsc}&#34;&gt;{labelEsc}:&lt;/b&gt;&#39;
                    f&#39; &lt;span title=&#34;{offEsc}&#34;&gt;{locEsc}&lt;/span&gt;&#39;
                )

    def download(self):
        cChk = self.commitChk
        rChk = self.releaseChk

        fetched = False
        if rChk is not None:
            fetched = self.downloadRelease(rChk, showErrors=cChk is None)
        if not fetched and cChk is not None:
            fetched = self.downloadCommit(cChk, showErrors=True)

        if fetched:
            self.writeInfo()
        return fetched

    def downloadRelease(self, release, showErrors=True):
        cChk = self.commitChk
        r = self.getReleaseObj(release, showErrors=showErrors)
        if not r:
            return False
        (commit, release) = self.getReleaseFromObj(r)

        assets = None
        try:
            assets = r.get_assets()
        except Exception:
            pass
        assetUrl = None
        versionRep3 = f&#34;-{self.version}&#34; if self.version else &#34;&#34;
        relativeFlat = self.relative.replace(&#34;/&#34;, &#34;-&#34;)
        dataFile = f&#34;{relativeFlat}{versionRep3}.zip&#34;
        if assets and assets.totalCount &gt; 0:
            for asset in assets:
                if asset.name == dataFile:
                    assetUrl = asset.browser_download_url
                    break
        fetched = False
        if assetUrl:
            fetched = self.downloadZip(assetUrl, showErrors=False)
        if not fetched:
            thisShowErrors = not cChk == &#34;&#34;
            fetched = self.downloadCommit(commit, showErrors=thisShowErrors)
        if fetched:
            self.commitOff = commit
            self.releaseOff = release
        return fetched

    def downloadCommit(self, commit, showErrors=True):
        c = self.getCommitObj(commit)
        if not c:
            return False
        commit = self.getCommitFromObj(c)
        fetched = self.downloadDir(commit, exclude=r&#34;\.tfx&#34;, showErrors=showErrors)
        if fetched:
            self.commitOff = commit
            self.releaseOff = None
        return fetched

    def downloadZip(self, dataUrl, showErrors=True):
        label = self.label
        self.log(f&#34;\tdownloading {dataUrl} ... &#34;)
        try:
            r = requests.get(dataUrl, allow_redirects=True)
            self.log(&#34;\tunzipping ... &#34;)
            zf = io.BytesIO(r.content)
        except Exception as e:
            msg = f&#34;\t{str(e)}\n\tcould not download {dataUrl}&#34;
            self.possibleError(msg, showErrors, again=True)
            return False

        self.log(f&#34;\tsaving {label}&#34;)

        cwd = os.getcwd()
        destZip = self.dirPathLocal
        try:
            z = ZipFile(zf)
            if not self.keep:
                if os.path.exists(destZip):
                    rmtree(destZip)
            os.makedirs(destZip, exist_ok=True)
            os.chdir(destZip)
            if self.withPaths:
                z.extractall()
                if os.path.exists(&#34;__MACOSX&#34;):
                    rmtree(&#34;__MACOSX&#34;)
            else:
                for zInfo in z.infolist():
                    if zInfo.filename[-1] == &#34;/&#34;:
                        continue
                    if zInfo.filename.startswith(&#34;__MACOS&#34;):
                        continue
                    zInfo.filename = os.path.basename(zInfo.filename)
                    z.extract(zInfo)
        except Exception:
            msg = f&#34;\tcould not save {label} to {destZip}&#34;
            self.possibleError(msg, showErrors, again=True)
            os.chdir(cwd)
            return False
        os.chdir(cwd)
        return True

    def downloadDir(self, commit, exclude=None, showErrors=False):
        g = self.repoOnline
        if not g:
            return None

        destDir = f&#34;{self.dirPathLocal}&#34;
        destSave = f&#34;{self.dirPathSaveLocal}&#34;
        if not self.keep:
            if os.path.exists(destDir):
                rmtree(destDir)
        os.makedirs(destDir, exist_ok=True)

        excludeRe = re.compile(exclude) if exclude else None

        good = True

        def _downloadDir(subPath, level=0):
            nonlocal good
            if not good:
                return
            lead = &#34;\t&#34; * level
            try:
                contents = g.get_contents(subPath, ref=commit)
            except UnknownObjectException:
                msg = f&#34;{lead}No directory {subPath} in {self.toString(commit, None, False)}&#34;
                self.possibleError(msg, showErrors, again=True, indent=lead)
                good = False
                return
            for content in contents:
                thisPath = content.path
                self.log(f&#34;\t{lead}{thisPath}...&#34;, newline=False)
                if exclude and excludeRe.search(thisPath):
                    self.log(&#34;excluded&#34;)
                    continue
                if content.type == &#34;dir&#34;:
                    self.log(&#34;directory&#34;)
                    os.makedirs(f&#34;{destSave}/{thisPath}&#34;, exist_ok=True)
                    _downloadDir(thisPath, level + 1)
                else:
                    try:
                        fileContent = g.get_git_blob(content.sha)
                        fileData = base64.b64decode(fileContent.content)
                        fileDest = f&#34;{destSave}/{thisPath}&#34;
                        with open(fileDest, &#34;wb&#34;) as fd:
                            fd.write(fileData)
                        self.log(&#34;downloaded&#34;)
                    except (GithubException, IOError):
                        msg = &#34;error&#34;
                        self.possibleError(msg, showErrors, again=True, indent=lead)
                        good = False

        _downloadDir(self.dataDir, 0)

        if good:
            self.log(&#34;\tOK&#34;)
        else:
            msg = &#34;\tFailed&#34;
            self.possibleError(msg, showErrors)

        return good

    def getRelease(self, release, showErrors=True):
        r = self.getReleaseObj(release, showErrors=showErrors)
        if not r:
            return None
        return self.getReleaseFromObj(r)

    def getCommit(self, commit):
        c = self.getCommitObj(commit)
        if not c:
            return None
        return self.getCommitFromObj(c)

    def getReleaseObj(self, release, showErrors=True):
        g = self.repoOnline
        if not g:
            return None

        r = None
        msg = f&#39; tagged &#34;{release}&#34;&#39; if release else &#34;s&#34;

        try:
            r = g.get_release(release) if release else g.get_latest_release()
        except UnknownObjectException:
            self.possibleError(f&#34;\tno release{msg}&#34;, showErrors, newline=True)
        except Exception:
            self.possibleError(f&#34;\tcannot find release{msg}&#34;, showErrors, newline=True)
        return r

    def getCommitObj(self, commit):
        error = self.error

        g = self.repoOnline
        if not g:
            return None

        c = None
        msg = f&#39; with hash &#34;{commit}&#34;&#39; if commit else &#34;s&#34;

        try:
            cs = g.get_commits(sha=commit) if commit else g.get_commits()
            if cs.totalCount:
                c = cs[0]
            else:
                error(f&#34;\tno commit{msg}&#34;)
        except Exception:
            error(f&#34;\tcannot find commit{msg}&#34;)
        return c

    def getReleaseFromObj(self, r):
        g = self.repoOnline
        if not g:
            return None
        release = r.tag_name
        ref = g.get_git_ref(f&#34;tags/{release}&#34;)
        commit = ref.object.sha
        return (commit, release)

    def getCommitFromObj(self, c):
        g = self.repoOnline
        if not g:
            return None
        return c.sha

    def fetchInfo(self):
        g = self.repoOnline
        if not g:
            return
        self.commitOn = None
        self.releaseOn = None
        self.releaseCommitOn = None
        if self.releaseChk is not None:
            result = self.getRelease(self.releaseChk, showErrors=self.commitChk is None)
            if result:
                (self.releaseCommitOn, self.releaseOn) = result
        if self.commitChk is not None:
            result = self.getCommit(self.commitChk)
            if result:
                self.commitOn = result

    def fixInfo(self):
        sDir = self.dirPathLocal
        if not os.path.exists(sDir):
            return
        for sFile in EXPRESS_SYNC_LEGACY:
            sPath = f&#34;{sDir}/{sFile}&#34;
            if os.path.exists(sPath):
                goodPath = f&#34;{sDir}/{EXPRESS_SYNC}&#34;
                if os.path.exists(goodPath):
                    os.remove(sPath)
                else:
                    os.rename(sPath, goodPath)

    def readInfo(self):
        if os.path.exists(self.filePathLocal):
            with open(self.filePathLocal, encoding=&#34;utf8&#34;) as f:
                for line in f:
                    string = line.strip()
                    (commit, release, local) = self.fromString(string)
                    if commit:
                        self.commitOff = commit
                    if release:
                        self.releaseOff = release

    def writeInfo(self):
        if not os.path.exists(self.dirPathLocal):
            os.makedirs(self.dirPathLocal, exist_ok=True)
        with open(self.filePathLocal, &#34;w&#34;, encoding=&#34;utf8&#34;) as f:
            if self.releaseOff:
                f.write(f&#34;{self.releaseOff}\n&#34;)
            if self.commitOff:
                f.write(f&#34;{self.commitOff}\n&#34;)

    def connect(self):
        warning = self.warning

        if not self.ghConn:
            ghPerson = os.environ.get(&#34;GHPERS&#34;, None)
            if ghPerson:
                self.ghConn = Github(ghPerson)
            else:
                ghClient = os.environ.get(&#34;GHCLIENT&#34;, None)
                ghSecret = os.environ.get(&#34;GHSECRET&#34;, None)
                if ghClient and ghSecret:
                    self.ghConn = Github(client_id=ghClient, client_secret=ghSecret)
                else:
                    self.ghConn = Github()
        try:
            rate = self.ghConn.get_rate_limit().core
            self.log(
                f&#34;rate limit is {rate.limit} requests per hour,&#34;
                f&#34; with {rate.remaining} left for this hour&#34;
            )
            if rate.limit &lt; 100:
                warning(f&#34;To increase the rate,&#34; f&#34;see {URL_TFDOC}/advanced/repo.html/&#34;)

            self.log(
                f&#34;\tconnecting to online GitHub repo {self.org}/{self.repo} ... &#34;,
                newline=False,
            )
            self.repoOnline = self.ghConn.get_repo(f&#34;{self.org}/{self.repo}&#34;)
            self.log(&#34;connected&#34;)
        except GithubException as why:
            warning(&#34;failed&#34;)
            warning(f&#34;GitHub says: {why}&#34;)
        except IOError:
            warning(&#34;no internet&#34;)


def checkoutRepo(
    _browse=False,
    org=&#34;annotation&#34;,
    repo=&#34;tutorials&#34;,
    folder=&#34;text-fabric/examples/banks/tf&#34;,
    version=&#34;&#34;,
    checkout=&#34;&#34;,
    source=GH_BASE,
    dest=EXPRESS_BASE,
    withPaths=True,
    keep=True,
    silent=False,
    label=&#34;data&#34;,
):
    def resolve(chkout, attempt=False):
        rData = Checkout(
            org,
            repo,
            folder,
            chkout,
            source,
            dest,
            keep,
            withPaths,
            silent,
            _browse,
            version=version,
            label=label,
        )
        rData.makeSureLocal(attempt=attempt)
        return (
            (
                rData.commitOff,
                rData.releaseOff,
                rData.local,
                rData.localBase,
                rData.localDir,
            )
            if rData.localBase
            else (None, None, False, False, None)
        )

    if checkout == &#34;&#34;:
        rData = resolve(&#34;local&#34;, attempt=True)
        if rData[3]:
            return rData

    return resolve(checkout)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.advanced.repo.checkoutRepo"><code class="name flex">
<span>def <span class="ident">checkoutRepo</span></span>(<span>org='annotation', repo='tutorials', folder='text-fabric/examples/banks/tf', version='', checkout='', source='~/github', dest='~/text-fabric-data', withPaths=True, keep=True, silent=False, label='data')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L1262-L1309" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkoutRepo(
    _browse=False,
    org=&#34;annotation&#34;,
    repo=&#34;tutorials&#34;,
    folder=&#34;text-fabric/examples/banks/tf&#34;,
    version=&#34;&#34;,
    checkout=&#34;&#34;,
    source=GH_BASE,
    dest=EXPRESS_BASE,
    withPaths=True,
    keep=True,
    silent=False,
    label=&#34;data&#34;,
):
    def resolve(chkout, attempt=False):
        rData = Checkout(
            org,
            repo,
            folder,
            chkout,
            source,
            dest,
            keep,
            withPaths,
            silent,
            _browse,
            version=version,
            label=label,
        )
        rData.makeSureLocal(attempt=attempt)
        return (
            (
                rData.commitOff,
                rData.releaseOff,
                rData.local,
                rData.localBase,
                rData.localDir,
            )
            if rData.localBase
            else (None, None, False, False, None)
        )

    if checkout == &#34;&#34;:
        rData = resolve(&#34;local&#34;, attempt=True)
        if rData[3]:
            return rData

    return resolve(checkout)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.releaseData"><code class="name flex">
<span>def <span class="ident">releaseData</span></span>(<span>org, repo, folder, version, increase, source='~/github', dest='~/Downloads')</span>
</code></dt>
<dd>
<div class="desc"><p>increase:
1 = bump major version;
2 = bump intermediate version;
3 = bump minor version</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L637-L645" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def releaseData(org, repo, folder, version, increase, source=GH_BASE, dest=DOWNLOADS):
    &#34;&#34;&#34;
    increase:
    1 = bump major version;
    2 = bump intermediate version;
    3 = bump minor version
    &#34;&#34;&#34;
    R = Repo(org, repo, folder, version, increase, source=source, dest=dest)
    return R.newRelease()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.advanced.repo.Checkout"><code class="flex name class">
<span>class <span class="ident">Checkout</span></span>
<span>(</span><span>org, repo, relative, checkout, source, dest, keep, withPaths, silent, _browse, version=None, label='data')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L648-L1259" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Checkout(object):
    @staticmethod
    def fromString(string):
        commit = None
        release = None
        local = None
        if not string:
            commit = &#34;&#34;
            release = &#34;&#34;
        elif string == &#34;latest&#34;:
            commit = None
            release = &#34;&#34;
        elif string == &#34;hot&#34;:
            commit = &#34;&#34;
            release = None
        elif string in {&#34;local&#34;, &#34;clone&#34;}:
            commit = None
            release = None
            local = string
        elif &#34;.&#34; in string or len(string) &lt; 12:
            commit = None
            release = string
        else:
            commit = string
            release = None
        return (commit, release, local)

    @staticmethod
    def toString(commit, release, local, source=GH_BASE, dest=EXPRESS_BASE):
        extra = &#34;&#34;
        if local:
            baseRep = source if local == &#34;clone&#34; else dest
            extra = f&#34; offline under {baseRep}&#34;
        if local == &#34;clone&#34;:
            result = &#34;repo clone&#34;
        elif commit and release:
            result = f&#34;r{release}=#{commit}&#34;
        elif commit:
            result = f&#34;#{commit}&#34;
        elif release:
            result = f&#34;r{release}&#34;
        elif commit is None and release is None:
            result = &#34;unknown release or commit&#34;
        elif commit is None:
            result = &#34;latest release&#34;
        elif release is None:
            result = &#34;latest commit&#34;
        else:
            result = &#34;latest release or commit&#34;
        return f&#34;{result}{extra}&#34;

    def isClone(self):
        return self.local == &#34;clone&#34;

    def isOffline(self):
        return self.local in {&#34;clone&#34;, &#34;local&#34;}

    def __init__(
        self,
        org,
        repo,
        relative,
        checkout,
        source,
        dest,
        keep,
        withPaths,
        silent,
        _browse,
        version=None,
        label=&#34;data&#34;,
    ):
        self._browse = _browse
        self.label = label
        self.org = org
        self.repo = repo
        self.source = source
        self.dest = dest
        (self.commitChk, self.releaseChk, self.local) = self.fromString(checkout)
        clone = self.isClone()
        offline = self.isOffline()

        self.relative = relative
        self.version = version
        versionRep = f&#34;/{version}&#34; if version else &#34;&#34;
        self.versionRep = versionRep
        relativeRep = f&#34;/{relative}&#34; if relative else &#34;&#34;
        relativeGh = f&#34;/tree/master/{relative}&#34; if relative else &#34;&#34;
        self.baseGh = f&#34;{URL_GH}/{org}/{repo}{relativeGh}{versionRep}&#34;
        self.dataDir = f&#34;{relative}{versionRep}&#34;

        self.baseLocal = os.path.expanduser(self.dest)
        self.dataRelLocal = f&#34;{org}/{repo}{relativeRep}&#34;
        self.dirPathSaveLocal = f&#34;{self.baseLocal}/{org}/{repo}&#34;
        self.dirPathLocal = f&#34;{self.baseLocal}/{self.dataRelLocal}{versionRep}&#34;
        self.dataPathLocal = f&#34;{self.dataRelLocal}{versionRep}&#34;
        self.filePathLocal = f&#34;{self.dirPathLocal}/{EXPRESS_SYNC}&#34;

        self.baseClone = os.path.expanduser(self.source)
        self.dataRelClone = f&#34;{org}/{repo}{relativeRep}&#34;
        self.dirPathClone = f&#34;{self.baseClone}/{self.dataRelClone}{versionRep}&#34;
        self.dataPathClone = f&#34;{self.dataRelClone}{versionRep}&#34;

        self.dataPath = self.dataRelClone if clone else self.dataRelLocal

        self.keep = keep
        self.withPaths = withPaths
        self.ghConn = None

        self.commitOff = None
        self.releaseOff = None
        self.commitOn = None
        self.releaseOn = None
        self.releaseCommitOn = None

        self.silent = silent

        self.repoOnline = None
        self.localBase = False
        self.localDir = None

        if clone:
            self.commitOff = None
            self.releaseOff = None
        else:
            self.fixInfo()
            self.readInfo()

        if not offline:
            self.connect()
            self.fetchInfo()

    def log(self, msg, newline=True):
        silent = self.silent
        if not silent:
            console(msg, newline=newline)

    def warning(self, msg, newline=True):
        silent = self.silent
        if not silent == &#34;deep&#34;:
            console(msg, newline=newline)

    def error(self, msg, newline=True):
        console(msg, error=True, newline=newline)

    def possibleError(self, msg, showErrors, again=False, indent=&#34;\t&#34;, newline=False):
        error = self.error
        warning = self.warning

        if showErrors:
            error(msg, newline=newline)
        else:
            warning(msg, newline=newline)
            if again:
                warning(f&#34;{indent}Will try something else&#34;)

    def makeSureLocal(self, attempt=False):
        _browse = self._browse
        label = self.label
        offline = self.isOffline()
        clone = self.isClone()

        error = self.error
        warning = self.warning

        cOff = self.commitOff
        rOff = self.releaseOff
        cChk = self.commitChk
        rChk = self.releaseChk
        cOn = self.commitOn
        rOn = self.releaseOn
        rcOn = self.releaseCommitOn

        askExact = rChk or cChk
        askExactRelease = rChk
        askExactCommit = cChk
        askLatest = not askExact and (rChk == &#34;&#34; or cChk == &#34;&#34;)
        askLatestAny = rChk == &#34;&#34; and cChk == &#34;&#34;
        askLatestRelease = rChk == &#34;&#34; and cChk is None
        askLatestCommit = cChk == &#34;&#34; and rChk is None

        isExactReleaseOff = rChk and rChk == rOff
        isExactCommitOff = cChk and cChk == cOff
        isExactReleaseOn = rChk and rChk == rOn
        isExactCommitOn = cChk and cChk == cOn
        isLatestRelease = rOff and rOff == rOn or cOff and cOff == rcOn
        isLatestCommit = cOff and cOff == cOn

        isLocal = (
            askExactRelease
            and isExactReleaseOff
            or askExactCommit
            and isExactCommitOff
            or askLatestAny
            and (isLatestRelease or isLatestCommit)
            or askLatestRelease
            and isLatestRelease
            or askLatestCommit
            and isLatestCommit
        )
        mayLocal = (
            askLatestAny
            and (rOff or cOff)
            or askLatestRelease
            and rOff
            or askLatestCommit
            and cOff
        )
        canOnline = self.repoOnline
        isOnline = canOnline and (
            askExactRelease
            and isExactReleaseOn
            or askExactCommit
            and isExactCommitOn
            or askLatestAny
            or askLatestRelease
            or askLatestCommit
        )

        if offline:
            if clone:
                dirPath = self.dirPathClone
                self.localBase = self.baseClone if os.path.exists(dirPath) else False
            else:
                self.localBase = (
                    self.baseLocal
                    if (
                        cChk
                        and cChk == cOff
                        or cChk is None
                        and cOff
                        or rChk
                        and rChk == rOff
                        or rChk is None
                        and rOff
                    )
                    else False
                )
            if not self.localBase:
                method = self.warning if attempt else self.error
                method(f&#34;The requested {label} is not available offline&#34;)
                base = self.baseClone if clone else self.baseLocal
                method(f&#34;\t{base}/{self.dataPath} not found&#34;)
        else:
            if isLocal:
                self.localBase = self.baseLocal
            else:
                if not canOnline:
                    if askLatest:
                        if mayLocal:
                            warning(f&#34;The offline {label} may not be the latest&#34;)
                            self.localBase = self.baseLocal
                        else:
                            error(f&#34;The requested {label} is not available offline&#34;)
                    else:
                        warning(f&#34;The requested {label} is not available offline&#34;)
                        error(&#34;No online connection&#34;)
                elif not isOnline:
                    error(f&#34;The requested {label} is not available online&#34;)
                else:
                    self.localBase = self.baseLocal if self.download() else False

        if self.localBase:
            self.localDir = self.dataPath
            state = (
                &#34;requested&#34;
                if askExact
                else &#34;latest release&#34;
                if rChk == &#34;&#34; and canOnline and self.releaseOff
                else &#34;latest? release&#34;
                if rChk == &#34;&#34; and not canOnline and self.releaseOff
                else &#34;latest commit&#34;
                if cChk == &#34;&#34; and canOnline and self.commitOff
                else &#34;latest? commit&#34;
                if cChk == &#34;&#34; and not canOnline and self.commitOff
                else &#34;local release&#34;
                if self.local == &#34;local&#34; and self.releaseOff
                else &#34;local commit&#34;
                if self.local == &#34;local&#34; and self.commitOff
                else &#34;local github&#34;
                if self.local == &#34;clone&#34;
                else &#34;for whatever reason&#34;
            )
            offString = self.toString(
                self.commitOff,
                self.releaseOff,
                self.local,
                dest=self.dest,
                source=self.source,
            )
            labelEsc = htmlEsc(label)
            stateEsc = htmlEsc(state)
            offEsc = htmlEsc(offString)
            locEsc = htmlEsc(f&#34;{self.localBase}/{self.localDir}{self.versionRep}&#34;)
            if _browse:
                self.log(
                    f&#34;Using {label} in {self.localBase}/{self.localDir}{self.versionRep}:&#34;
                )
                self.log(f&#34;\t{offString} ({state})&#34;)
            else:
                dh(
                    f&#39;&lt;b title=&#34;{stateEsc}&#34;&gt;{labelEsc}:&lt;/b&gt;&#39;
                    f&#39; &lt;span title=&#34;{offEsc}&#34;&gt;{locEsc}&lt;/span&gt;&#39;
                )

    def download(self):
        cChk = self.commitChk
        rChk = self.releaseChk

        fetched = False
        if rChk is not None:
            fetched = self.downloadRelease(rChk, showErrors=cChk is None)
        if not fetched and cChk is not None:
            fetched = self.downloadCommit(cChk, showErrors=True)

        if fetched:
            self.writeInfo()
        return fetched

    def downloadRelease(self, release, showErrors=True):
        cChk = self.commitChk
        r = self.getReleaseObj(release, showErrors=showErrors)
        if not r:
            return False
        (commit, release) = self.getReleaseFromObj(r)

        assets = None
        try:
            assets = r.get_assets()
        except Exception:
            pass
        assetUrl = None
        versionRep3 = f&#34;-{self.version}&#34; if self.version else &#34;&#34;
        relativeFlat = self.relative.replace(&#34;/&#34;, &#34;-&#34;)
        dataFile = f&#34;{relativeFlat}{versionRep3}.zip&#34;
        if assets and assets.totalCount &gt; 0:
            for asset in assets:
                if asset.name == dataFile:
                    assetUrl = asset.browser_download_url
                    break
        fetched = False
        if assetUrl:
            fetched = self.downloadZip(assetUrl, showErrors=False)
        if not fetched:
            thisShowErrors = not cChk == &#34;&#34;
            fetched = self.downloadCommit(commit, showErrors=thisShowErrors)
        if fetched:
            self.commitOff = commit
            self.releaseOff = release
        return fetched

    def downloadCommit(self, commit, showErrors=True):
        c = self.getCommitObj(commit)
        if not c:
            return False
        commit = self.getCommitFromObj(c)
        fetched = self.downloadDir(commit, exclude=r&#34;\.tfx&#34;, showErrors=showErrors)
        if fetched:
            self.commitOff = commit
            self.releaseOff = None
        return fetched

    def downloadZip(self, dataUrl, showErrors=True):
        label = self.label
        self.log(f&#34;\tdownloading {dataUrl} ... &#34;)
        try:
            r = requests.get(dataUrl, allow_redirects=True)
            self.log(&#34;\tunzipping ... &#34;)
            zf = io.BytesIO(r.content)
        except Exception as e:
            msg = f&#34;\t{str(e)}\n\tcould not download {dataUrl}&#34;
            self.possibleError(msg, showErrors, again=True)
            return False

        self.log(f&#34;\tsaving {label}&#34;)

        cwd = os.getcwd()
        destZip = self.dirPathLocal
        try:
            z = ZipFile(zf)
            if not self.keep:
                if os.path.exists(destZip):
                    rmtree(destZip)
            os.makedirs(destZip, exist_ok=True)
            os.chdir(destZip)
            if self.withPaths:
                z.extractall()
                if os.path.exists(&#34;__MACOSX&#34;):
                    rmtree(&#34;__MACOSX&#34;)
            else:
                for zInfo in z.infolist():
                    if zInfo.filename[-1] == &#34;/&#34;:
                        continue
                    if zInfo.filename.startswith(&#34;__MACOS&#34;):
                        continue
                    zInfo.filename = os.path.basename(zInfo.filename)
                    z.extract(zInfo)
        except Exception:
            msg = f&#34;\tcould not save {label} to {destZip}&#34;
            self.possibleError(msg, showErrors, again=True)
            os.chdir(cwd)
            return False
        os.chdir(cwd)
        return True

    def downloadDir(self, commit, exclude=None, showErrors=False):
        g = self.repoOnline
        if not g:
            return None

        destDir = f&#34;{self.dirPathLocal}&#34;
        destSave = f&#34;{self.dirPathSaveLocal}&#34;
        if not self.keep:
            if os.path.exists(destDir):
                rmtree(destDir)
        os.makedirs(destDir, exist_ok=True)

        excludeRe = re.compile(exclude) if exclude else None

        good = True

        def _downloadDir(subPath, level=0):
            nonlocal good
            if not good:
                return
            lead = &#34;\t&#34; * level
            try:
                contents = g.get_contents(subPath, ref=commit)
            except UnknownObjectException:
                msg = f&#34;{lead}No directory {subPath} in {self.toString(commit, None, False)}&#34;
                self.possibleError(msg, showErrors, again=True, indent=lead)
                good = False
                return
            for content in contents:
                thisPath = content.path
                self.log(f&#34;\t{lead}{thisPath}...&#34;, newline=False)
                if exclude and excludeRe.search(thisPath):
                    self.log(&#34;excluded&#34;)
                    continue
                if content.type == &#34;dir&#34;:
                    self.log(&#34;directory&#34;)
                    os.makedirs(f&#34;{destSave}/{thisPath}&#34;, exist_ok=True)
                    _downloadDir(thisPath, level + 1)
                else:
                    try:
                        fileContent = g.get_git_blob(content.sha)
                        fileData = base64.b64decode(fileContent.content)
                        fileDest = f&#34;{destSave}/{thisPath}&#34;
                        with open(fileDest, &#34;wb&#34;) as fd:
                            fd.write(fileData)
                        self.log(&#34;downloaded&#34;)
                    except (GithubException, IOError):
                        msg = &#34;error&#34;
                        self.possibleError(msg, showErrors, again=True, indent=lead)
                        good = False

        _downloadDir(self.dataDir, 0)

        if good:
            self.log(&#34;\tOK&#34;)
        else:
            msg = &#34;\tFailed&#34;
            self.possibleError(msg, showErrors)

        return good

    def getRelease(self, release, showErrors=True):
        r = self.getReleaseObj(release, showErrors=showErrors)
        if not r:
            return None
        return self.getReleaseFromObj(r)

    def getCommit(self, commit):
        c = self.getCommitObj(commit)
        if not c:
            return None
        return self.getCommitFromObj(c)

    def getReleaseObj(self, release, showErrors=True):
        g = self.repoOnline
        if not g:
            return None

        r = None
        msg = f&#39; tagged &#34;{release}&#34;&#39; if release else &#34;s&#34;

        try:
            r = g.get_release(release) if release else g.get_latest_release()
        except UnknownObjectException:
            self.possibleError(f&#34;\tno release{msg}&#34;, showErrors, newline=True)
        except Exception:
            self.possibleError(f&#34;\tcannot find release{msg}&#34;, showErrors, newline=True)
        return r

    def getCommitObj(self, commit):
        error = self.error

        g = self.repoOnline
        if not g:
            return None

        c = None
        msg = f&#39; with hash &#34;{commit}&#34;&#39; if commit else &#34;s&#34;

        try:
            cs = g.get_commits(sha=commit) if commit else g.get_commits()
            if cs.totalCount:
                c = cs[0]
            else:
                error(f&#34;\tno commit{msg}&#34;)
        except Exception:
            error(f&#34;\tcannot find commit{msg}&#34;)
        return c

    def getReleaseFromObj(self, r):
        g = self.repoOnline
        if not g:
            return None
        release = r.tag_name
        ref = g.get_git_ref(f&#34;tags/{release}&#34;)
        commit = ref.object.sha
        return (commit, release)

    def getCommitFromObj(self, c):
        g = self.repoOnline
        if not g:
            return None
        return c.sha

    def fetchInfo(self):
        g = self.repoOnline
        if not g:
            return
        self.commitOn = None
        self.releaseOn = None
        self.releaseCommitOn = None
        if self.releaseChk is not None:
            result = self.getRelease(self.releaseChk, showErrors=self.commitChk is None)
            if result:
                (self.releaseCommitOn, self.releaseOn) = result
        if self.commitChk is not None:
            result = self.getCommit(self.commitChk)
            if result:
                self.commitOn = result

    def fixInfo(self):
        sDir = self.dirPathLocal
        if not os.path.exists(sDir):
            return
        for sFile in EXPRESS_SYNC_LEGACY:
            sPath = f&#34;{sDir}/{sFile}&#34;
            if os.path.exists(sPath):
                goodPath = f&#34;{sDir}/{EXPRESS_SYNC}&#34;
                if os.path.exists(goodPath):
                    os.remove(sPath)
                else:
                    os.rename(sPath, goodPath)

    def readInfo(self):
        if os.path.exists(self.filePathLocal):
            with open(self.filePathLocal, encoding=&#34;utf8&#34;) as f:
                for line in f:
                    string = line.strip()
                    (commit, release, local) = self.fromString(string)
                    if commit:
                        self.commitOff = commit
                    if release:
                        self.releaseOff = release

    def writeInfo(self):
        if not os.path.exists(self.dirPathLocal):
            os.makedirs(self.dirPathLocal, exist_ok=True)
        with open(self.filePathLocal, &#34;w&#34;, encoding=&#34;utf8&#34;) as f:
            if self.releaseOff:
                f.write(f&#34;{self.releaseOff}\n&#34;)
            if self.commitOff:
                f.write(f&#34;{self.commitOff}\n&#34;)

    def connect(self):
        warning = self.warning

        if not self.ghConn:
            ghPerson = os.environ.get(&#34;GHPERS&#34;, None)
            if ghPerson:
                self.ghConn = Github(ghPerson)
            else:
                ghClient = os.environ.get(&#34;GHCLIENT&#34;, None)
                ghSecret = os.environ.get(&#34;GHSECRET&#34;, None)
                if ghClient and ghSecret:
                    self.ghConn = Github(client_id=ghClient, client_secret=ghSecret)
                else:
                    self.ghConn = Github()
        try:
            rate = self.ghConn.get_rate_limit().core
            self.log(
                f&#34;rate limit is {rate.limit} requests per hour,&#34;
                f&#34; with {rate.remaining} left for this hour&#34;
            )
            if rate.limit &lt; 100:
                warning(f&#34;To increase the rate,&#34; f&#34;see {URL_TFDOC}/advanced/repo.html/&#34;)

            self.log(
                f&#34;\tconnecting to online GitHub repo {self.org}/{self.repo} ... &#34;,
                newline=False,
            )
            self.repoOnline = self.ghConn.get_repo(f&#34;{self.org}/{self.repo}&#34;)
            self.log(&#34;connected&#34;)
        except GithubException as why:
            warning(&#34;failed&#34;)
            warning(f&#34;GitHub says: {why}&#34;)
        except IOError:
            warning(&#34;no internet&#34;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="tf.advanced.repo.Checkout.fromString"><code class="name flex">
<span>def <span class="ident">fromString</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L649-L673" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def fromString(string):
    commit = None
    release = None
    local = None
    if not string:
        commit = &#34;&#34;
        release = &#34;&#34;
    elif string == &#34;latest&#34;:
        commit = None
        release = &#34;&#34;
    elif string == &#34;hot&#34;:
        commit = &#34;&#34;
        release = None
    elif string in {&#34;local&#34;, &#34;clone&#34;}:
        commit = None
        release = None
        local = string
    elif &#34;.&#34; in string or len(string) &lt; 12:
        commit = None
        release = string
    else:
        commit = string
        release = None
    return (commit, release, local)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.toString"><code class="name flex">
<span>def <span class="ident">toString</span></span>(<span>commit, release, local, source='~/github', dest='~/text-fabric-data')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L675-L697" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def toString(commit, release, local, source=GH_BASE, dest=EXPRESS_BASE):
    extra = &#34;&#34;
    if local:
        baseRep = source if local == &#34;clone&#34; else dest
        extra = f&#34; offline under {baseRep}&#34;
    if local == &#34;clone&#34;:
        result = &#34;repo clone&#34;
    elif commit and release:
        result = f&#34;r{release}=#{commit}&#34;
    elif commit:
        result = f&#34;#{commit}&#34;
    elif release:
        result = f&#34;r{release}&#34;
    elif commit is None and release is None:
        result = &#34;unknown release or commit&#34;
    elif commit is None:
        result = &#34;latest release&#34;
    elif release is None:
        result = &#34;latest commit&#34;
    else:
        result = &#34;latest release or commit&#34;
    return f&#34;{result}{extra}&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tf.advanced.repo.Checkout.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L1226-L1259" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def connect(self):
    warning = self.warning

    if not self.ghConn:
        ghPerson = os.environ.get(&#34;GHPERS&#34;, None)
        if ghPerson:
            self.ghConn = Github(ghPerson)
        else:
            ghClient = os.environ.get(&#34;GHCLIENT&#34;, None)
            ghSecret = os.environ.get(&#34;GHSECRET&#34;, None)
            if ghClient and ghSecret:
                self.ghConn = Github(client_id=ghClient, client_secret=ghSecret)
            else:
                self.ghConn = Github()
    try:
        rate = self.ghConn.get_rate_limit().core
        self.log(
            f&#34;rate limit is {rate.limit} requests per hour,&#34;
            f&#34; with {rate.remaining} left for this hour&#34;
        )
        if rate.limit &lt; 100:
            warning(f&#34;To increase the rate,&#34; f&#34;see {URL_TFDOC}/advanced/repo.html/&#34;)

        self.log(
            f&#34;\tconnecting to online GitHub repo {self.org}/{self.repo} ... &#34;,
            newline=False,
        )
        self.repoOnline = self.ghConn.get_repo(f&#34;{self.org}/{self.repo}&#34;)
        self.log(&#34;connected&#34;)
    except GithubException as why:
        warning(&#34;failed&#34;)
        warning(f&#34;GitHub says: {why}&#34;)
    except IOError:
        warning(&#34;no internet&#34;)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L953-L965" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def download(self):
    cChk = self.commitChk
    rChk = self.releaseChk

    fetched = False
    if rChk is not None:
        fetched = self.downloadRelease(rChk, showErrors=cChk is None)
    if not fetched and cChk is not None:
        fetched = self.downloadCommit(cChk, showErrors=True)

    if fetched:
        self.writeInfo()
    return fetched</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.downloadCommit"><code class="name flex">
<span>def <span class="ident">downloadCommit</span></span>(<span>self, commit, showErrors=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L999-L1008" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def downloadCommit(self, commit, showErrors=True):
    c = self.getCommitObj(commit)
    if not c:
        return False
    commit = self.getCommitFromObj(c)
    fetched = self.downloadDir(commit, exclude=r&#34;\.tfx&#34;, showErrors=showErrors)
    if fetched:
        self.commitOff = commit
        self.releaseOff = None
    return fetched</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.downloadDir"><code class="name flex">
<span>def <span class="ident">downloadDir</span></span>(<span>self, commit, exclude=None, showErrors=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L1053-L1112" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def downloadDir(self, commit, exclude=None, showErrors=False):
    g = self.repoOnline
    if not g:
        return None

    destDir = f&#34;{self.dirPathLocal}&#34;
    destSave = f&#34;{self.dirPathSaveLocal}&#34;
    if not self.keep:
        if os.path.exists(destDir):
            rmtree(destDir)
    os.makedirs(destDir, exist_ok=True)

    excludeRe = re.compile(exclude) if exclude else None

    good = True

    def _downloadDir(subPath, level=0):
        nonlocal good
        if not good:
            return
        lead = &#34;\t&#34; * level
        try:
            contents = g.get_contents(subPath, ref=commit)
        except UnknownObjectException:
            msg = f&#34;{lead}No directory {subPath} in {self.toString(commit, None, False)}&#34;
            self.possibleError(msg, showErrors, again=True, indent=lead)
            good = False
            return
        for content in contents:
            thisPath = content.path
            self.log(f&#34;\t{lead}{thisPath}...&#34;, newline=False)
            if exclude and excludeRe.search(thisPath):
                self.log(&#34;excluded&#34;)
                continue
            if content.type == &#34;dir&#34;:
                self.log(&#34;directory&#34;)
                os.makedirs(f&#34;{destSave}/{thisPath}&#34;, exist_ok=True)
                _downloadDir(thisPath, level + 1)
            else:
                try:
                    fileContent = g.get_git_blob(content.sha)
                    fileData = base64.b64decode(fileContent.content)
                    fileDest = f&#34;{destSave}/{thisPath}&#34;
                    with open(fileDest, &#34;wb&#34;) as fd:
                        fd.write(fileData)
                    self.log(&#34;downloaded&#34;)
                except (GithubException, IOError):
                    msg = &#34;error&#34;
                    self.possibleError(msg, showErrors, again=True, indent=lead)
                    good = False

    _downloadDir(self.dataDir, 0)

    if good:
        self.log(&#34;\tOK&#34;)
    else:
        msg = &#34;\tFailed&#34;
        self.possibleError(msg, showErrors)

    return good</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.downloadRelease"><code class="name flex">
<span>def <span class="ident">downloadRelease</span></span>(<span>self, release, showErrors=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L967-L997" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def downloadRelease(self, release, showErrors=True):
    cChk = self.commitChk
    r = self.getReleaseObj(release, showErrors=showErrors)
    if not r:
        return False
    (commit, release) = self.getReleaseFromObj(r)

    assets = None
    try:
        assets = r.get_assets()
    except Exception:
        pass
    assetUrl = None
    versionRep3 = f&#34;-{self.version}&#34; if self.version else &#34;&#34;
    relativeFlat = self.relative.replace(&#34;/&#34;, &#34;-&#34;)
    dataFile = f&#34;{relativeFlat}{versionRep3}.zip&#34;
    if assets and assets.totalCount &gt; 0:
        for asset in assets:
            if asset.name == dataFile:
                assetUrl = asset.browser_download_url
                break
    fetched = False
    if assetUrl:
        fetched = self.downloadZip(assetUrl, showErrors=False)
    if not fetched:
        thisShowErrors = not cChk == &#34;&#34;
        fetched = self.downloadCommit(commit, showErrors=thisShowErrors)
    if fetched:
        self.commitOff = commit
        self.releaseOff = release
    return fetched</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.downloadZip"><code class="name flex">
<span>def <span class="ident">downloadZip</span></span>(<span>self, dataUrl, showErrors=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L1010-L1051" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def downloadZip(self, dataUrl, showErrors=True):
    label = self.label
    self.log(f&#34;\tdownloading {dataUrl} ... &#34;)
    try:
        r = requests.get(dataUrl, allow_redirects=True)
        self.log(&#34;\tunzipping ... &#34;)
        zf = io.BytesIO(r.content)
    except Exception as e:
        msg = f&#34;\t{str(e)}\n\tcould not download {dataUrl}&#34;
        self.possibleError(msg, showErrors, again=True)
        return False

    self.log(f&#34;\tsaving {label}&#34;)

    cwd = os.getcwd()
    destZip = self.dirPathLocal
    try:
        z = ZipFile(zf)
        if not self.keep:
            if os.path.exists(destZip):
                rmtree(destZip)
        os.makedirs(destZip, exist_ok=True)
        os.chdir(destZip)
        if self.withPaths:
            z.extractall()
            if os.path.exists(&#34;__MACOSX&#34;):
                rmtree(&#34;__MACOSX&#34;)
        else:
            for zInfo in z.infolist():
                if zInfo.filename[-1] == &#34;/&#34;:
                    continue
                if zInfo.filename.startswith(&#34;__MACOS&#34;):
                    continue
                zInfo.filename = os.path.basename(zInfo.filename)
                z.extract(zInfo)
    except Exception:
        msg = f&#34;\tcould not save {label} to {destZip}&#34;
        self.possibleError(msg, showErrors, again=True)
        os.chdir(cwd)
        return False
    os.chdir(cwd)
    return True</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>self, msg, newline=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L790-L791" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def error(self, msg, newline=True):
    console(msg, error=True, newline=newline)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.fetchInfo"><code class="name flex">
<span>def <span class="ident">fetchInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L1177-L1191" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fetchInfo(self):
    g = self.repoOnline
    if not g:
        return
    self.commitOn = None
    self.releaseOn = None
    self.releaseCommitOn = None
    if self.releaseChk is not None:
        result = self.getRelease(self.releaseChk, showErrors=self.commitChk is None)
        if result:
            (self.releaseCommitOn, self.releaseOn) = result
    if self.commitChk is not None:
        result = self.getCommit(self.commitChk)
        if result:
            self.commitOn = result</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.fixInfo"><code class="name flex">
<span>def <span class="ident">fixInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L1193-L1204" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fixInfo(self):
    sDir = self.dirPathLocal
    if not os.path.exists(sDir):
        return
    for sFile in EXPRESS_SYNC_LEGACY:
        sPath = f&#34;{sDir}/{sFile}&#34;
        if os.path.exists(sPath):
            goodPath = f&#34;{sDir}/{EXPRESS_SYNC}&#34;
            if os.path.exists(goodPath):
                os.remove(sPath)
            else:
                os.rename(sPath, goodPath)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.getCommit"><code class="name flex">
<span>def <span class="ident">getCommit</span></span>(<span>self, commit)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L1120-L1124" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getCommit(self, commit):
    c = self.getCommitObj(commit)
    if not c:
        return None
    return self.getCommitFromObj(c)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.getCommitFromObj"><code class="name flex">
<span>def <span class="ident">getCommitFromObj</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L1171-L1175" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getCommitFromObj(self, c):
    g = self.repoOnline
    if not g:
        return None
    return c.sha</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.getCommitObj"><code class="name flex">
<span>def <span class="ident">getCommitObj</span></span>(<span>self, commit)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L1142-L1160" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getCommitObj(self, commit):
    error = self.error

    g = self.repoOnline
    if not g:
        return None

    c = None
    msg = f&#39; with hash &#34;{commit}&#34;&#39; if commit else &#34;s&#34;

    try:
        cs = g.get_commits(sha=commit) if commit else g.get_commits()
        if cs.totalCount:
            c = cs[0]
        else:
            error(f&#34;\tno commit{msg}&#34;)
    except Exception:
        error(f&#34;\tcannot find commit{msg}&#34;)
    return c</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.getRelease"><code class="name flex">
<span>def <span class="ident">getRelease</span></span>(<span>self, release, showErrors=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L1114-L1118" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getRelease(self, release, showErrors=True):
    r = self.getReleaseObj(release, showErrors=showErrors)
    if not r:
        return None
    return self.getReleaseFromObj(r)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.getReleaseFromObj"><code class="name flex">
<span>def <span class="ident">getReleaseFromObj</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L1162-L1169" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getReleaseFromObj(self, r):
    g = self.repoOnline
    if not g:
        return None
    release = r.tag_name
    ref = g.get_git_ref(f&#34;tags/{release}&#34;)
    commit = ref.object.sha
    return (commit, release)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.getReleaseObj"><code class="name flex">
<span>def <span class="ident">getReleaseObj</span></span>(<span>self, release, showErrors=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L1126-L1140" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getReleaseObj(self, release, showErrors=True):
    g = self.repoOnline
    if not g:
        return None

    r = None
    msg = f&#39; tagged &#34;{release}&#34;&#39; if release else &#34;s&#34;

    try:
        r = g.get_release(release) if release else g.get_latest_release()
    except UnknownObjectException:
        self.possibleError(f&#34;\tno release{msg}&#34;, showErrors, newline=True)
    except Exception:
        self.possibleError(f&#34;\tcannot find release{msg}&#34;, showErrors, newline=True)
    return r</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.isClone"><code class="name flex">
<span>def <span class="ident">isClone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L699-L700" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isClone(self):
    return self.local == &#34;clone&#34;</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.isOffline"><code class="name flex">
<span>def <span class="ident">isOffline</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L702-L703" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isOffline(self):
    return self.local in {&#34;clone&#34;, &#34;local&#34;}</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, msg, newline=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L780-L783" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log(self, msg, newline=True):
    silent = self.silent
    if not silent:
        console(msg, newline=newline)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.makeSureLocal"><code class="name flex">
<span>def <span class="ident">makeSureLocal</span></span>(<span>self, attempt=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L804-L951" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeSureLocal(self, attempt=False):
    _browse = self._browse
    label = self.label
    offline = self.isOffline()
    clone = self.isClone()

    error = self.error
    warning = self.warning

    cOff = self.commitOff
    rOff = self.releaseOff
    cChk = self.commitChk
    rChk = self.releaseChk
    cOn = self.commitOn
    rOn = self.releaseOn
    rcOn = self.releaseCommitOn

    askExact = rChk or cChk
    askExactRelease = rChk
    askExactCommit = cChk
    askLatest = not askExact and (rChk == &#34;&#34; or cChk == &#34;&#34;)
    askLatestAny = rChk == &#34;&#34; and cChk == &#34;&#34;
    askLatestRelease = rChk == &#34;&#34; and cChk is None
    askLatestCommit = cChk == &#34;&#34; and rChk is None

    isExactReleaseOff = rChk and rChk == rOff
    isExactCommitOff = cChk and cChk == cOff
    isExactReleaseOn = rChk and rChk == rOn
    isExactCommitOn = cChk and cChk == cOn
    isLatestRelease = rOff and rOff == rOn or cOff and cOff == rcOn
    isLatestCommit = cOff and cOff == cOn

    isLocal = (
        askExactRelease
        and isExactReleaseOff
        or askExactCommit
        and isExactCommitOff
        or askLatestAny
        and (isLatestRelease or isLatestCommit)
        or askLatestRelease
        and isLatestRelease
        or askLatestCommit
        and isLatestCommit
    )
    mayLocal = (
        askLatestAny
        and (rOff or cOff)
        or askLatestRelease
        and rOff
        or askLatestCommit
        and cOff
    )
    canOnline = self.repoOnline
    isOnline = canOnline and (
        askExactRelease
        and isExactReleaseOn
        or askExactCommit
        and isExactCommitOn
        or askLatestAny
        or askLatestRelease
        or askLatestCommit
    )

    if offline:
        if clone:
            dirPath = self.dirPathClone
            self.localBase = self.baseClone if os.path.exists(dirPath) else False
        else:
            self.localBase = (
                self.baseLocal
                if (
                    cChk
                    and cChk == cOff
                    or cChk is None
                    and cOff
                    or rChk
                    and rChk == rOff
                    or rChk is None
                    and rOff
                )
                else False
            )
        if not self.localBase:
            method = self.warning if attempt else self.error
            method(f&#34;The requested {label} is not available offline&#34;)
            base = self.baseClone if clone else self.baseLocal
            method(f&#34;\t{base}/{self.dataPath} not found&#34;)
    else:
        if isLocal:
            self.localBase = self.baseLocal
        else:
            if not canOnline:
                if askLatest:
                    if mayLocal:
                        warning(f&#34;The offline {label} may not be the latest&#34;)
                        self.localBase = self.baseLocal
                    else:
                        error(f&#34;The requested {label} is not available offline&#34;)
                else:
                    warning(f&#34;The requested {label} is not available offline&#34;)
                    error(&#34;No online connection&#34;)
            elif not isOnline:
                error(f&#34;The requested {label} is not available online&#34;)
            else:
                self.localBase = self.baseLocal if self.download() else False

    if self.localBase:
        self.localDir = self.dataPath
        state = (
            &#34;requested&#34;
            if askExact
            else &#34;latest release&#34;
            if rChk == &#34;&#34; and canOnline and self.releaseOff
            else &#34;latest? release&#34;
            if rChk == &#34;&#34; and not canOnline and self.releaseOff
            else &#34;latest commit&#34;
            if cChk == &#34;&#34; and canOnline and self.commitOff
            else &#34;latest? commit&#34;
            if cChk == &#34;&#34; and not canOnline and self.commitOff
            else &#34;local release&#34;
            if self.local == &#34;local&#34; and self.releaseOff
            else &#34;local commit&#34;
            if self.local == &#34;local&#34; and self.commitOff
            else &#34;local github&#34;
            if self.local == &#34;clone&#34;
            else &#34;for whatever reason&#34;
        )
        offString = self.toString(
            self.commitOff,
            self.releaseOff,
            self.local,
            dest=self.dest,
            source=self.source,
        )
        labelEsc = htmlEsc(label)
        stateEsc = htmlEsc(state)
        offEsc = htmlEsc(offString)
        locEsc = htmlEsc(f&#34;{self.localBase}/{self.localDir}{self.versionRep}&#34;)
        if _browse:
            self.log(
                f&#34;Using {label} in {self.localBase}/{self.localDir}{self.versionRep}:&#34;
            )
            self.log(f&#34;\t{offString} ({state})&#34;)
        else:
            dh(
                f&#39;&lt;b title=&#34;{stateEsc}&#34;&gt;{labelEsc}:&lt;/b&gt;&#39;
                f&#39; &lt;span title=&#34;{offEsc}&#34;&gt;{locEsc}&lt;/span&gt;&#39;
            )</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.possibleError"><code class="name flex">
<span>def <span class="ident">possibleError</span></span>(<span>self, msg, showErrors, again=False, indent='\t', newline=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L793-L802" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def possibleError(self, msg, showErrors, again=False, indent=&#34;\t&#34;, newline=False):
    error = self.error
    warning = self.warning

    if showErrors:
        error(msg, newline=newline)
    else:
        warning(msg, newline=newline)
        if again:
            warning(f&#34;{indent}Will try something else&#34;)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.readInfo"><code class="name flex">
<span>def <span class="ident">readInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L1206-L1215" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readInfo(self):
    if os.path.exists(self.filePathLocal):
        with open(self.filePathLocal, encoding=&#34;utf8&#34;) as f:
            for line in f:
                string = line.strip()
                (commit, release, local) = self.fromString(string)
                if commit:
                    self.commitOff = commit
                if release:
                    self.releaseOff = release</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.warning"><code class="name flex">
<span>def <span class="ident">warning</span></span>(<span>self, msg, newline=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L785-L788" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def warning(self, msg, newline=True):
    silent = self.silent
    if not silent == &#34;deep&#34;:
        console(msg, newline=newline)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.writeInfo"><code class="name flex">
<span>def <span class="ident">writeInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L1217-L1224" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def writeInfo(self):
    if not os.path.exists(self.dirPathLocal):
        os.makedirs(self.dirPathLocal, exist_ok=True)
    with open(self.filePathLocal, &#34;w&#34;, encoding=&#34;utf8&#34;) as f:
        if self.releaseOff:
            f.write(f&#34;{self.releaseOff}\n&#34;)
        if self.commitOff:
            f.write(f&#34;{self.commitOff}\n&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tf.advanced.repo.Repo"><code class="flex name class">
<span>class <span class="ident">Repo</span></span>
<span>(</span><span>org, repo, folder, version, increase, source='~/github', dest='~/Downloads')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L387-L634" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Repo:
    def __init__(
        self,
        org,
        repo,
        folder,
        version,
        increase,
        source=GH_BASE,
        dest=DOWNLOADS,
    ):
        self.org = org
        self.repo = repo
        self.folder = folder
        self.version = version
        self.increase = increase
        self.source = os.path.expanduser(source)
        self.dest = os.path.expanduser(dest)

        self.repoOnline = None
        self.ghConn = None

    def newRelease(self):
        if not self.makeZip():
            return False

        self.connect()
        if not self.ghConn:
            return False

        if not self.fetchInfo():
            return False

        if not self.bumpRelease():
            return False

        if not self.makeRelease():
            return False

        if not self.uploadZip():
            return False

        return True

    def makeZip(self):
        source = self.source
        dest = self.dest
        org = self.org
        repo = self.repo
        folder = self.folder
        version = self.version

        dataIn = f&#34;{source}/{org}/{repo}/{folder}/{version}&#34;

        if not os.path.exists(dataIn):
            console(f&#34;No data found in {dataIn}&#34;, error=True)
            return False

        zipData(org, repo, version=version, relative=folder, source=source, dest=dest)
        return True

    def connect(self):
        warning = self.warning

        if not self.ghConn:
            ghPerson = os.environ.get(&#34;GHPERS&#34;, None)
            if ghPerson:
                self.ghConn = Github(ghPerson)
            else:
                ghClient = os.environ.get(&#34;GHCLIENT&#34;, None)
                ghSecret = os.environ.get(&#34;GHSECRET&#34;, None)
                if ghClient and ghSecret:
                    self.ghConn = Github(client_id=ghClient, client_secret=ghSecret)
                else:
                    self.ghConn = Github()
        try:
            rate = self.ghConn.get_rate_limit().core
            self.log(
                f&#34;rate limit is {rate.limit} requests per hour,&#34;
                f&#34; with {rate.remaining} left for this hour&#34;
            )
            if rate.limit &lt; 100:
                warning(f&#34;To increase the rate,&#34; f&#34;see {URL_TFDOC}/advanced/repo.html/&#34;)

            self.log(
                f&#34;\tconnecting to online GitHub repo {self.org}/{self.repo} ... &#34;,
                newline=False,
            )
            self.repoOnline = self.ghConn.get_repo(f&#34;{self.org}/{self.repo}&#34;)
            self.log(&#34;connected&#34;)
        except GithubException as why:
            warning(&#34;failed&#34;)
            warning(f&#34;GitHub says: {why}&#34;)
        except IOError:
            warning(&#34;no internet&#34;)

    def fetchInfo(self):
        g = self.repoOnline
        if not g:
            return False
        self.commitOn = None
        self.releaseOn = None
        self.releaseCommitOn = None
        result = self.getRelease()
        if result:
            self.releaseOn = result
        result = self.getCommit()
        if result:
            self.commitOn = result
        return True

    def bumpRelease(self):
        increase = self.increase

        latestR = self.releaseOn
        if latestR:
            console(f&#34;Latest release = {latestR}&#34;)
        else:
            latestR = &#34;v0.0.0&#34;
            console(&#34;No releases yet&#34;)

        # bump the release version

        v = &#34;&#34;
        if latestR.startswith(&#34;v&#34;):
            v = &#34;v&#34;
            r = latestR[1:] if latestR.startswith(&#34;v&#34;) else latestR
        parts = [int(p) for p in r.split(&#34;.&#34;)]
        nParts = len(parts)
        if nParts &lt; increase:
            for i in range(nParts, increase):
                parts.append(0)
        parts[increase - 1] += 1
        parts[increase:] = []
        newTag = f&#34;{v}{&#39;.&#39;.join(str(p) for p in parts)}&#34;
        console(f&#34;New release = {newTag}&#34;)
        self.newTag = newTag
        return True

    def makeRelease(self):
        commit = self.commitOn
        newTag = self.newTag

        g = self.repoOnline
        if not g:
            return False

        tag_message = &#34;data update&#34;
        release_name = &#34;data update&#34;
        release_message = &#34;data update&#34;

        try:
            newReleaseObj = g.create_git_tag_and_release(
                newTag,
                tag_message,
                release_name,
                release_message,
                commit,
                &#34;commit&#34;,
            )
        except Exception as e:
            self.error(&#34;\tcannot create release&#34;, newline=True)
            console(str(e), error=True)
            return False

        self.newReleaseObj = newReleaseObj
        return True

    def uploadZip(self):
        newTag = self.newTag
        newReleaseObj = self.newReleaseObj
        dest = self.dest
        org = self.org
        repo = self.repo
        folder = self.folder
        version = self.version
        dataFile = f&#34;{folder}-{version}.zip&#34;
        dataDir = f&#34;{dest}/{org}-release/{repo}&#34;
        dataPath = f&#34;{dataDir}/{dataFile}&#34;

        if not os.path.exists(dataPath):
            console(f&#34;No release data found: {dataPath}&#34;, error=True)
            return False

        try:
            newReleaseObj.upload_asset(dataPath, label=&#39;&#39;, content_type=&#34;application/zip&#34;, name=dataFile)
            console(f&#34;{dataFile} attached to release {newTag}&#34;)
        except Exception as e:
            self.error(&#34;\tcannot attach zipfile to release&#34;, newline=True)
            console(str(e), error=True)
            return False

        return True

    def getRelease(self):
        r = self.getReleaseObj()
        if not r:
            return None
        return r.tag_name

    def getReleaseObj(self):
        g = self.repoOnline
        if not g:
            return None

        r = None

        try:
            r = g.get_latest_release()
        except UnknownObjectException:
            self.error(&#34;\tno releases&#34;, newline=True)
        except Exception:
            self.error(&#34;\tcannot find releases&#34;, newline=True)
        return r

    def getCommit(self):
        c = self.getCommitObj()
        if not c:
            return None
        return c.sha

    def getCommitObj(self):
        error = self.error

        g = self.repoOnline
        if not g:
            return None

        c = None

        try:
            cs = g.get_commits()
            if cs.totalCount:
                c = cs[0]
            else:
                error(&#34;\tno commits&#34;)
        except Exception:
            error(&#34;\tcannot find commits&#34;)
        return c

    def log(self, msg, newline=True):
        console(msg, newline=newline)

    def warning(self, msg, newline=True):
        console(msg, newline=newline)

    def error(self, msg, newline=True):
        console(msg, error=True, newline=newline)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.advanced.repo.Repo.bumpRelease"><code class="name flex">
<span>def <span class="ident">bumpRelease</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L498-L524" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bumpRelease(self):
    increase = self.increase

    latestR = self.releaseOn
    if latestR:
        console(f&#34;Latest release = {latestR}&#34;)
    else:
        latestR = &#34;v0.0.0&#34;
        console(&#34;No releases yet&#34;)

    # bump the release version

    v = &#34;&#34;
    if latestR.startswith(&#34;v&#34;):
        v = &#34;v&#34;
        r = latestR[1:] if latestR.startswith(&#34;v&#34;) else latestR
    parts = [int(p) for p in r.split(&#34;.&#34;)]
    nParts = len(parts)
    if nParts &lt; increase:
        for i in range(nParts, increase):
            parts.append(0)
    parts[increase - 1] += 1
    parts[increase:] = []
    newTag = f&#34;{v}{&#39;.&#39;.join(str(p) for p in parts)}&#34;
    console(f&#34;New release = {newTag}&#34;)
    self.newTag = newTag
    return True</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L448-L481" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def connect(self):
    warning = self.warning

    if not self.ghConn:
        ghPerson = os.environ.get(&#34;GHPERS&#34;, None)
        if ghPerson:
            self.ghConn = Github(ghPerson)
        else:
            ghClient = os.environ.get(&#34;GHCLIENT&#34;, None)
            ghSecret = os.environ.get(&#34;GHSECRET&#34;, None)
            if ghClient and ghSecret:
                self.ghConn = Github(client_id=ghClient, client_secret=ghSecret)
            else:
                self.ghConn = Github()
    try:
        rate = self.ghConn.get_rate_limit().core
        self.log(
            f&#34;rate limit is {rate.limit} requests per hour,&#34;
            f&#34; with {rate.remaining} left for this hour&#34;
        )
        if rate.limit &lt; 100:
            warning(f&#34;To increase the rate,&#34; f&#34;see {URL_TFDOC}/advanced/repo.html/&#34;)

        self.log(
            f&#34;\tconnecting to online GitHub repo {self.org}/{self.repo} ... &#34;,
            newline=False,
        )
        self.repoOnline = self.ghConn.get_repo(f&#34;{self.org}/{self.repo}&#34;)
        self.log(&#34;connected&#34;)
    except GithubException as why:
        warning(&#34;failed&#34;)
        warning(f&#34;GitHub says: {why}&#34;)
    except IOError:
        warning(&#34;no internet&#34;)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>self, msg, newline=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L633-L634" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def error(self, msg, newline=True):
    console(msg, error=True, newline=newline)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.fetchInfo"><code class="name flex">
<span>def <span class="ident">fetchInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L483-L496" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fetchInfo(self):
    g = self.repoOnline
    if not g:
        return False
    self.commitOn = None
    self.releaseOn = None
    self.releaseCommitOn = None
    result = self.getRelease()
    if result:
        self.releaseOn = result
    result = self.getCommit()
    if result:
        self.commitOn = result
    return True</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.getCommit"><code class="name flex">
<span>def <span class="ident">getCommit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L602-L606" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getCommit(self):
    c = self.getCommitObj()
    if not c:
        return None
    return c.sha</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.getCommitObj"><code class="name flex">
<span>def <span class="ident">getCommitObj</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L608-L625" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getCommitObj(self):
    error = self.error

    g = self.repoOnline
    if not g:
        return None

    c = None

    try:
        cs = g.get_commits()
        if cs.totalCount:
            c = cs[0]
        else:
            error(&#34;\tno commits&#34;)
    except Exception:
        error(&#34;\tcannot find commits&#34;)
    return c</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.getRelease"><code class="name flex">
<span>def <span class="ident">getRelease</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L581-L585" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getRelease(self):
    r = self.getReleaseObj()
    if not r:
        return None
    return r.tag_name</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.getReleaseObj"><code class="name flex">
<span>def <span class="ident">getReleaseObj</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L587-L600" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getReleaseObj(self):
    g = self.repoOnline
    if not g:
        return None

    r = None

    try:
        r = g.get_latest_release()
    except UnknownObjectException:
        self.error(&#34;\tno releases&#34;, newline=True)
    except Exception:
        self.error(&#34;\tcannot find releases&#34;, newline=True)
    return r</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, msg, newline=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L627-L628" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log(self, msg, newline=True):
    console(msg, newline=newline)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.makeRelease"><code class="name flex">
<span>def <span class="ident">makeRelease</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L526-L553" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeRelease(self):
    commit = self.commitOn
    newTag = self.newTag

    g = self.repoOnline
    if not g:
        return False

    tag_message = &#34;data update&#34;
    release_name = &#34;data update&#34;
    release_message = &#34;data update&#34;

    try:
        newReleaseObj = g.create_git_tag_and_release(
            newTag,
            tag_message,
            release_name,
            release_message,
            commit,
            &#34;commit&#34;,
        )
    except Exception as e:
        self.error(&#34;\tcannot create release&#34;, newline=True)
        console(str(e), error=True)
        return False

    self.newReleaseObj = newReleaseObj
    return True</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.makeZip"><code class="name flex">
<span>def <span class="ident">makeZip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L431-L446" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeZip(self):
    source = self.source
    dest = self.dest
    org = self.org
    repo = self.repo
    folder = self.folder
    version = self.version

    dataIn = f&#34;{source}/{org}/{repo}/{folder}/{version}&#34;

    if not os.path.exists(dataIn):
        console(f&#34;No data found in {dataIn}&#34;, error=True)
        return False

    zipData(org, repo, version=version, relative=folder, source=source, dest=dest)
    return True</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.newRelease"><code class="name flex">
<span>def <span class="ident">newRelease</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L409-L429" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def newRelease(self):
    if not self.makeZip():
        return False

    self.connect()
    if not self.ghConn:
        return False

    if not self.fetchInfo():
        return False

    if not self.bumpRelease():
        return False

    if not self.makeRelease():
        return False

    if not self.uploadZip():
        return False

    return True</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.uploadZip"><code class="name flex">
<span>def <span class="ident">uploadZip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L555-L579" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def uploadZip(self):
    newTag = self.newTag
    newReleaseObj = self.newReleaseObj
    dest = self.dest
    org = self.org
    repo = self.repo
    folder = self.folder
    version = self.version
    dataFile = f&#34;{folder}-{version}.zip&#34;
    dataDir = f&#34;{dest}/{org}-release/{repo}&#34;
    dataPath = f&#34;{dataDir}/{dataFile}&#34;

    if not os.path.exists(dataPath):
        console(f&#34;No release data found: {dataPath}&#34;, error=True)
        return False

    try:
        newReleaseObj.upload_asset(dataPath, label=&#39;&#39;, content_type=&#34;application/zip&#34;, name=dataFile)
        console(f&#34;{dataFile} attached to release {newTag}&#34;)
    except Exception as e:
        self.error(&#34;\tcannot attach zipfile to release&#34;, newline=True)
        console(str(e), error=True)
        return False

    return True</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.warning"><code class="name flex">
<span>def <span class="ident">warning</span></span>(<span>self, msg, newline=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4fbf272b7a61ece60b7ef4e73d3d6f4a35b50960/tf/advanced/repo.py#L630-L631" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def warning(self, msg, newline=True):
    console(msg, newline=newline)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#auto-downloading-from-github">Auto downloading from GitHub</a><ul>
<li><a href="#description">Description</a></li>
<li><a href="#result">Result</a></li>
<li><a href="#checkout-source-and-dest">checkout, source and dest</a></li>
<li><a href="#other-parameters">other parameters</a></li>
<li><a href="#rate-limiting">Rate limiting</a></li>
</ul>
</li>
<li><a href="#github">GitHub</a><ul>
<li><a href="#increase-the-rate-limit">Increase the rate limit</a><ul>
<li><a href="#on-mac-and-linux">On Mac and Linux</a></li>
<li><a href="#on-windows">On Windows</a></li>
<li><a href="#result_1">Result</a></li>
</ul>
</li>
<li><a href="#minimize-accessing-github">Minimize accessing Github</a><ul>
<li><a href="#using-a-corpus-for-the-first-time-within-the-rate-limit">Using a corpus for the first time, within the rate limit</a></li>
<li><a href="#using-a-corpus-for-the-first-time-after-hitting-the-rate-limit">Using a corpus for the first time, after hitting the rate limit</a></li>
<li><a href="#using-a-corpus-that-you-already-have">Using a corpus that you already have</a></li>
<li><a href="#updating-a-corpus-that-you-already-have">Updating a corpus that you already have</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.advanced" href="index.html">tf.advanced</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.advanced.repo.checkoutRepo" href="#tf.advanced.repo.checkoutRepo">checkoutRepo</a></code></li>
<li><code><a title="tf.advanced.repo.releaseData" href="#tf.advanced.repo.releaseData">releaseData</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.advanced.repo.Checkout" href="#tf.advanced.repo.Checkout">Checkout</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.advanced.repo.Checkout.connect" href="#tf.advanced.repo.Checkout.connect">connect</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.download" href="#tf.advanced.repo.Checkout.download">download</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.downloadCommit" href="#tf.advanced.repo.Checkout.downloadCommit">downloadCommit</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.downloadDir" href="#tf.advanced.repo.Checkout.downloadDir">downloadDir</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.downloadRelease" href="#tf.advanced.repo.Checkout.downloadRelease">downloadRelease</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.downloadZip" href="#tf.advanced.repo.Checkout.downloadZip">downloadZip</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.error" href="#tf.advanced.repo.Checkout.error">error</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.fetchInfo" href="#tf.advanced.repo.Checkout.fetchInfo">fetchInfo</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.fixInfo" href="#tf.advanced.repo.Checkout.fixInfo">fixInfo</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.fromString" href="#tf.advanced.repo.Checkout.fromString">fromString</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.getCommit" href="#tf.advanced.repo.Checkout.getCommit">getCommit</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.getCommitFromObj" href="#tf.advanced.repo.Checkout.getCommitFromObj">getCommitFromObj</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.getCommitObj" href="#tf.advanced.repo.Checkout.getCommitObj">getCommitObj</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.getRelease" href="#tf.advanced.repo.Checkout.getRelease">getRelease</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.getReleaseFromObj" href="#tf.advanced.repo.Checkout.getReleaseFromObj">getReleaseFromObj</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.getReleaseObj" href="#tf.advanced.repo.Checkout.getReleaseObj">getReleaseObj</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.isClone" href="#tf.advanced.repo.Checkout.isClone">isClone</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.isOffline" href="#tf.advanced.repo.Checkout.isOffline">isOffline</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.log" href="#tf.advanced.repo.Checkout.log">log</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.makeSureLocal" href="#tf.advanced.repo.Checkout.makeSureLocal">makeSureLocal</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.possibleError" href="#tf.advanced.repo.Checkout.possibleError">possibleError</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.readInfo" href="#tf.advanced.repo.Checkout.readInfo">readInfo</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.toString" href="#tf.advanced.repo.Checkout.toString">toString</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.warning" href="#tf.advanced.repo.Checkout.warning">warning</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.writeInfo" href="#tf.advanced.repo.Checkout.writeInfo">writeInfo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tf.advanced.repo.Repo" href="#tf.advanced.repo.Repo">Repo</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.advanced.repo.Repo.bumpRelease" href="#tf.advanced.repo.Repo.bumpRelease">bumpRelease</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.connect" href="#tf.advanced.repo.Repo.connect">connect</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.error" href="#tf.advanced.repo.Repo.error">error</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.fetchInfo" href="#tf.advanced.repo.Repo.fetchInfo">fetchInfo</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.getCommit" href="#tf.advanced.repo.Repo.getCommit">getCommit</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.getCommitObj" href="#tf.advanced.repo.Repo.getCommitObj">getCommitObj</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.getRelease" href="#tf.advanced.repo.Repo.getRelease">getRelease</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.getReleaseObj" href="#tf.advanced.repo.Repo.getReleaseObj">getReleaseObj</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.log" href="#tf.advanced.repo.Repo.log">log</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.makeRelease" href="#tf.advanced.repo.Repo.makeRelease">makeRelease</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.makeZip" href="#tf.advanced.repo.Repo.makeZip">makeZip</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.newRelease" href="#tf.advanced.repo.Repo.newRelease">newRelease</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.uploadZip" href="#tf.advanced.repo.Repo.uploadZip">uploadZip</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.warning" href="#tf.advanced.repo.Repo.warning">warning</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="../../tf/images/DANS-logo.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>