<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tf.advanced.app API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.advanced.app</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/70483c9fc7920a9380e010f78f5483ebb84ed24f/tf/advanced/app.py#L0-L547" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import os
import types
import traceback

from ..parameters import ORG, APP_CODE
from ..fabric import Fabric
from ..parameters import APIREF, TEMP_DIR
from ..lib import readSets
from ..core.helpers import console, setDir, mergeDict
from .find import findAppConfig, findAppClass
from .helpers import getText, dm, dh
from .settings import setAppSpecs, setAppSpecsApi
from .volumes import volumesApi
from .links import linksApi, outLink
from .text import textApi
from .sections import sectionsApi
from .display import displayApi
from .search import searchApi
from .data import getModulesData
from .repo import checkoutRepo


# SET UP A TF API FOR AN APP


FROM_TF_METHODS = &#34;&#34;&#34;
    banner
    silentOn
    silentOff
    isSilent
    setSilent
    info
    warning
    error
    indent
&#34;&#34;&#34;.strip().split()


class App:
    def __init__(
        self,
        cfg,
        appName,
        appPath,
        commit,
        release,
        local,
        _browse,
        hoist=False,
        version=None,
        checkout=&#34;&#34;,
        mod=None,
        locations=None,
        modules=None,
        volume=None,
        collection=None,
        api=None,
        setFile=&#34;&#34;,
        silent=False,
        **configOverrides,
    ):
        &#34;&#34;&#34;Set up the advanced TF API.

        Parameters
        ----------
        appName: string
            The appname  can be as simple as the name of an existing TF-app.
            The app should exist as a repository `app-`*appName* under
            [github.com/annotation](https://github.com/annotation).

            If there is a `/` in the *appName argument*,
            it is interpreted as a location on your system or on GitHub.

            If it points to a directory with a *config.yaml* in it,
            this config file will be read and interpreted as settings
            for the advanced API.
            If there is also a *app.py*, it will be imported as custom application code.
            And if there is a *static/display.css* there, it will be used
            for styling the display of corpus material.

            If there is no `config.yaml` there, it will be assumed that there are
            `.tf` data files in that location, and they will be loaded.
            The advanced API will work with default settings,
            based on the `.tf` data found.

            !!! hint &#34;appName:specifier, checkout=specifier&#34;
                You may want to load downloadable features from the internet,
                or you want to experiment with features you are developing.
                The specifiers let you use a specific point in the
                history of the app and data.

                *appName:specifier* is used for retrieving a TF-app (*code*).

                *checkout=specifier* is for retrieving the corpus itself  (*data*).

                *   `&#39;&#39;` (empty string or absent) (**default**):
                    use local data if it is present under `~/text-fabric-data`,
                    otherwise use the latest release if there are releases online,
                    otherwise, use the latest commit.
                *   `latest`: use the latest release.
                    If there are commits after the commit that has been tagged
                    with the latest release, these will **not** be used.
                *   `hot`: use the latest commit, even if it comes after the
                    latest commit of the latest release.
                *   *release tag*, e.g. `v1.3`: use exactly this release.
                    More precisely, this is the commit that has been tagged
                    with that release tag.
                *   *commit hash*, e.g. `2d0ca1f593805af0c13c4a62ed7405b94d870045`:
                    use exactly this commit.
                *   `local`: use local data from your `~/text-fabric-data` directory
                    if it is present, otherwise fail.
                *   `clone`: use local data from your `~/github` directory
                    if it is present, otherwise fail.

                For a demo, see
                [banks/repo](https://nbviewer.jupyter.org/github/annotation/tutorials/blob/master/banks/repo.ipynb)

        hoist: dict, optional `False`
            If you pass `globals()`, the core API elements are made directly available
            as global names in your script or notebook:

            * `tf.core.nodefeature.NodeFeature` as `F` instead of `A.api.F`
            * `tf.core.locality.Locality` as `L` instead of `A.api.L`
            * `tf.core.text.Text` as `T` instead of `A.api.T`
            * and a few others (listed after executing the incantation)

        version: string, optional `None`
            If you do not want to work with the default version of your main corpus,
            you can specify a different version here.

            !!! caution &#34;Modules&#34;
                If you also ask for extra data modules by means of the `mod` argument,
                then the corresponding version of those modules will be chosen.
                Every properly designed data module must refer to a specific
                version of the main source!

        mod: string, optional `None`
            A comma-separated list of modules in one of the forms

               {org}/{repo}/{path}`

            or

               {org}/{repo}/{path}:specifier`

            All features of all those modules will be loaded.
            If they are not yet present, they will be downloaded from GitHub first.

            For example, there is an easter egg module on GitHub,
            and you can obtain it by

               mod=&#39;etcbc/lingo/easter/tf&#39;`

            Here the `{org}` is `etcbc`, the `{repo}` is `lingo`,
            and the `{path}` is `easter/tf` under which
            version `c` of the feature `egg`
            is available in TF format.

            You can point to any such directory om the entire GitHub
            if you know that it contains relevant features.

            The specifier is as in `appName:specifier` and `checkData=specifier`.
            It is used to get data from a different point in the history.

            Your TF app might be configured to download specific modules.
            See `moduleSpecs` in the app&#39;s `config.yaml` file.

            !!! caution &#34;Let TF manage your text-fabric-data directory&#34;
                It is better not to fiddle with your `~/text-fabric-data` directory
                manually. Let it be filled with auto-downloaded data.
                You can then delete data sources and modules when needed,
                and have them redownloaded at your wish,
                without any hassle or data loss.

        locations, modules: string, optional `None`
            If you want to add other search locations for TF features manually,
            you can pass optional `locations` and `modules` parameters,
            which will be passed to the `tf.fabric.Fabric` call to the core of TF.

            !!! note &#34;More, not less&#34;
                Using these arguments will load features on top of the
                default selection of features.
                You cannot use these arguments to prevent features from being loaded.

            !!! note &#34;appName with `/`&#34;
                If you use the *appName* argument with a `/` in it,
                and it does not point to a TF app you have locally,
                it will be interpreted as a *locations* search path to find `.tf` files.
                It acts as the main `locations` argument,
                and will be combined with the `modules` argument.

        collection: string
            Triggers the loading of a single collection of
            volumes of the work. The collection is a directory with `.tf` files,
            located under the directory `_local` which is in the
            same directory as the `.tf` files of the work.
            See `tf.about.volumes`.

        volume: string
            Triggers the loading of a single volume of
            the work. The volume is a directory with `.tf` files,
            located under the directory `_local` which is in the
            same directory as the `.tf` files of the work.
            See `tf.about.volumes`.

        api: object, optional, `None`
            So far, the TF app will construct an advanced API
            with a more or less standard set of features
            loaded, and make that API avaible to you, under `A.api`.

            But you can also setup a core API yourself by using
            `tf.fabric.Fabric` with your choice of locations and modules:

               from tf.fabric import Fabric`
               TF = Fabric(locations=..., modules=...)`
               api = TF.load(features)`

            Here you have full control over what you load and what not.

            If you want the extra power of the TF app, you can wrap this `api`:

               A = use(&#39;xxxx&#39;, api=api)`

            !!! hint &#34;Unloaded features&#34;
                Some apps do not load all available features of the corpus by default.

                This happens when a corpus contains quite a number of features
                that most people never need.
                Loading them cost time and takes a lot of RAM.

                In the case where you need an available feature
                that has not been loaded, you can load it by demanding

                   TF.load(&#39;feature1 feature2&#39;, add=True)`

                provided you have used the `hoist=globals()` parameter earlier.
                If not, you have to say

                   A.api.TF.load(&#39;feature1 feature2&#39;, add=True)`

        setFile: string, optional, `None`
            The name of a file that contains condensed set information,
            produces with `tf.lib.writeSets`.
            These sets will be read and will become usable in TF queries.

        silent: boolean, optional `False`
            If `True`, nearly all output of this call will be suppressed,
            including the links to the loaded
            data, features, and the API methods.
            Error messages will still come through.

        configOverrides: key value pairs
            All values here will be used to override configuration settings
            that are specified in the app&#39;s `config.yaml` file.
            The list of those settings is spelled out in
            `tf.advanced.settings`.

        !!! caution &#34;Volumes and collections&#34;
            It is an error to load a volume as a collection and vice-versa

            You get a warning if you pass both a volume and a collection.
            The collection takes precedence, and the volume is ignored in that case.

        See Also
        --------
        tf.about.corpora: list of corpora with an official TF app
        tf.advanced.settings: description of what can go in a `config.yaml`
        &#34;&#34;&#34;

        self.context = None
        &#34;&#34;&#34;Result of interpreting all configuration options in `config.yaml`.

        See Also
        --------
        tf.advanced.settings.showContext
        &#34;&#34;&#34;

        mergeDict(cfg, configOverrides)

        for (key, value) in dict(
            isCompatible=cfg.get(&#34;isCompatible&#34;, None),
            appName=appName,
            api=api,
            version=version,
            volume=volume,
            collection=collection,
            silent=silent,
            _browse=_browse,
        ).items():
            setattr(self, key, value)

        setattr(self, &#34;dm&#34;, dm)
        setattr(self, &#34;dh&#34;, dh)

        setAppSpecs(self, cfg)
        aContext = self.context
        version = aContext.version

        setDir(self)

        if not self.api:
            self.sets = None
            if setFile:
                sets = readSets(setFile)
                if sets:
                    self.sets = sets
                    console(f&#39;Sets from {setFile}: {&#34;, &#34;.join(sets)}&#39;)
            specs = getModulesData(
                self, mod, locations, modules, version, checkout, silent
            )
            if specs:
                (locations, modules) = specs
                self.tempDir = f&#34;{self.repoLocation}/{TEMP_DIR}&#34;
                TF = Fabric(
                    locations=locations,
                    modules=modules,
                    volume=volume,
                    collection=collection,
                    silent=silent,
                )
                api = TF.load(&#34;&#34;, silent=True)
                if api:
                    self.api = api
                    excludedFeatures = aContext.excludedFeatures
                    allFeatures = TF.explore(silent=True, show=True)
                    loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
                    useFeatures = [
                        f for f in loadableFeatures if f not in excludedFeatures
                    ]
                    result = TF.load(useFeatures, add=True, silent=True)
                    if result is False:
                        self.api = None
            else:
                self.api = None

        if self.api:
            self.TF = self.api.TF
            for m in FROM_TF_METHODS:
                setattr(self, m, getattr(self.TF, m))
            self.getText = types.MethodType(getText, self)
            volumesApi(self)
            linksApi(self, silent)
            searchApi(self)
            sectionsApi(self)
            setAppSpecsApi(self, cfg)
            displayApi(self, silent)
            textApi(self)
            setattr(self, &#34;isLoaded&#34;, self.api.isLoaded)
            if hoist:
                # docs = self.api.makeAvailableIn(hoist)
                self.api.makeAvailableIn(hoist)
                if not silent:
                    dh(
                        &#34;&lt;div&gt;&lt;b&gt;Text-Fabric API:&lt;/b&gt; names &#34;
                        + outLink(
                            &#34;N F E L T S C TF&#34;,
                            APIREF,
                            title=&#34;doc&#34;,
                        )
                        + &#34; directly usable&lt;/div&gt;&lt;hr&gt;&#34;
                    )

            silentOff = self.silentOff
            silentOff()
        else:
            if not _browse:
                console(
                    f&#34;&#34;&#34;
There were problems with loading data.
The Text-Fabric API has not been loaded!
The app &#34;{appName}&#34; will not work!
&#34;&#34;&#34;,
                    error=True,
                )

    def reinit(self):
        &#34;&#34;&#34;TF-Apps may override this method.
        It is called by `reuse`. Hence it needs to be present.
        &#34;&#34;&#34;

        pass

    def reuse(self, hoist=False):
        &#34;&#34;&#34;Re-initialize the app.

        The app&#39;s settings are read again, the app&#39;s code is re-imported,
        the app&#39;s stylesheets are applied again.
        But the data is left untouched, and no time-consuming reloading of data
        takes place.

        Handy when you are developing a new app and want to experiment with it
        without the costly re-loading of the data in every cycle.

        Parameters
        ----------
        hoist: boolean, optional `False`
            Same as in `App`.

        !!! hint &#34;the effect of the config settings&#34;
            If you are developing a TF app and need to see the effects of
            the configuration settings in detail, you can conveniently
            call `reuse` and `tf.advanced.settings.showContext` in tandem.
        &#34;&#34;&#34;

        aContext = self.context
        appPath = aContext.appPath
        appName = aContext.appName
        local = aContext.local
        commit = aContext.commit
        release = aContext.release
        version = aContext.version
        api = self.api

        cfg = findAppConfig(appName, appPath, commit, release, local, version=version)
        findAppClass(appName, appPath)

        setAppSpecs(self, cfg, reset=True)

        if api:
            TF = self.TF
            TF._makeApi()
            api = TF.api
            self.api = api
            self.reinit()  # may be used by custom TF apps
            linksApi(self, True)
            searchApi(self)
            sectionsApi(self)
            setAppSpecsApi(self, cfg)
            displayApi(self, True)
            textApi(self)
            if hoist:
                api.makeAvailableIn(hoist)


def findApp(appName, checkoutApp, _browse, *args, silent=False, version=None, **kwargs):
    &#34;&#34;&#34;Find a TF app by name and initialize an object of its main class.

    Parameters
    ----------
    appName: string
        Either:

        * the plain name of an official TF app (e.g. `bhsa`, `oldbabylonian`)
        * or a local directory, containing at least one `/`:
          * if it points to a directory under which an unofficial app sits:
            that app will be loaded
          * else it is assumed that the local directory is a TF data directory:
            a vanilla app without extra configuration is initialized
            and this local directory is supplied for its `locations`
            parameter. This has the effect that the TF features here will
            be loaded.

    checkoutApp: string
        The checkout specifier for the app code. See `tf.advanced.app.App`.

    args: mixed
        Arguments that will be passed to the initializer of the `tf.advanced.app.App`
        class.

    kwargs: mixed
        Keyword arguments that will be passed to the initializer of the
        `tf.advanced.app.App` class.

    &#34;&#34;&#34;

    (commit, release, local) = (None, None, None)
    extraMod = None

    if not appName or (&#34;/&#34; in appName and checkoutApp == &#34;&#34;):
        appPath = os.path.expanduser(appName) if appName else &#34;&#34;
        absPath = os.path.abspath(appPath)

        if os.path.isdir(absPath):
            (appDir, appName) = os.path.split(absPath)
            codePath = f&#34;{absPath}/{APP_CODE}&#34;
            if os.path.isdir(codePath):
                appDir = codePath
            appBase = &#34;&#34;
        else:
            console(f&#34;{absPath} is not an existing directory&#34;, error=True)
            appBase = False
            appDir = None
        appPath = appDir
    elif &#34;/&#34; in appName and checkoutApp != &#34;&#34;:
        appBase = &#34;&#34;
        appDir = &#34;&#34;
        appPath = appDir
        extraMod = f&#34;{appName}:{checkoutApp}&#34;
    else:
        (commit, release, local, appBase, appDir) = checkoutRepo(
            _browse=_browse,
            org=ORG,
            repo=f&#34;app-{appName}&#34;,
            folder=APP_CODE,
            checkout=checkoutApp,
            withPaths=True,
            keep=False,
            silent=silent,
            label=&#34;TF-app&#34;,
        )
        appBaseRep = f&#34;{appBase}/&#34; if appBase else &#34;&#34;
        appPath = f&#34;{appBaseRep}{appDir}&#34;

    if appPath is None:
        return None

    cfg = findAppConfig(appName, appPath, commit, release, local, version=version)
    version = cfg[&#34;provenanceSpec&#34;].get(&#34;version&#34;, None)
    isCompatible = cfg[&#34;isCompatible&#34;]
    if isCompatible is None:
        appClass = App
    elif not isCompatible:
        return None
    else:
        appBaseRep = f&#34;{appBase}/&#34; if appBase else &#34;&#34;
        appPath = f&#34;{appBaseRep}{appDir}&#34;

        appClass = findAppClass(appName, appPath) or App
    if extraMod:
        if kwargs.get(&#34;mod&#34;, None):
            kwargs[&#34;mod&#34;] = f&#34;{extraMod},{kwargs[&#39;mod&#39;]}&#34;
        else:
            kwargs[&#34;mod&#34;] = extraMod
    try:
        app = appClass(
            cfg,
            appName,
            appPath,
            commit,
            release,
            local,
            _browse,
            *args,
            version=version,
            silent=silent,
            **kwargs,
        )
    except Exception as e:
        if appClass is not App:
            console(
                f&#34;There was an error loading TF-app {appName} from {appPath}&#34;,
                error=True,
            )
            console(repr(e), error=True)
        traceback.print_exc()
        console(&#34;Text-Fabric is not loaded&#34;, error=True)
        return None
    return app</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.advanced.app.findApp"><code class="name flex">
<span>def <span class="ident">findApp</span></span>(<span>appName, checkoutApp, _browse, *args, silent=False, version=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Find a TF app by name and initialize an object of its main class.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>appName</code></strong> :&ensp;<code>string</code></dt>
<dd>
<p>Either:</p>
<ul>
<li>the plain name of an official TF app (e.g. <code>bhsa</code>, <code>oldbabylonian</code>)</li>
<li>or a local directory, containing at least one <code>/</code>:</li>
<li>if it points to a directory under which an unofficial app sits:
that app will be loaded</li>
<li>else it is assumed that the local directory is a TF data directory:
a vanilla app without extra configuration is initialized
and this local directory is supplied for its <code>locations</code>
parameter. This has the effect that the TF features here will
be loaded.</li>
</ul>
</dd>
<dt><strong><code>checkoutApp</code></strong> :&ensp;<code>string</code></dt>
<dd>The checkout specifier for the app code. See <code><a title="tf.advanced.app.App" href="#tf.advanced.app.App">App</a></code>.</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>mixed</code></dt>
<dd>Arguments that will be passed to the initializer of the <code><a title="tf.advanced.app.App" href="#tf.advanced.app.App">App</a></code>
class.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>mixed</code></dt>
<dd>Keyword arguments that will be passed to the initializer of the
<code><a title="tf.advanced.app.App" href="#tf.advanced.app.App">App</a></code> class.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/70483c9fc7920a9380e010f78f5483ebb84ed24f/tf/advanced/app.py#L435-L548" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findApp(appName, checkoutApp, _browse, *args, silent=False, version=None, **kwargs):
    &#34;&#34;&#34;Find a TF app by name and initialize an object of its main class.

    Parameters
    ----------
    appName: string
        Either:

        * the plain name of an official TF app (e.g. `bhsa`, `oldbabylonian`)
        * or a local directory, containing at least one `/`:
          * if it points to a directory under which an unofficial app sits:
            that app will be loaded
          * else it is assumed that the local directory is a TF data directory:
            a vanilla app without extra configuration is initialized
            and this local directory is supplied for its `locations`
            parameter. This has the effect that the TF features here will
            be loaded.

    checkoutApp: string
        The checkout specifier for the app code. See `tf.advanced.app.App`.

    args: mixed
        Arguments that will be passed to the initializer of the `tf.advanced.app.App`
        class.

    kwargs: mixed
        Keyword arguments that will be passed to the initializer of the
        `tf.advanced.app.App` class.

    &#34;&#34;&#34;

    (commit, release, local) = (None, None, None)
    extraMod = None

    if not appName or (&#34;/&#34; in appName and checkoutApp == &#34;&#34;):
        appPath = os.path.expanduser(appName) if appName else &#34;&#34;
        absPath = os.path.abspath(appPath)

        if os.path.isdir(absPath):
            (appDir, appName) = os.path.split(absPath)
            codePath = f&#34;{absPath}/{APP_CODE}&#34;
            if os.path.isdir(codePath):
                appDir = codePath
            appBase = &#34;&#34;
        else:
            console(f&#34;{absPath} is not an existing directory&#34;, error=True)
            appBase = False
            appDir = None
        appPath = appDir
    elif &#34;/&#34; in appName and checkoutApp != &#34;&#34;:
        appBase = &#34;&#34;
        appDir = &#34;&#34;
        appPath = appDir
        extraMod = f&#34;{appName}:{checkoutApp}&#34;
    else:
        (commit, release, local, appBase, appDir) = checkoutRepo(
            _browse=_browse,
            org=ORG,
            repo=f&#34;app-{appName}&#34;,
            folder=APP_CODE,
            checkout=checkoutApp,
            withPaths=True,
            keep=False,
            silent=silent,
            label=&#34;TF-app&#34;,
        )
        appBaseRep = f&#34;{appBase}/&#34; if appBase else &#34;&#34;
        appPath = f&#34;{appBaseRep}{appDir}&#34;

    if appPath is None:
        return None

    cfg = findAppConfig(appName, appPath, commit, release, local, version=version)
    version = cfg[&#34;provenanceSpec&#34;].get(&#34;version&#34;, None)
    isCompatible = cfg[&#34;isCompatible&#34;]
    if isCompatible is None:
        appClass = App
    elif not isCompatible:
        return None
    else:
        appBaseRep = f&#34;{appBase}/&#34; if appBase else &#34;&#34;
        appPath = f&#34;{appBaseRep}{appDir}&#34;

        appClass = findAppClass(appName, appPath) or App
    if extraMod:
        if kwargs.get(&#34;mod&#34;, None):
            kwargs[&#34;mod&#34;] = f&#34;{extraMod},{kwargs[&#39;mod&#39;]}&#34;
        else:
            kwargs[&#34;mod&#34;] = extraMod
    try:
        app = appClass(
            cfg,
            appName,
            appPath,
            commit,
            release,
            local,
            _browse,
            *args,
            version=version,
            silent=silent,
            **kwargs,
        )
    except Exception as e:
        if appClass is not App:
            console(
                f&#34;There was an error loading TF-app {appName} from {appPath}&#34;,
                error=True,
            )
            console(repr(e), error=True)
        traceback.print_exc()
        console(&#34;Text-Fabric is not loaded&#34;, error=True)
        return None
    return app</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.advanced.app.App"><code class="flex name class">
<span>class <span class="ident">App</span></span>
<span>(</span><span>cfg, appName, appPath, commit, release, local, _browse, hoist=False, version=None, checkout='', mod=None, locations=None, modules=None, volume=None, collection=None, api=None, setFile='', silent=False, **configOverrides)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up the advanced TF API.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>appName</code></strong> :&ensp;<code>string</code></dt>
<dd>
<p>The appname
can be as simple as the name of an existing TF-app.
The app should exist as a repository <code>app-</code><em>appName</em> under
<a href="https://github.com/annotation">github.com/annotation</a>.</p>
<p>If there is a <code>/</code> in the <em>appName argument</em>,
it is interpreted as a location on your system or on GitHub.</p>
<p>If it points to a directory with a <em>config.yaml</em> in it,
this config file will be read and interpreted as settings
for the advanced API.
If there is also a <em>app.py</em>, it will be imported as custom application code.
And if there is a <em>static/display.css</em> there, it will be used
for styling the display of corpus material.</p>
<p>If there is no <code>config.yaml</code> there, it will be assumed that there are
<code>.<a title="tf" href="../index.html">tf</a></code> data files in that location, and they will be loaded.
The advanced API will work with default settings,
based on the <code>.<a title="tf" href="../index.html">tf</a></code> data found.</p>
<div class="admonition hint">
<p class="admonition-title">appName:specifier, checkout=specifier</p>
<p>You may want to load downloadable features from the internet,
or you want to experiment with features you are developing.
The specifiers let you use a specific point in the
history of the app and data.</p>
<p><em>appName:specifier</em> is used for retrieving a TF-app (<em>code</em>).</p>
<p><em>checkout=specifier</em> is for retrieving the corpus itself
(<em>data</em>).</p>
<ul>
<li><code>''</code> (empty string or absent) (<strong>default</strong>):
use local data if it is present under <code>~/text-fabric-data</code>,
otherwise use the latest release if there are releases online,
otherwise, use the latest commit.</li>
<li><code>latest</code>: use the latest release.
If there are commits after the commit that has been tagged
with the latest release, these will <strong>not</strong> be used.</li>
<li><code>hot</code>: use the latest commit, even if it comes after the
latest commit of the latest release.</li>
<li><em>release tag</em>, e.g. <code>v1.3</code>: use exactly this release.
More precisely, this is the commit that has been tagged
with that release tag.</li>
<li><em>commit hash</em>, e.g. <code>2d0ca1f593805af0c13c4a62ed7405b94d870045</code>:
use exactly this commit.</li>
<li><code>local</code>: use local data from your <code>~/text-fabric-data</code> directory
if it is present, otherwise fail.</li>
<li><code>clone</code>: use local data from your <code>~/github</code> directory
if it is present, otherwise fail.</li>
</ul>
<p>For a demo, see
<a href="https://nbviewer.jupyter.org/github/annotation/tutorials/blob/master/banks/repo.ipynb">banks/repo</a></p>
</div>
</dd>
<dt><strong><code>hoist</code></strong> :&ensp;<code>dict</code>, optional <code>False</code></dt>
<dd>
<p>If you pass <code>globals()</code>, the core API elements are made directly available
as global names in your script or notebook:</p>
<ul>
<li><code><a title="tf.core.nodefeature.NodeFeature" href="../core/nodefeature.html#tf.core.nodefeature.NodeFeature">NodeFeature</a></code> as <code>F</code> instead of <code>A.api.F</code></li>
<li><code><a title="tf.core.locality.Locality" href="../core/locality.html#tf.core.locality.Locality">Locality</a></code> as <code>L</code> instead of <code>A.api.L</code></li>
<li><code><a title="tf.core.text.Text" href="../core/text.html#tf.core.text.Text">Text</a></code> as <code>T</code> instead of <code>A.api.T</code></li>
<li>and a few others (listed after executing the incantation)</li>
</ul>
</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>
<p>If you do not want to work with the default version of your main corpus,
you can specify a different version here.</p>
<div class="admonition caution">
<p class="admonition-title">Modules</p>
<p>If you also ask for extra data modules by means of the <code>mod</code> argument,
then the corresponding version of those modules will be chosen.
Every properly designed data module must refer to a specific
version of the main source!</p>
</div>
</dd>
<dt><strong><code>mod</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>
<p>A comma-separated list of modules in one of the forms</p>
<p>{org}/{repo}/{path}`</p>
<p>or</p>
<p>{org}/{repo}/{path}:specifier`</p>
<p>All features of all those modules will be loaded.
If they are not yet present, they will be downloaded from GitHub first.</p>
<p>For example, there is an easter egg module on GitHub,
and you can obtain it by</p>
<p>mod='etcbc/lingo/easter/tf'`</p>
<p>Here the <code>{org}</code> is <code>etcbc</code>, the <code>{repo}</code> is <code>lingo</code>,
and the <code>{path}</code> is <code>easter/tf</code> under which
version <code>c</code> of the feature <code>egg</code>
is available in TF format.</p>
<p>You can point to any such directory om the entire GitHub
if you know that it contains relevant features.</p>
<p>The specifier is as in <code>appName:specifier</code> and <code>checkData=specifier</code>.
It is used to get data from a different point in the history.</p>
<p>Your TF app might be configured to download specific modules.
See <code>moduleSpecs</code> in the app's <code>config.yaml</code> file.</p>
<div class="admonition caution">
<p class="admonition-title">Let TF manage your text-fabric-data directory</p>
<p>It is better not to fiddle with your <code>~/text-fabric-data</code> directory
manually. Let it be filled with auto-downloaded data.
You can then delete data sources and modules when needed,
and have them redownloaded at your wish,
without any hassle or data loss.</p>
</div>
</dd>
<dt><strong><code>locations</code></strong>, <strong><code>modules</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>
<p>If you want to add other search locations for TF features manually,
you can pass optional <code>locations</code> and <code>modules</code> parameters,
which will be passed to the <code><a title="tf.fabric.Fabric" href="../fabric.html#tf.fabric.Fabric">Fabric</a></code> call to the core of TF.</p>
<div class="admonition note">
<p class="admonition-title">More, not less</p>
<p>Using these arguments will load features on top of the
default selection of features.
You cannot use these arguments to prevent features from being loaded.</p>
</div>
<div class="admonition note">
<p class="admonition-title">appName with <code>/</code></p>
<p>If you use the <em>appName</em> argument with a <code>/</code> in it,
and it does not point to a TF app you have locally,
it will be interpreted as a <em>locations</em> search path to find <code>.<a title="tf" href="../index.html">tf</a></code> files.
It acts as the main <code>locations</code> argument,
and will be combined with the <code>modules</code> argument.</p>
</div>
</dd>
<dt><strong><code>collection</code></strong> :&ensp;<code>string</code></dt>
<dd>Triggers the loading of a single collection of
volumes of the work. The collection is a directory with <code>.<a title="tf" href="../index.html">tf</a></code> files,
located under the directory <code>_local</code> which is in the
same directory as the <code>.<a title="tf" href="../index.html">tf</a></code> files of the work.
See <code><a title="tf.about.volumes" href="../about/volumes.html">tf.about.volumes</a></code>.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>string</code></dt>
<dd>Triggers the loading of a single volume of
the work. The volume is a directory with <code>.<a title="tf" href="../index.html">tf</a></code> files,
located under the directory <code>_local</code> which is in the
same directory as the <code>.<a title="tf" href="../index.html">tf</a></code> files of the work.
See <code><a title="tf.about.volumes" href="../about/volumes.html">tf.about.volumes</a></code>.</dd>
<dt><strong><code>api</code></strong> :&ensp;<code>object</code>, optional<code>, </code>None``</dt>
<dd>
<p>So far, the TF app will construct an advanced API
with a more or less standard set of features
loaded, and make that API avaible to you, under <code>A.api</code>.</p>
<p>But you can also setup a core API yourself by using
<code><a title="tf.fabric.Fabric" href="../fabric.html#tf.fabric.Fabric">Fabric</a></code> with your choice of locations and modules:</p>
<p>from tf.fabric import Fabric<code>TF = Fabric(locations=..., modules=...)</code>
api = TF.load(features)`</p>
<p>Here you have full control over what you load and what not.</p>
<p>If you want the extra power of the TF app, you can wrap this <code>api</code>:</p>
<p>A = use('xxxx', api=api)`</p>
<div class="admonition hint">
<p class="admonition-title">Unloaded features</p>
<p>Some apps do not load all available features of the corpus by default.</p>
<p>This happens when a corpus contains quite a number of features
that most people never need.
Loading them cost time and takes a lot of RAM.</p>
<p>In the case where you need an available feature
that has not been loaded, you can load it by demanding</p>
<p>TF.load('feature1 feature2', add=True)`</p>
<p>provided you have used the <code>hoist=globals()</code> parameter earlier.
If not, you have to say</p>
<p>A.api.TF.load('feature1 feature2', add=True)`</p>
</div>
</dd>
<dt><strong><code>setFile</code></strong> :&ensp;<code>string</code>, optional<code>, </code>None``</dt>
<dd>The name of a file that contains condensed set information,
produces with <code><a title="tf.lib.writeSets" href="../lib.html#tf.lib.writeSets">writeSets()</a></code>.
These sets will be read and will become usable in TF queries.</dd>
<dt><strong><code>silent</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If <code>True</code>, nearly all output of this call will be suppressed,
including the links to the loaded
data, features, and the API methods.
Error messages will still come through.</dd>
<dt><strong><code>configOverrides</code></strong> :&ensp;<code>key value pairs</code></dt>
<dd>All values here will be used to override configuration settings
that are specified in the app's <code>config.yaml</code> file.
The list of those settings is spelled out in
<code><a title="tf.advanced.settings" href="settings.html">tf.advanced.settings</a></code>.</dd>
</dl>
<div class="admonition caution">
<p class="admonition-title">Volumes and collections</p>
<p>It is an error to load a volume as a collection and vice-versa</p>
<p>You get a warning if you pass both a volume and a collection.
The collection takes precedence, and the volume is ignored in that case.</p>
</div>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="tf.about.corpora" href="../about/corpora.html">tf.about.corpora</a></code></dt>
<dd>list of corpora with an official TF app</dd>
<dt><code><a title="tf.advanced.settings" href="settings.html">tf.advanced.settings</a></code></dt>
<dd>description of what can go in a <code>config.yaml</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/70483c9fc7920a9380e010f78f5483ebb84ed24f/tf/advanced/app.py#L39-L432" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class App:
    def __init__(
        self,
        cfg,
        appName,
        appPath,
        commit,
        release,
        local,
        _browse,
        hoist=False,
        version=None,
        checkout=&#34;&#34;,
        mod=None,
        locations=None,
        modules=None,
        volume=None,
        collection=None,
        api=None,
        setFile=&#34;&#34;,
        silent=False,
        **configOverrides,
    ):
        &#34;&#34;&#34;Set up the advanced TF API.

        Parameters
        ----------
        appName: string
            The appname  can be as simple as the name of an existing TF-app.
            The app should exist as a repository `app-`*appName* under
            [github.com/annotation](https://github.com/annotation).

            If there is a `/` in the *appName argument*,
            it is interpreted as a location on your system or on GitHub.

            If it points to a directory with a *config.yaml* in it,
            this config file will be read and interpreted as settings
            for the advanced API.
            If there is also a *app.py*, it will be imported as custom application code.
            And if there is a *static/display.css* there, it will be used
            for styling the display of corpus material.

            If there is no `config.yaml` there, it will be assumed that there are
            `.tf` data files in that location, and they will be loaded.
            The advanced API will work with default settings,
            based on the `.tf` data found.

            !!! hint &#34;appName:specifier, checkout=specifier&#34;
                You may want to load downloadable features from the internet,
                or you want to experiment with features you are developing.
                The specifiers let you use a specific point in the
                history of the app and data.

                *appName:specifier* is used for retrieving a TF-app (*code*).

                *checkout=specifier* is for retrieving the corpus itself  (*data*).

                *   `&#39;&#39;` (empty string or absent) (**default**):
                    use local data if it is present under `~/text-fabric-data`,
                    otherwise use the latest release if there are releases online,
                    otherwise, use the latest commit.
                *   `latest`: use the latest release.
                    If there are commits after the commit that has been tagged
                    with the latest release, these will **not** be used.
                *   `hot`: use the latest commit, even if it comes after the
                    latest commit of the latest release.
                *   *release tag*, e.g. `v1.3`: use exactly this release.
                    More precisely, this is the commit that has been tagged
                    with that release tag.
                *   *commit hash*, e.g. `2d0ca1f593805af0c13c4a62ed7405b94d870045`:
                    use exactly this commit.
                *   `local`: use local data from your `~/text-fabric-data` directory
                    if it is present, otherwise fail.
                *   `clone`: use local data from your `~/github` directory
                    if it is present, otherwise fail.

                For a demo, see
                [banks/repo](https://nbviewer.jupyter.org/github/annotation/tutorials/blob/master/banks/repo.ipynb)

        hoist: dict, optional `False`
            If you pass `globals()`, the core API elements are made directly available
            as global names in your script or notebook:

            * `tf.core.nodefeature.NodeFeature` as `F` instead of `A.api.F`
            * `tf.core.locality.Locality` as `L` instead of `A.api.L`
            * `tf.core.text.Text` as `T` instead of `A.api.T`
            * and a few others (listed after executing the incantation)

        version: string, optional `None`
            If you do not want to work with the default version of your main corpus,
            you can specify a different version here.

            !!! caution &#34;Modules&#34;
                If you also ask for extra data modules by means of the `mod` argument,
                then the corresponding version of those modules will be chosen.
                Every properly designed data module must refer to a specific
                version of the main source!

        mod: string, optional `None`
            A comma-separated list of modules in one of the forms

               {org}/{repo}/{path}`

            or

               {org}/{repo}/{path}:specifier`

            All features of all those modules will be loaded.
            If they are not yet present, they will be downloaded from GitHub first.

            For example, there is an easter egg module on GitHub,
            and you can obtain it by

               mod=&#39;etcbc/lingo/easter/tf&#39;`

            Here the `{org}` is `etcbc`, the `{repo}` is `lingo`,
            and the `{path}` is `easter/tf` under which
            version `c` of the feature `egg`
            is available in TF format.

            You can point to any such directory om the entire GitHub
            if you know that it contains relevant features.

            The specifier is as in `appName:specifier` and `checkData=specifier`.
            It is used to get data from a different point in the history.

            Your TF app might be configured to download specific modules.
            See `moduleSpecs` in the app&#39;s `config.yaml` file.

            !!! caution &#34;Let TF manage your text-fabric-data directory&#34;
                It is better not to fiddle with your `~/text-fabric-data` directory
                manually. Let it be filled with auto-downloaded data.
                You can then delete data sources and modules when needed,
                and have them redownloaded at your wish,
                without any hassle or data loss.

        locations, modules: string, optional `None`
            If you want to add other search locations for TF features manually,
            you can pass optional `locations` and `modules` parameters,
            which will be passed to the `tf.fabric.Fabric` call to the core of TF.

            !!! note &#34;More, not less&#34;
                Using these arguments will load features on top of the
                default selection of features.
                You cannot use these arguments to prevent features from being loaded.

            !!! note &#34;appName with `/`&#34;
                If you use the *appName* argument with a `/` in it,
                and it does not point to a TF app you have locally,
                it will be interpreted as a *locations* search path to find `.tf` files.
                It acts as the main `locations` argument,
                and will be combined with the `modules` argument.

        collection: string
            Triggers the loading of a single collection of
            volumes of the work. The collection is a directory with `.tf` files,
            located under the directory `_local` which is in the
            same directory as the `.tf` files of the work.
            See `tf.about.volumes`.

        volume: string
            Triggers the loading of a single volume of
            the work. The volume is a directory with `.tf` files,
            located under the directory `_local` which is in the
            same directory as the `.tf` files of the work.
            See `tf.about.volumes`.

        api: object, optional, `None`
            So far, the TF app will construct an advanced API
            with a more or less standard set of features
            loaded, and make that API avaible to you, under `A.api`.

            But you can also setup a core API yourself by using
            `tf.fabric.Fabric` with your choice of locations and modules:

               from tf.fabric import Fabric`
               TF = Fabric(locations=..., modules=...)`
               api = TF.load(features)`

            Here you have full control over what you load and what not.

            If you want the extra power of the TF app, you can wrap this `api`:

               A = use(&#39;xxxx&#39;, api=api)`

            !!! hint &#34;Unloaded features&#34;
                Some apps do not load all available features of the corpus by default.

                This happens when a corpus contains quite a number of features
                that most people never need.
                Loading them cost time and takes a lot of RAM.

                In the case where you need an available feature
                that has not been loaded, you can load it by demanding

                   TF.load(&#39;feature1 feature2&#39;, add=True)`

                provided you have used the `hoist=globals()` parameter earlier.
                If not, you have to say

                   A.api.TF.load(&#39;feature1 feature2&#39;, add=True)`

        setFile: string, optional, `None`
            The name of a file that contains condensed set information,
            produces with `tf.lib.writeSets`.
            These sets will be read and will become usable in TF queries.

        silent: boolean, optional `False`
            If `True`, nearly all output of this call will be suppressed,
            including the links to the loaded
            data, features, and the API methods.
            Error messages will still come through.

        configOverrides: key value pairs
            All values here will be used to override configuration settings
            that are specified in the app&#39;s `config.yaml` file.
            The list of those settings is spelled out in
            `tf.advanced.settings`.

        !!! caution &#34;Volumes and collections&#34;
            It is an error to load a volume as a collection and vice-versa

            You get a warning if you pass both a volume and a collection.
            The collection takes precedence, and the volume is ignored in that case.

        See Also
        --------
        tf.about.corpora: list of corpora with an official TF app
        tf.advanced.settings: description of what can go in a `config.yaml`
        &#34;&#34;&#34;

        self.context = None
        &#34;&#34;&#34;Result of interpreting all configuration options in `config.yaml`.

        See Also
        --------
        tf.advanced.settings.showContext
        &#34;&#34;&#34;

        mergeDict(cfg, configOverrides)

        for (key, value) in dict(
            isCompatible=cfg.get(&#34;isCompatible&#34;, None),
            appName=appName,
            api=api,
            version=version,
            volume=volume,
            collection=collection,
            silent=silent,
            _browse=_browse,
        ).items():
            setattr(self, key, value)

        setattr(self, &#34;dm&#34;, dm)
        setattr(self, &#34;dh&#34;, dh)

        setAppSpecs(self, cfg)
        aContext = self.context
        version = aContext.version

        setDir(self)

        if not self.api:
            self.sets = None
            if setFile:
                sets = readSets(setFile)
                if sets:
                    self.sets = sets
                    console(f&#39;Sets from {setFile}: {&#34;, &#34;.join(sets)}&#39;)
            specs = getModulesData(
                self, mod, locations, modules, version, checkout, silent
            )
            if specs:
                (locations, modules) = specs
                self.tempDir = f&#34;{self.repoLocation}/{TEMP_DIR}&#34;
                TF = Fabric(
                    locations=locations,
                    modules=modules,
                    volume=volume,
                    collection=collection,
                    silent=silent,
                )
                api = TF.load(&#34;&#34;, silent=True)
                if api:
                    self.api = api
                    excludedFeatures = aContext.excludedFeatures
                    allFeatures = TF.explore(silent=True, show=True)
                    loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
                    useFeatures = [
                        f for f in loadableFeatures if f not in excludedFeatures
                    ]
                    result = TF.load(useFeatures, add=True, silent=True)
                    if result is False:
                        self.api = None
            else:
                self.api = None

        if self.api:
            self.TF = self.api.TF
            for m in FROM_TF_METHODS:
                setattr(self, m, getattr(self.TF, m))
            self.getText = types.MethodType(getText, self)
            volumesApi(self)
            linksApi(self, silent)
            searchApi(self)
            sectionsApi(self)
            setAppSpecsApi(self, cfg)
            displayApi(self, silent)
            textApi(self)
            setattr(self, &#34;isLoaded&#34;, self.api.isLoaded)
            if hoist:
                # docs = self.api.makeAvailableIn(hoist)
                self.api.makeAvailableIn(hoist)
                if not silent:
                    dh(
                        &#34;&lt;div&gt;&lt;b&gt;Text-Fabric API:&lt;/b&gt; names &#34;
                        + outLink(
                            &#34;N F E L T S C TF&#34;,
                            APIREF,
                            title=&#34;doc&#34;,
                        )
                        + &#34; directly usable&lt;/div&gt;&lt;hr&gt;&#34;
                    )

            silentOff = self.silentOff
            silentOff()
        else:
            if not _browse:
                console(
                    f&#34;&#34;&#34;
There were problems with loading data.
The Text-Fabric API has not been loaded!
The app &#34;{appName}&#34; will not work!
&#34;&#34;&#34;,
                    error=True,
                )

    def reinit(self):
        &#34;&#34;&#34;TF-Apps may override this method.
        It is called by `reuse`. Hence it needs to be present.
        &#34;&#34;&#34;

        pass

    def reuse(self, hoist=False):
        &#34;&#34;&#34;Re-initialize the app.

        The app&#39;s settings are read again, the app&#39;s code is re-imported,
        the app&#39;s stylesheets are applied again.
        But the data is left untouched, and no time-consuming reloading of data
        takes place.

        Handy when you are developing a new app and want to experiment with it
        without the costly re-loading of the data in every cycle.

        Parameters
        ----------
        hoist: boolean, optional `False`
            Same as in `App`.

        !!! hint &#34;the effect of the config settings&#34;
            If you are developing a TF app and need to see the effects of
            the configuration settings in detail, you can conveniently
            call `reuse` and `tf.advanced.settings.showContext` in tandem.
        &#34;&#34;&#34;

        aContext = self.context
        appPath = aContext.appPath
        appName = aContext.appName
        local = aContext.local
        commit = aContext.commit
        release = aContext.release
        version = aContext.version
        api = self.api

        cfg = findAppConfig(appName, appPath, commit, release, local, version=version)
        findAppClass(appName, appPath)

        setAppSpecs(self, cfg, reset=True)

        if api:
            TF = self.TF
            TF._makeApi()
            api = TF.api
            self.api = api
            self.reinit()  # may be used by custom TF apps
            linksApi(self, True)
            searchApi(self)
            sectionsApi(self)
            setAppSpecsApi(self, cfg)
            displayApi(self, True)
            textApi(self)
            if hoist:
                api.makeAvailableIn(hoist)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tf.advanced.app.App.context"><code class="name">var <span class="ident">context</span></code></dt>
<dd>
<div class="desc"><p>Result of interpreting all configuration options in <code>config.yaml</code>.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="tf.advanced.settings.showContext" href="settings.html#tf.advanced.settings.showContext">showContext()</a></code></p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tf.advanced.app.App.reinit"><code class="name flex">
<span>def <span class="ident">reinit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TF-Apps may override this method.
It is called by <code>reuse</code>. Hence it needs to be present.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/70483c9fc7920a9380e010f78f5483ebb84ed24f/tf/advanced/app.py#L376-L381" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reinit(self):
    &#34;&#34;&#34;TF-Apps may override this method.
    It is called by `reuse`. Hence it needs to be present.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
</dd>
<dt id="tf.advanced.app.App.reuse"><code class="name flex">
<span>def <span class="ident">reuse</span></span>(<span>self, hoist=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-initialize the app.</p>
<p>The app's settings are read again, the app's code is re-imported,
the app's stylesheets are applied again.
But the data is left untouched, and no time-consuming reloading of data
takes place.</p>
<p>Handy when you are developing a new app and want to experiment with it
without the costly re-loading of the data in every cycle.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hoist</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Same as in <code><a title="tf.advanced.app.App" href="#tf.advanced.app.App">App</a></code>.</dd>
</dl>
<div class="admonition hint">
<p class="admonition-title">the effect of the config settings</p>
<p>If you are developing a TF app and need to see the effects of
the configuration settings in detail, you can conveniently
call <code>reuse</code> and <code><a title="tf.advanced.settings.showContext" href="settings.html#tf.advanced.settings.showContext">showContext()</a></code> in tandem.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/70483c9fc7920a9380e010f78f5483ebb84ed24f/tf/advanced/app.py#L383-L432" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reuse(self, hoist=False):
    &#34;&#34;&#34;Re-initialize the app.

    The app&#39;s settings are read again, the app&#39;s code is re-imported,
    the app&#39;s stylesheets are applied again.
    But the data is left untouched, and no time-consuming reloading of data
    takes place.

    Handy when you are developing a new app and want to experiment with it
    without the costly re-loading of the data in every cycle.

    Parameters
    ----------
    hoist: boolean, optional `False`
        Same as in `App`.

    !!! hint &#34;the effect of the config settings&#34;
        If you are developing a TF app and need to see the effects of
        the configuration settings in detail, you can conveniently
        call `reuse` and `tf.advanced.settings.showContext` in tandem.
    &#34;&#34;&#34;

    aContext = self.context
    appPath = aContext.appPath
    appName = aContext.appName
    local = aContext.local
    commit = aContext.commit
    release = aContext.release
    version = aContext.version
    api = self.api

    cfg = findAppConfig(appName, appPath, commit, release, local, version=version)
    findAppClass(appName, appPath)

    setAppSpecs(self, cfg, reset=True)

    if api:
        TF = self.TF
        TF._makeApi()
        api = TF.api
        self.api = api
        self.reinit()  # may be used by custom TF apps
        linksApi(self, True)
        searchApi(self)
        sectionsApi(self)
        setAppSpecsApi(self, cfg)
        displayApi(self, True)
        textApi(self)
        if hoist:
            api.makeAvailableIn(hoist)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.advanced" href="index.html">tf.advanced</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.advanced.app.findApp" href="#tf.advanced.app.findApp">findApp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.advanced.app.App" href="#tf.advanced.app.App">App</a></code></h4>
<ul class="">
<li><code><a title="tf.advanced.app.App.context" href="#tf.advanced.app.App.context">context</a></code></li>
<li><code><a title="tf.advanced.app.App.reinit" href="#tf.advanced.app.App.reinit">reinit</a></code></li>
<li><code><a title="tf.advanced.app.App.reuse" href="#tf.advanced.app.App.reuse">reuse</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="../../tf/images/DANS-logo.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>