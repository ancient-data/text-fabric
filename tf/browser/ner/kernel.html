<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.browser.ner.kernel API documentation</title>
<meta name="description" content="TF backend processing â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.browser.ner.kernel</code></h1>
</header>
<section id="section-intro">
<p>TF backend processing.</p>
<p>This module is for functions that extract data from the corpus
and put it in various dedicated data structures.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/kernel.py#L1-L315" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;TF backend processing.

This module is for functions that extract data from the corpus
and put it in various dedicated data structures.
&#34;&#34;&#34;

import collections
import re
import time

from ...core.generic import AttrDict
from ...core.files import mTime, fileExists, annotateDir

GENERIC = &#34;any&#34;
FEATURES = (&#34;txt&#34;, &#34;eid&#34;, &#34;kind&#34;)
KEYWORD_FEATURES = set(FEATURES[2])

NF = len(FEATURES)


WHITE_RE = re.compile(r&#34;&#34;&#34;\s{2,}&#34;&#34;&#34;, re.S)


def mergeEntities(web, newEntities):
    kernelApi = web.kernelApi
    app = kernelApi.app
    annoSet = web.annoSet
    annoDir = annotateDir(app, &#34;ner&#34;)

    dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

    for (fVals, matches) in newEntities:
        with open(dataFile, &#34;a&#34;) as fh:
            fh.write(&#34;\t&#34;.join(str(x) for x in (*fVals, *matches)) + &#34;\n&#34;)

    loadData(web)


def weedEntities(web, delEntities):
    kernelApi = web.kernelApi
    app = kernelApi.app
    annoSet = web.annoSet
    annoDir = annotateDir(app, &#34;ner&#34;)

    dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

    newEntities = []

    with open(dataFile) as fh:
        for line in fh:
            fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
            fVals = tuple(fields[0:NF])
            matches = tuple(int(f) for f in fields[NF:])
            data = (fVals, matches)
            if data in delEntities:
                continue
            newEntities.append(line)

    with open(dataFile, &#34;w&#34;) as fh:
        fh.write(&#34;&#34;.join(newEntities))

    loadData(web)


def ucFirst(x):
    return x[0].upper() + x[1:].lower()


def getText(F, slots):
    return WHITE_RE.sub(
        &#34; &#34;,
        &#34;&#34;.join(f&#34;{F.str.v(s)}{F.after.v(s)}&#34; for s in slots).strip(),
    )


def getEid(F, slots):
    return WHITE_RE.sub(
        &#34;&#34;,
        &#34;&#34;.join(ucFirst(x) for s in slots if (x := F.str.v(s).strip())).strip(),
    )


def getKind(F, slots):
    return GENERIC


featureDefault = {
    &#34;&#34;: getText,
    FEATURES[0]: getKind,
    FEATURES[1]: getEid,
}


def loadData(web):
    &#34;&#34;&#34;Loads data of the given annotation set from disk into memory.

    The data of an annotation set consists of:

    *   a dict of entities, keyed by nodes or line numbers;
        each entity specifies a kind and a list of slots that are part of the entity.

    If `annoSet` is empty, the annotation data is already in the TF data, and we do not
    do anything.

    After loading we process the data into a sligthly other shape:

    *   a dictionary keyed by pairs of kind and text and valued by the sequence numbers
        of the entities that have that kind and text
    *   a frequency list of the entity kinds
    *   a frequency list of the entity texts
    *   a dictionary, keyed by slot number, and valued by the following information:
        *   If the slot is outside any entity, it is not in the dictionary
        *   Otherwise, the value is a list of items, each item holds information
            about a specific entity wrt to that slot:
        *   If an entity starts or ends there, the item is a tuple
            (status, kind, number of occurrences)
        *   If the slot is inside an entity, the item is True

    We try to be lazy. We only load data from disk if the data is not already in memory,
    or the data on disk has been updated since the last load.

    Likewise, we only process the data if the data has been loaded again.

    Parameters
    ----------
    web: object
        The web application object, which has a handle to the TF app object.

    Returns
    -------
    void
        The resulting data is stored on the `web` object, under the key `toolData`
        and then under the key `ner` and then `sets` and then the name of the
        annotation set.

        For each set we produce the keys:

        *   `dateLoaded`: datetime when the data was last loaded from disk
        *   `dateProcessed`: datetime when the data was last processed
        *   `entities`: the list of entities as loaded from a tsv file

        We then process this into the following data structures:

        *   `entityKindFreq`: the frequency list of entity kinds
        *   `entityTextFreq`: the frequency list of entity texts
        *   `entityTextKind`: the set of kinds that the entities with a given text may
            have
        *   `entitySlotIndex`: the index of entities by slot
        *   `entityIndexKind`: the index of entities by tuple of slot positions; the values
            are the set of kinds of the entities at that position.

        *   `entityById`
        *   `entityId`
        *   `entityIdFreq`
        *   `entityIndexId`
    &#34;&#34;&#34;
    if not hasattr(web, &#34;toolData&#34;):
        setattr(web, &#34;toolData&#34;, AttrDict())

    toolData = web.toolData

    if &#34;ner&#34; not in toolData:
        toolData.ner = AttrDict()

    nerData = toolData.ner

    if &#34;sets&#34; not in nerData:
        nerData.sets = AttrDict()

    setsData = nerData.sets

    annoSet = web.annoSet

    if annoSet not in setsData:
        setsData[annoSet] = AttrDict()

    setData = setsData[annoSet]

    kernelApi = web.kernelApi
    app = kernelApi.app
    api = app.api
    F = api.F
    Fs = api.Fs
    L = api.L
    slotType = F.otype.slotType

    annoDir = annotateDir(app, &#34;ner&#34;)
    dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

    # load sentence nodes

    if &#34;sentences&#34; not in setData:
        setData.sentences = F.otype.s(&#34;sentence&#34;)

    # loading stage (only for real annosets)

    changed = False

    if annoSet:
        if (
            &#34;entities&#34; not in setData
            or &#34;dateLoaded&#34; not in setData
            or (len(setData.entities) &gt; 0 and not fileExists(dataFile))
            or (fileExists(dataFile) and setData.dateLoaded &lt; mTime(dataFile))
        ):
            web.console(f&#34;LOAD &#39;{annoSet}&#39; START&#34;)
            changed = True
            entities = {}

            if fileExists(dataFile):
                with open(dataFile) as df:
                    for (e, line) in enumerate(df):
                        fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
                        entities[e] = (
                            tuple(fields[0:NF]),
                            tuple(int(f) for f in fields[NF:]),
                        )

            setData.entities = entities
            setData.dateLoaded = time.time()
            web.console(f&#34;LOAD &#39;{annoSet}&#39; DONE&#34;)
        else:
            web.console(f&#34;LOAD &#39;{annoSet}&#39; REUSED&#34;)
    else:
        if &#34;entities&#34; not in setData:
            entities = {}
            hasFeature = {
                feat: api.isLoaded(&#34;entid&#34;)[&#34;entid&#34;] is not None for feat in FEATURES
            }

            for e in F.otype.s(&#34;ent&#34;):
                slots = L.d(e, otype=slotType)
                entities[e] = (
                    tuple(
                        Fs(feat).v(e)
                        if hasFeature[feat]
                        else featureDefault[feat](F, slots)
                        for feat in FEATURES
                    ),
                    tuple(slots),
                )

            setData.entities = entities

    # processing stage (a bit different for annoset == &#34;&#34;)

    dateLoaded = setData.dateLoaded
    dateProcessed = setData.dateProcessed

    if (
        changed
        or &#34;dateProcessed&#34; not in setData
        or &#34;entityVal&#34; not in setData
        or &#34;entityTextVal&#34; not in setData
        or &#34;entityBy&#34; not in setData
        or &#34;entityFreq&#34; not in setData
        or &#34;entityIndex&#34; not in setData
        or &#34;entitySlotIndex&#34; not in setData
        or dateLoaded is not None
        and dateProcessed &lt; dateLoaded
    ):
        web.console(f&#34;PROCESS &#39;{annoSet}&#39; START&#34;)

        entityItems = setData.entities.items()

        entityVal = {feat: {} for feat in FEATURES}
        entityTextVal = {feat: collections.defaultdict(set) for feat in FEATURES[1:]}
        entityBy = {}
        entityFreq = {feat: collections.Counter() for feat in FEATURES}
        entityIndex = {feat: {} for feat in FEATURES}
        entitySlotIndex = {}

        for (e, (fVals, slots)) in entityItems:
            txt = fVals[0]
            ident = fVals[1:]

            for (feat, val) in zip(FEATURES, fVals):
                entityVal[feat][e] = val
                entityFreq[feat][val] += 1
                entityIndex[feat].setdefault(slots, set()).add(val)
                entityTextVal[feat][txt].add(val)

            entityBy.setdefault(ident, []).append(e)

            firstSlot = slots[0]
            lastSlot = slots[-1]

            for slot in slots:
                isFirst = slot == firstSlot
                isLast = slot == lastSlot
                if isFirst or isLast:
                    if isFirst:
                        entitySlotIndex.setdefault(slot, []).append(
                            [True, firstSlot - lastSlot - 1, ident]
                        )
                    if isLast:
                        entitySlotIndex.setdefault(slot, []).append(
                            [False, lastSlot - firstSlot + 1, ident]
                        )
                else:
                    entitySlotIndex.setdefault(slot, []).append(None)

        setData.entityVal = entityVal
        setData.entityTextVal = entityTextVal
        setData.entityBy = entityBy
        setData.entityFreq = sorted(entityFreq.items())
        setData.entityIndex = entityIndex
        setData.entitySlotIndex = entitySlotIndex

        setData.dateProcessed = time.time()

        web.console(f&#34;PROCESS &#39;{annoSet}&#39; DONE&#34;)

    else:
        web.console(f&#34;PROCESS &#39;{annoSet}&#39; REUSED&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.browser.ner.kernel.getEid"><code class="name flex">
<span>def <span class="ident">getEid</span></span>(<span>F, slots)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/kernel.py#L76-L80" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getEid(F, slots):
    return WHITE_RE.sub(
        &#34;&#34;,
        &#34;&#34;.join(ucFirst(x) for s in slots if (x := F.str.v(s).strip())).strip(),
    )</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.kernel.getKind"><code class="name flex">
<span>def <span class="ident">getKind</span></span>(<span>F, slots)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/kernel.py#L83-L84" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getKind(F, slots):
    return GENERIC</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.kernel.getText"><code class="name flex">
<span>def <span class="ident">getText</span></span>(<span>F, slots)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/kernel.py#L69-L73" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getText(F, slots):
    return WHITE_RE.sub(
        &#34; &#34;,
        &#34;&#34;.join(f&#34;{F.str.v(s)}{F.after.v(s)}&#34; for s in slots).strip(),
    )</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.kernel.loadData"><code class="name flex">
<span>def <span class="ident">loadData</span></span>(<span>web)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads data of the given annotation set from disk into memory.</p>
<p>The data of an annotation set consists of:</p>
<ul>
<li>a dict of entities, keyed by nodes or line numbers;
each entity specifies a kind and a list of slots that are part of the entity.</li>
</ul>
<p>If <code>annoSet</code> is empty, the annotation data is already in the TF data, and we do not
do anything.</p>
<p>After loading we process the data into a sligthly other shape:</p>
<ul>
<li>a dictionary keyed by pairs of kind and text and valued by the sequence numbers
of the entities that have that kind and text</li>
<li>a frequency list of the entity kinds</li>
<li>a frequency list of the entity texts</li>
<li>a dictionary, keyed by slot number, and valued by the following information:<ul>
<li>If the slot is outside any entity, it is not in the dictionary</li>
<li>Otherwise, the value is a list of items, each item holds information
about a specific entity wrt to that slot:</li>
<li>If an entity starts or ends there, the item is a tuple
(status, kind, number of occurrences)</li>
<li>If the slot is inside an entity, the item is True</li>
</ul>
</li>
</ul>
<p>We try to be lazy. We only load data from disk if the data is not already in memory,
or the data on disk has been updated since the last load.</p>
<p>Likewise, we only process the data if the data has been loaded again.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>web</code></strong> :&ensp;<code>object</code></dt>
<dd>The web application object, which has a handle to the TF app object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>
<p>The resulting data is stored on the <code>web</code> object, under the key <code>toolData</code>
and then under the key <code>ner</code> and then <code>sets</code> and then the name of the
annotation set.</p>
<p>For each set we produce the keys:</p>
<ul>
<li><code>dateLoaded</code>: datetime when the data was last loaded from disk</li>
<li><code>dateProcessed</code>: datetime when the data was last processed</li>
<li><code>entities</code>: the list of entities as loaded from a tsv file</li>
</ul>
<p>We then process this into the following data structures:</p>
<ul>
<li><code>entityKindFreq</code>: the frequency list of entity kinds</li>
<li><code>entityTextFreq</code>: the frequency list of entity texts</li>
<li><code>entityTextKind</code>: the set of kinds that the entities with a given text may
have</li>
<li><code>entitySlotIndex</code>: the index of entities by slot</li>
<li>
<p><code>entityIndexKind</code>: the index of entities by tuple of slot positions; the values
are the set of kinds of the entities at that position.</p>
</li>
<li>
<p><code>entityById</code></p>
</li>
<li><code>entityId</code></li>
<li><code>entityIdFreq</code></li>
<li><code>entityIndexId</code></li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/kernel.py#L94-L315" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loadData(web):
    &#34;&#34;&#34;Loads data of the given annotation set from disk into memory.

    The data of an annotation set consists of:

    *   a dict of entities, keyed by nodes or line numbers;
        each entity specifies a kind and a list of slots that are part of the entity.

    If `annoSet` is empty, the annotation data is already in the TF data, and we do not
    do anything.

    After loading we process the data into a sligthly other shape:

    *   a dictionary keyed by pairs of kind and text and valued by the sequence numbers
        of the entities that have that kind and text
    *   a frequency list of the entity kinds
    *   a frequency list of the entity texts
    *   a dictionary, keyed by slot number, and valued by the following information:
        *   If the slot is outside any entity, it is not in the dictionary
        *   Otherwise, the value is a list of items, each item holds information
            about a specific entity wrt to that slot:
        *   If an entity starts or ends there, the item is a tuple
            (status, kind, number of occurrences)
        *   If the slot is inside an entity, the item is True

    We try to be lazy. We only load data from disk if the data is not already in memory,
    or the data on disk has been updated since the last load.

    Likewise, we only process the data if the data has been loaded again.

    Parameters
    ----------
    web: object
        The web application object, which has a handle to the TF app object.

    Returns
    -------
    void
        The resulting data is stored on the `web` object, under the key `toolData`
        and then under the key `ner` and then `sets` and then the name of the
        annotation set.

        For each set we produce the keys:

        *   `dateLoaded`: datetime when the data was last loaded from disk
        *   `dateProcessed`: datetime when the data was last processed
        *   `entities`: the list of entities as loaded from a tsv file

        We then process this into the following data structures:

        *   `entityKindFreq`: the frequency list of entity kinds
        *   `entityTextFreq`: the frequency list of entity texts
        *   `entityTextKind`: the set of kinds that the entities with a given text may
            have
        *   `entitySlotIndex`: the index of entities by slot
        *   `entityIndexKind`: the index of entities by tuple of slot positions; the values
            are the set of kinds of the entities at that position.

        *   `entityById`
        *   `entityId`
        *   `entityIdFreq`
        *   `entityIndexId`
    &#34;&#34;&#34;
    if not hasattr(web, &#34;toolData&#34;):
        setattr(web, &#34;toolData&#34;, AttrDict())

    toolData = web.toolData

    if &#34;ner&#34; not in toolData:
        toolData.ner = AttrDict()

    nerData = toolData.ner

    if &#34;sets&#34; not in nerData:
        nerData.sets = AttrDict()

    setsData = nerData.sets

    annoSet = web.annoSet

    if annoSet not in setsData:
        setsData[annoSet] = AttrDict()

    setData = setsData[annoSet]

    kernelApi = web.kernelApi
    app = kernelApi.app
    api = app.api
    F = api.F
    Fs = api.Fs
    L = api.L
    slotType = F.otype.slotType

    annoDir = annotateDir(app, &#34;ner&#34;)
    dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

    # load sentence nodes

    if &#34;sentences&#34; not in setData:
        setData.sentences = F.otype.s(&#34;sentence&#34;)

    # loading stage (only for real annosets)

    changed = False

    if annoSet:
        if (
            &#34;entities&#34; not in setData
            or &#34;dateLoaded&#34; not in setData
            or (len(setData.entities) &gt; 0 and not fileExists(dataFile))
            or (fileExists(dataFile) and setData.dateLoaded &lt; mTime(dataFile))
        ):
            web.console(f&#34;LOAD &#39;{annoSet}&#39; START&#34;)
            changed = True
            entities = {}

            if fileExists(dataFile):
                with open(dataFile) as df:
                    for (e, line) in enumerate(df):
                        fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
                        entities[e] = (
                            tuple(fields[0:NF]),
                            tuple(int(f) for f in fields[NF:]),
                        )

            setData.entities = entities
            setData.dateLoaded = time.time()
            web.console(f&#34;LOAD &#39;{annoSet}&#39; DONE&#34;)
        else:
            web.console(f&#34;LOAD &#39;{annoSet}&#39; REUSED&#34;)
    else:
        if &#34;entities&#34; not in setData:
            entities = {}
            hasFeature = {
                feat: api.isLoaded(&#34;entid&#34;)[&#34;entid&#34;] is not None for feat in FEATURES
            }

            for e in F.otype.s(&#34;ent&#34;):
                slots = L.d(e, otype=slotType)
                entities[e] = (
                    tuple(
                        Fs(feat).v(e)
                        if hasFeature[feat]
                        else featureDefault[feat](F, slots)
                        for feat in FEATURES
                    ),
                    tuple(slots),
                )

            setData.entities = entities

    # processing stage (a bit different for annoset == &#34;&#34;)

    dateLoaded = setData.dateLoaded
    dateProcessed = setData.dateProcessed

    if (
        changed
        or &#34;dateProcessed&#34; not in setData
        or &#34;entityVal&#34; not in setData
        or &#34;entityTextVal&#34; not in setData
        or &#34;entityBy&#34; not in setData
        or &#34;entityFreq&#34; not in setData
        or &#34;entityIndex&#34; not in setData
        or &#34;entitySlotIndex&#34; not in setData
        or dateLoaded is not None
        and dateProcessed &lt; dateLoaded
    ):
        web.console(f&#34;PROCESS &#39;{annoSet}&#39; START&#34;)

        entityItems = setData.entities.items()

        entityVal = {feat: {} for feat in FEATURES}
        entityTextVal = {feat: collections.defaultdict(set) for feat in FEATURES[1:]}
        entityBy = {}
        entityFreq = {feat: collections.Counter() for feat in FEATURES}
        entityIndex = {feat: {} for feat in FEATURES}
        entitySlotIndex = {}

        for (e, (fVals, slots)) in entityItems:
            txt = fVals[0]
            ident = fVals[1:]

            for (feat, val) in zip(FEATURES, fVals):
                entityVal[feat][e] = val
                entityFreq[feat][val] += 1
                entityIndex[feat].setdefault(slots, set()).add(val)
                entityTextVal[feat][txt].add(val)

            entityBy.setdefault(ident, []).append(e)

            firstSlot = slots[0]
            lastSlot = slots[-1]

            for slot in slots:
                isFirst = slot == firstSlot
                isLast = slot == lastSlot
                if isFirst or isLast:
                    if isFirst:
                        entitySlotIndex.setdefault(slot, []).append(
                            [True, firstSlot - lastSlot - 1, ident]
                        )
                    if isLast:
                        entitySlotIndex.setdefault(slot, []).append(
                            [False, lastSlot - firstSlot + 1, ident]
                        )
                else:
                    entitySlotIndex.setdefault(slot, []).append(None)

        setData.entityVal = entityVal
        setData.entityTextVal = entityTextVal
        setData.entityBy = entityBy
        setData.entityFreq = sorted(entityFreq.items())
        setData.entityIndex = entityIndex
        setData.entitySlotIndex = entitySlotIndex

        setData.dateProcessed = time.time()

        web.console(f&#34;PROCESS &#39;{annoSet}&#39; DONE&#34;)

    else:
        web.console(f&#34;PROCESS &#39;{annoSet}&#39; REUSED&#34;)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.kernel.mergeEntities"><code class="name flex">
<span>def <span class="ident">mergeEntities</span></span>(<span>web, newEntities)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/kernel.py#L24-L36" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mergeEntities(web, newEntities):
    kernelApi = web.kernelApi
    app = kernelApi.app
    annoSet = web.annoSet
    annoDir = annotateDir(app, &#34;ner&#34;)

    dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

    for (fVals, matches) in newEntities:
        with open(dataFile, &#34;a&#34;) as fh:
            fh.write(&#34;\t&#34;.join(str(x) for x in (*fVals, *matches)) + &#34;\n&#34;)

    loadData(web)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.kernel.ucFirst"><code class="name flex">
<span>def <span class="ident">ucFirst</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/kernel.py#L65-L66" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ucFirst(x):
    return x[0].upper() + x[1:].lower()</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.kernel.weedEntities"><code class="name flex">
<span>def <span class="ident">weedEntities</span></span>(<span>web, delEntities)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/kernel.py#L39-L62" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def weedEntities(web, delEntities):
    kernelApi = web.kernelApi
    app = kernelApi.app
    annoSet = web.annoSet
    annoDir = annotateDir(app, &#34;ner&#34;)

    dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

    newEntities = []

    with open(dataFile) as fh:
        for line in fh:
            fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
            fVals = tuple(fields[0:NF])
            matches = tuple(int(f) for f in fields[NF:])
            data = (fVals, matches)
            if data in delEntities:
                continue
            newEntities.append(line)

    with open(dataFile, &#34;w&#34;) as fh:
        fh.write(&#34;&#34;.join(newEntities))

    loadData(web)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.browser.ner" href="index.html">tf.browser.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tf.browser.ner.kernel.getEid" href="#tf.browser.ner.kernel.getEid">getEid</a></code></li>
<li><code><a title="tf.browser.ner.kernel.getKind" href="#tf.browser.ner.kernel.getKind">getKind</a></code></li>
<li><code><a title="tf.browser.ner.kernel.getText" href="#tf.browser.ner.kernel.getText">getText</a></code></li>
<li><code><a title="tf.browser.ner.kernel.loadData" href="#tf.browser.ner.kernel.loadData">loadData</a></code></li>
<li><code><a title="tf.browser.ner.kernel.mergeEntities" href="#tf.browser.ner.kernel.mergeEntities">mergeEntities</a></code></li>
<li><code><a title="tf.browser.ner.kernel.ucFirst" href="#tf.browser.ner.kernel.ucFirst">ucFirst</a></code></li>
<li><code><a title="tf.browser.ner.kernel.weedEntities" href="#tf.browser.ner.kernel.weedEntities">weedEntities</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>