<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.browser.ner.annotate API documentation</title>
<meta name="description" content="Central Annotation object â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-GjqubOlYA6/wOZV7F31o2t4ogk4JGDGFa6XmL+BfAG0=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-qDPJ4nH38AgHyK3U6cvI6DBifA+7hPBo8mVoH6pyN9c=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.browser.ner.annotate</code></h1>
</header>
<section id="section-intro">
<p>Central Annotation object.</p>
<p>As a preparation, read <code><a title="tf.about.annotate" href="../../about/annotate.html">tf.about.annotate</a></code> first, since it explains the concepts, and
guides you to set up the configuration for your corpus.</p>
<p>The main task of this module is to find occurrences of annotations
on the basis of criteria.</p>
<p>But this is just the tip of the iceberg, since this module inherits
from a number of other modules that inherit form yet other modules:</p>
<ul>
<li><code><a title="tf.browser.ner.show" href="show.html">tf.browser.ner.show</a></code>: generate HTML for annotated buckets of the corpus;</li>
<li><code><a title="tf.browser.ner.sets" href="sets.html">tf.browser.ner.sets</a></code>: manage annotation sets;</li>
<li><code><a title="tf.browser.ner.data" href="data.html">tf.browser.ner.data</a></code>: manage annotation data: loading, adding/deleting
annotations;</li>
<li><code><a title="tf.browser.ner.settings" href="settings.html">tf.browser.ner.settings</a></code>: manage the specifics of a TF corpus and have
access to its data.</li>
</ul>
<p>It also uses</p>
<ul>
<li><code><a title="tf.browser.ner.match" href="match.html">tf.browser.ner.match</a></code>: to filter individual buckets on the basis of
criteria.</li>
</ul>
<p>Hence, <code>Annotation</code> is the central class of this tools, whose methods are relevant
for:</p>
<ul>
<li><code><a title="tf.browser.ner.power" href="power.html">tf.browser.ner.power</a></code>: the API for users to manipulate annotations in their
own programs, especially in a Jupyter notebook.</li>
<li><code><a title="tf.browser.ner.web" href="web.html">tf.browser.ner.web</a></code>: Flask app that routes urls to controller functions.</li>
</ul>
<p><code>web</code> makes use of the following modules that are not needed by <code>power</code>:</p>
<ul>
<li><code><a title="tf.browser.ner.serve" href="serve.html">tf.browser.ner.serve</a></code>: define the controllers of the web app</li>
</ul>
<p>Again, this is a top of an iceberg, since it inherits from:</p>
<ul>
<li><code><a title="tf.browser.ner.request" href="request.html">tf.browser.ner.request</a></code>: manage the data of a request;</li>
<li><code><a title="tf.browser.ner.fragments" href="fragments.html">tf.browser.ner.fragments</a></code>: generate HTML for widgets on the page;</li>
</ul>
<p><code>request</code> also uses <code>form</code> to retrieve form values into typed and structured values.</p>
<p>Both <code>web</code> and <code>power</code> make use of the following modules in as far as they are not
already mentioned under <code>annotate</code> and its parent classes:</p>
<ul>
<li><code><a title="tf.browser.ner.helpers" href="helpers.html">tf.browser.ner.helpers</a></code>: a variety of context-free data jugglers;</li>
<li><code><a title="tf.browser.ner.html" href="html.html">tf.browser.ner.html</a></code>: a generic library to generate HTML using Pythonic
syntax.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Class hierarchy</p>
<p>The classes <code>`Settings</code>, <code>Corpus</code>, <code>Data</code>, <code>Sets</code>, <code>Show</code>, <code><a title="tf.browser.ner.annotate.Annotate" href="#tf.browser.ner.annotate.Annotate">Annotate</a></code>,
<code>PowerNER</code> form one hierarchy.
So an object of class <code>PowerNER</code> has access to all methods of these classes.</p>
<p>The classes <code>Serve</code>, <code>Request</code>, <code>Fragments</code>, <code>From</code> form a separate hierarchy.
It will create an <code><a title="tf.browser.ner.annotate.Annotate" href="#tf.browser.ner.annotate.Annotate">Annotate</a></code> instance which will be stored in a <code>Serve</code> instance.</p>
</div>
<p>Here is an overview how the modules hang together.</p>
<p>A <code>|</code> denotes inheritance, parent classes above child classes.</p>
<p>A <code>&lt;-&lt;</code> arrow denotes dependency by importing code.</p>
<pre><code>Browser                           |   Api-hierarchy
---------------------------------------------------------
                                  |   PowerNER
                                  |     |
web &lt;-----&lt; Serve &lt;-----------------&lt; Annotate  &lt;-&lt; match
            |   |                 |     |   |
       Request Fragments &lt;-&lt; html |   Sets Show &lt;-&lt; html
          |                       |     |
        Form                      |   Data
                                  |     |
                                  |   Corpus
                                  |     |
                                  |   Settings
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/7fdf25fed954698d7bcf1c0099489ed4c8456fe6/tf/browser/ner/annotate.py#L1-L399" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Central Annotation object.

As a preparation, read `tf.about.annotate` first, since it explains the concepts, and
guides you to set up the configuration for your corpus.

The main task of this module is to find occurrences of annotations
on the basis of criteria.

But this is just the tip of the iceberg, since this module inherits
from a number of other modules that inherit form yet other modules:

*   `tf.browser.ner.show`: generate HTML for annotated buckets of the corpus;
*   `tf.browser.ner.sets`: manage annotation sets;
*   `tf.browser.ner.data`: manage annotation data: loading, adding/deleting
    annotations;
*   `tf.browser.ner.settings`: manage the specifics of a TF corpus and have
    access to its data.

It also uses

*   `tf.browser.ner.match`: to filter individual buckets on the basis of
    criteria.

Hence, `Annotation` is the central class of this tools, whose methods are relevant
for:

*   `tf.browser.ner.power`: the API for users to manipulate annotations in their
    own programs, especially in a Jupyter notebook.
*   `tf.browser.ner.web`: Flask app that routes urls to controller functions.

`web` makes use of the following modules that are not needed by `power`:

*   `tf.browser.ner.serve`: define the controllers of the web app

Again, this is a top of an iceberg, since it inherits from:

*   `tf.browser.ner.request`: manage the data of a request;
*   `tf.browser.ner.fragments`: generate HTML for widgets on the page;

`request` also uses `form` to retrieve form values into typed and structured values.

Both `web` and `power` make use of the following modules in as far as they are not
already mentioned under `annotate` and its parent classes:

*   `tf.browser.ner.helpers`: a variety of context-free data jugglers;
*   `tf.browser.ner.html`: a generic library to generate HTML using Pythonic
    syntax.

!!! note &#34;Class hierarchy&#34;
    The classes ``Settings`, `Corpus`, `Data`, `Sets`, `Show`, `Annotate`,
    `PowerNER` form one hierarchy.
    So an object of class `PowerNER` has access to all methods of these classes.

    The classes `Serve`, `Request`, `Fragments`, `From` form a separate hierarchy.
    It will create an `Annotate` instance which will be stored in a `Serve` instance.

Here is an overview how the modules hang together.

A `|` denotes inheritance, parent classes above child classes.

A `&lt;-&lt;` arrow denotes dependency by importing code.

```
Browser                           |   Api-hierarchy
---------------------------------------------------------
                                  |   PowerNER
                                  |     |
web &lt;-----&lt; Serve &lt;-----------------&lt; Annotate  &lt;-&lt; match
            |   |                 |     |   |
       Request Fragments &lt;-&lt; html |   Sets Show &lt;-&lt; html
          |                       |     |
        Form                      |   Data
                                  |     |
                                  |   Corpus
                                  |     |
                                  |   Settings
```
&#34;&#34;&#34;

import collections


from .helpers import findCompile
from .sets import Sets
from .show import Show
from .match import entityMatch, occMatch


class Annotate(Sets, Show):
    def __init__(self, app, data=None, browse=False):
        &#34;&#34;&#34;Entity annotation.

        Basic methods to handle the various aspects of entity annotation.
        These methods can be used by code that runs in the Text-Fabric browser
        and by code that runs in a Jupyter notebook.

        This class handles data, it does not contain code to generate HTML.
        But it has a parent class, `Show`, that can generate HTML.

        This class works with a fixed annotation set.
        But it has a parent class, `Sets` that has method to manipulate such sets
        and switch between them.

        We consider the corpus as a list of buckets (typically level-3 sectional
        units; in TEI-derived corpora called `chunk`s, being generalizations of
        `p` (paragraph) elements). What type exactly the buckets are is configured
        in the `ner/config.yaml` file.

        Parameters
        ----------
        app: object
            The object that corresponds to a loaded TF app for a corpus.
        data: object, optional None
            Entity data to start with. If this class is initialized by the browser,
            the browser hands over the in-memory data that the tool needs.
            That way, it can maintain access to the same data between requests.
            If None, no data is handed over, and a fresh data store will be
            created by an ancestor class (Data)
        browse: boolean, optional False
            If True, the object is informed that it is run by the Text-Fabric
            browser. This will influence how results are reported back.
        &#34;&#34;&#34;
        self.app = app
        super().__init__(data=data)

        self.browse = browse

        if not browse:
            self.loadData()

    def findOccs(self, qTokenSet=set()):
        &#34;&#34;&#34;Finds the occurrences of multiple sequences of tokens.

        This is meant to efficiently list all occurrences of many token
        sequences in the corpus.

        Parameters
        ----------
        qTokenSet: set, optional set()
            A set of sequences of tokens. Each sequence in the set will be used as a
            search pattern in the whole corpus, and it occurrences are collected.

        Returns
        -------
        dict
            Keyed by each member of parameter `qTokenSet` the values are
            the occurrences of that member in the corpus.
            A single occurrence is represented as a tuple of slots.

        &#34;&#34;&#34;
        setData = self.getSetData()
        getTokens = self.getTokens

        buckets = setData.buckets or ()

        results = {}

        for b in buckets:
            occMatch(getTokens, b, qTokenSet, results)

        return results

    def filterContent(
        self,
        buckets=None,
        node=None,
        bFind=None,
        bFindC=None,
        bFindRe=None,
        anyEnt=None,
        eVals=None,
        qTokens=None,
        valSelect=None,
        freeState=None,
        showStats=None,
    ):
        &#34;&#34;&#34;Filter the buckets according to a variety of criteria.

        Either the buckets of the whole corpus are filtered, or a given subset
        of buckets, or a subset of buckets, namely those contained in a
        particular node, see parameters `node`, and `buckets`.

        **Bucket filtering**

        The parameters `bFind`, `bFindC`, `bFindRe`  specify a regular expression
        search on the texts of the buckets.

        The positions of the found occurrences is included in the result.

        The parameter `anyEnt` is a filter on the presence or absence of entities in
        buckets in general.

        **Entity filtering**

        The parameter `eVals` holds the values of a specific entity to look for.

        **Occurrence filtering**

        The parameter `qTokens` is a sequence of tokens to look for.
        The occurrences that are found, can be filtered further by `valSelect`
        and `freeState`.

        In entity filtering and occurrence filtering, the matching occurrences
        are included in the result.

        Parameters
        ----------
        buckets: set of integer, optional None
            The set of buckets to filter, instead of the whole corpus.
            Works also if the parameter `node` is specified, which also restricts
            the buckets to filter. If both are specified, their effect will be
            combined.
        node: integer, optional None
            Gets the context of the node, typically the intermediate-level section
            in which the node occurs. Then restricts the filtering to the buckets
            contained in the context, instead of the whole corpus.
        bFind: string, optional None
            A search pattern that filters the buckets, before applying the search
            for a token sequence.
        bFindC: string, optional None
            Whether the search is case sensitive or not.
        bFindRe: object, optional None
            A compiled regular expression.
            This function searches on `bFindRe`, but if it is None, it compiles
            `bFind` as regular expression and searches on that. If `bFind` itself
            is not None, of course.
        anyEnt: boolean, optional None
            If True, it wants all buckets that contain at least one already
            marked entity; if False, it wants all buckets that do not contain any
            already marked entity.
        eVals: tuple, optional None
            A sequence of values corresponding with the entity features `eid`
            and `kind`. If given, the function wants buckets that contain at least
            an entity with those properties.
        qTokens: tuple, optional None
            A sequence of tokens whose occurrences in the corpus will be looked up.
        valSelect: dict, optional None
            If present, the keys are the entity features (`eid` and `kind`),
            and the values are iterables of values that are allowed.

            The feature values to filter on.
            The results of searching for `eVals` or `qTokens` are filtered further.
            If a result is also an instance of an already marked entity,
            the properties of that entity will be compared feature by feature with
            the allowed values that `valSelect` specifies for that feature.
        freeState: boolean, optional None
            If True, found occurrences may not intersect with already marked up
            features.
            If False, found occurrences must intersect with already marked up features.
        showStats: boolean, optional None
            Whether to show statistics of the find.
            If None, it only shows gross totals, if False, it shows nothing,
            if True, it shows totals by feature.

        Returns
        -------
        list of tuples
            For each bucket that passes the filter, a tuple with the following
            members is added to the list:

            *   the TF node of the bucket;
            *   tokens: the tokens of the bucket, each token is a tuple consisting
                of the TF-slot of the token and its string value;
            *   matches: the match positions of the found occurrences or entity;
            *   positions: the token positions of where the text of the bucket
                starts matching the `bFindRe`;

            If `browse` is True, also some stats are passed next to the list
            of results.
        &#34;&#34;&#34;
        settings = self.settings
        bucketType = settings.bucketType
        features = settings.features

        getTextR = self.getTextR
        getTokens = self.getTokens

        browse = self.browse
        setData = self.getSetData()
        entityIndex = setData.entityIndex
        entityVal = setData.entityVal
        entitySlotVal = setData.entitySlotVal
        entitySlotAll = setData.entitySlotAll
        entitySlotIndex = setData.entitySlotIndex

        bucketUniverse = (
            setData.buckets
            if buckets is None
            else tuple(sorted(self.checkBuckets(buckets)))
        )
        buckets = (
            bucketUniverse
            if node is None
            else tuple(sorted(set(bucketUniverse) &amp; set(self.getContext(node))))
        )

        nFind = 0
        nEnt = {feat: collections.Counter() for feat in (&#34;&#34;,) + features}
        nVisible = {feat: collections.Counter() for feat in (&#34;&#34;,) + features}

        if bFindRe is None:
            if bFind is not None:
                (bFind, bFindRe, errorMsg) = findCompile(bFind, bFindC)
                if errorMsg:
                    self.console(errorMsg, error=True)

        hasEnt = eVals is not None
        hasQTokens = qTokens is not None and len(qTokens)
        hasOcc = not hasEnt and hasQTokens

        if eVals is not None and eVals in entityVal:
            eSlots = entityVal[eVals]
            eStarts = {s[0]: s[-1] for s in eSlots}
        else:
            eStarts = {}

        useQTokens = qTokens if hasOcc else None

        requireFree = (
            True if freeState == &#34;free&#34; else False if freeState == &#34;bound&#34; else None
        )

        results = []

        for b in buckets:
            fValStats = {feat: collections.Counter() for feat in features}
            (fits, result) = entityMatch(
                entityIndex,
                eStarts,
                entitySlotVal,
                entitySlotAll,
                entitySlotIndex,
                getTextR,
                getTokens,
                b,
                bFindRe,
                anyEnt,
                eVals,
                useQTokens,
                valSelect,
                requireFree,
                fValStats,
            )

            blocked = fits is not None and not fits

            if not blocked:
                nFind += 1

            for feat in features:
                theseStats = fValStats[feat]
                if len(theseStats):
                    theseNEnt = nEnt[feat]
                    theseNVisible = nVisible[feat]

                    for ek, n in theseStats.items():
                        theseNEnt[ek] += n
                        if not blocked:
                            theseNVisible[ek] += n

            nMatches = len(result[1])

            if nMatches:
                nEnt[&#34;&#34;][None] += nMatches
                if not blocked:
                    nVisible[&#34;&#34;][None] += nMatches

            if node is None:
                if fits is not None and not fits:
                    continue

                if (hasEnt or hasQTokens) and nMatches == 0:
                    continue

            results.append((b, *result))

        if browse:
            return (results, nFind, nVisible, nEnt)

        nResults = len(results)

        if showStats:
            pluralF = &#34;&#34; if nFind == 1 else &#34;s&#34;
            self.console(f&#34;{nFind} {bucketType}{pluralF} satisfy the filter&#34;)
            for feat in (&#34;&#34;,) + (() if anyEnt else features):
                if feat == &#34;&#34;:
                    self.console(&#34;Combined features match:&#34;)
                    for ek, n in sorted(nEnt[feat].items()):
                        v = nVisible[feat][ek]
                        self.console(f&#34;\t{v:&gt;5} of {n:&gt;5} x&#34;)
                else:
                    self.console(f&#34;Feature {feat}: found the following values:&#34;)
                    for ek, n in sorted(nEnt[feat].items()):
                        v = nVisible[feat][ek]
                        self.console(f&#34;\t{v:&gt;5} of {n:&gt;5} x {ek}&#34;)
        if showStats or showStats is None:
            pluralR = &#34;&#34; if nResults == 1 else &#34;s&#34;
            self.console(f&#34;{nResults} {bucketType}{pluralR}&#34;)
        return results</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.browser.ner.annotate.Annotate"><code class="flex name class">
<span>class <span class="ident">Annotate</span></span>
<span>(</span><span>app, data=None, browse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Entity annotation.</p>
<p>Basic methods to handle the various aspects of entity annotation.
These methods can be used by code that runs in the Text-Fabric browser
and by code that runs in a Jupyter notebook.</p>
<p>This class handles data, it does not contain code to generate HTML.
But it has a parent class, <code>Show</code>, that can generate HTML.</p>
<p>This class works with a fixed annotation set.
But it has a parent class, <code>Sets</code> that has method to manipulate such sets
and switch between them.</p>
<p>We consider the corpus as a list of buckets (typically level-3 sectional
units; in TEI-derived corpora called <code>chunk</code>s, being generalizations of
<code>p</code> (paragraph) elements). What type exactly the buckets are is configured
in the <code>ner/config.yaml</code> file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>object</code></dt>
<dd>The object that corresponds to a loaded TF app for a corpus.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>object</code>, optional <code>None</code></dt>
<dd>Entity data to start with. If this class is initialized by the browser,
the browser hands over the in-memory data that the tool needs.
That way, it can maintain access to the same data between requests.
If None, no data is handed over, and a fresh data store will be
created by an ancestor class (Data)</dd>
<dt><strong><code>browse</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, the object is informed that it is run by the Text-Fabric
browser. This will influence how results are reported back.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/7fdf25fed954698d7bcf1c0099489ed4c8456fe6/tf/browser/ner/annotate.py#L89-L399" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Annotate(Sets, Show):
    def __init__(self, app, data=None, browse=False):
        &#34;&#34;&#34;Entity annotation.

        Basic methods to handle the various aspects of entity annotation.
        These methods can be used by code that runs in the Text-Fabric browser
        and by code that runs in a Jupyter notebook.

        This class handles data, it does not contain code to generate HTML.
        But it has a parent class, `Show`, that can generate HTML.

        This class works with a fixed annotation set.
        But it has a parent class, `Sets` that has method to manipulate such sets
        and switch between them.

        We consider the corpus as a list of buckets (typically level-3 sectional
        units; in TEI-derived corpora called `chunk`s, being generalizations of
        `p` (paragraph) elements). What type exactly the buckets are is configured
        in the `ner/config.yaml` file.

        Parameters
        ----------
        app: object
            The object that corresponds to a loaded TF app for a corpus.
        data: object, optional None
            Entity data to start with. If this class is initialized by the browser,
            the browser hands over the in-memory data that the tool needs.
            That way, it can maintain access to the same data between requests.
            If None, no data is handed over, and a fresh data store will be
            created by an ancestor class (Data)
        browse: boolean, optional False
            If True, the object is informed that it is run by the Text-Fabric
            browser. This will influence how results are reported back.
        &#34;&#34;&#34;
        self.app = app
        super().__init__(data=data)

        self.browse = browse

        if not browse:
            self.loadData()

    def findOccs(self, qTokenSet=set()):
        &#34;&#34;&#34;Finds the occurrences of multiple sequences of tokens.

        This is meant to efficiently list all occurrences of many token
        sequences in the corpus.

        Parameters
        ----------
        qTokenSet: set, optional set()
            A set of sequences of tokens. Each sequence in the set will be used as a
            search pattern in the whole corpus, and it occurrences are collected.

        Returns
        -------
        dict
            Keyed by each member of parameter `qTokenSet` the values are
            the occurrences of that member in the corpus.
            A single occurrence is represented as a tuple of slots.

        &#34;&#34;&#34;
        setData = self.getSetData()
        getTokens = self.getTokens

        buckets = setData.buckets or ()

        results = {}

        for b in buckets:
            occMatch(getTokens, b, qTokenSet, results)

        return results

    def filterContent(
        self,
        buckets=None,
        node=None,
        bFind=None,
        bFindC=None,
        bFindRe=None,
        anyEnt=None,
        eVals=None,
        qTokens=None,
        valSelect=None,
        freeState=None,
        showStats=None,
    ):
        &#34;&#34;&#34;Filter the buckets according to a variety of criteria.

        Either the buckets of the whole corpus are filtered, or a given subset
        of buckets, or a subset of buckets, namely those contained in a
        particular node, see parameters `node`, and `buckets`.

        **Bucket filtering**

        The parameters `bFind`, `bFindC`, `bFindRe`  specify a regular expression
        search on the texts of the buckets.

        The positions of the found occurrences is included in the result.

        The parameter `anyEnt` is a filter on the presence or absence of entities in
        buckets in general.

        **Entity filtering**

        The parameter `eVals` holds the values of a specific entity to look for.

        **Occurrence filtering**

        The parameter `qTokens` is a sequence of tokens to look for.
        The occurrences that are found, can be filtered further by `valSelect`
        and `freeState`.

        In entity filtering and occurrence filtering, the matching occurrences
        are included in the result.

        Parameters
        ----------
        buckets: set of integer, optional None
            The set of buckets to filter, instead of the whole corpus.
            Works also if the parameter `node` is specified, which also restricts
            the buckets to filter. If both are specified, their effect will be
            combined.
        node: integer, optional None
            Gets the context of the node, typically the intermediate-level section
            in which the node occurs. Then restricts the filtering to the buckets
            contained in the context, instead of the whole corpus.
        bFind: string, optional None
            A search pattern that filters the buckets, before applying the search
            for a token sequence.
        bFindC: string, optional None
            Whether the search is case sensitive or not.
        bFindRe: object, optional None
            A compiled regular expression.
            This function searches on `bFindRe`, but if it is None, it compiles
            `bFind` as regular expression and searches on that. If `bFind` itself
            is not None, of course.
        anyEnt: boolean, optional None
            If True, it wants all buckets that contain at least one already
            marked entity; if False, it wants all buckets that do not contain any
            already marked entity.
        eVals: tuple, optional None
            A sequence of values corresponding with the entity features `eid`
            and `kind`. If given, the function wants buckets that contain at least
            an entity with those properties.
        qTokens: tuple, optional None
            A sequence of tokens whose occurrences in the corpus will be looked up.
        valSelect: dict, optional None
            If present, the keys are the entity features (`eid` and `kind`),
            and the values are iterables of values that are allowed.

            The feature values to filter on.
            The results of searching for `eVals` or `qTokens` are filtered further.
            If a result is also an instance of an already marked entity,
            the properties of that entity will be compared feature by feature with
            the allowed values that `valSelect` specifies for that feature.
        freeState: boolean, optional None
            If True, found occurrences may not intersect with already marked up
            features.
            If False, found occurrences must intersect with already marked up features.
        showStats: boolean, optional None
            Whether to show statistics of the find.
            If None, it only shows gross totals, if False, it shows nothing,
            if True, it shows totals by feature.

        Returns
        -------
        list of tuples
            For each bucket that passes the filter, a tuple with the following
            members is added to the list:

            *   the TF node of the bucket;
            *   tokens: the tokens of the bucket, each token is a tuple consisting
                of the TF-slot of the token and its string value;
            *   matches: the match positions of the found occurrences or entity;
            *   positions: the token positions of where the text of the bucket
                starts matching the `bFindRe`;

            If `browse` is True, also some stats are passed next to the list
            of results.
        &#34;&#34;&#34;
        settings = self.settings
        bucketType = settings.bucketType
        features = settings.features

        getTextR = self.getTextR
        getTokens = self.getTokens

        browse = self.browse
        setData = self.getSetData()
        entityIndex = setData.entityIndex
        entityVal = setData.entityVal
        entitySlotVal = setData.entitySlotVal
        entitySlotAll = setData.entitySlotAll
        entitySlotIndex = setData.entitySlotIndex

        bucketUniverse = (
            setData.buckets
            if buckets is None
            else tuple(sorted(self.checkBuckets(buckets)))
        )
        buckets = (
            bucketUniverse
            if node is None
            else tuple(sorted(set(bucketUniverse) &amp; set(self.getContext(node))))
        )

        nFind = 0
        nEnt = {feat: collections.Counter() for feat in (&#34;&#34;,) + features}
        nVisible = {feat: collections.Counter() for feat in (&#34;&#34;,) + features}

        if bFindRe is None:
            if bFind is not None:
                (bFind, bFindRe, errorMsg) = findCompile(bFind, bFindC)
                if errorMsg:
                    self.console(errorMsg, error=True)

        hasEnt = eVals is not None
        hasQTokens = qTokens is not None and len(qTokens)
        hasOcc = not hasEnt and hasQTokens

        if eVals is not None and eVals in entityVal:
            eSlots = entityVal[eVals]
            eStarts = {s[0]: s[-1] for s in eSlots}
        else:
            eStarts = {}

        useQTokens = qTokens if hasOcc else None

        requireFree = (
            True if freeState == &#34;free&#34; else False if freeState == &#34;bound&#34; else None
        )

        results = []

        for b in buckets:
            fValStats = {feat: collections.Counter() for feat in features}
            (fits, result) = entityMatch(
                entityIndex,
                eStarts,
                entitySlotVal,
                entitySlotAll,
                entitySlotIndex,
                getTextR,
                getTokens,
                b,
                bFindRe,
                anyEnt,
                eVals,
                useQTokens,
                valSelect,
                requireFree,
                fValStats,
            )

            blocked = fits is not None and not fits

            if not blocked:
                nFind += 1

            for feat in features:
                theseStats = fValStats[feat]
                if len(theseStats):
                    theseNEnt = nEnt[feat]
                    theseNVisible = nVisible[feat]

                    for ek, n in theseStats.items():
                        theseNEnt[ek] += n
                        if not blocked:
                            theseNVisible[ek] += n

            nMatches = len(result[1])

            if nMatches:
                nEnt[&#34;&#34;][None] += nMatches
                if not blocked:
                    nVisible[&#34;&#34;][None] += nMatches

            if node is None:
                if fits is not None and not fits:
                    continue

                if (hasEnt or hasQTokens) and nMatches == 0:
                    continue

            results.append((b, *result))

        if browse:
            return (results, nFind, nVisible, nEnt)

        nResults = len(results)

        if showStats:
            pluralF = &#34;&#34; if nFind == 1 else &#34;s&#34;
            self.console(f&#34;{nFind} {bucketType}{pluralF} satisfy the filter&#34;)
            for feat in (&#34;&#34;,) + (() if anyEnt else features):
                if feat == &#34;&#34;:
                    self.console(&#34;Combined features match:&#34;)
                    for ek, n in sorted(nEnt[feat].items()):
                        v = nVisible[feat][ek]
                        self.console(f&#34;\t{v:&gt;5} of {n:&gt;5} x&#34;)
                else:
                    self.console(f&#34;Feature {feat}: found the following values:&#34;)
                    for ek, n in sorted(nEnt[feat].items()):
                        v = nVisible[feat][ek]
                        self.console(f&#34;\t{v:&gt;5} of {n:&gt;5} x {ek}&#34;)
        if showStats or showStats is None:
            pluralR = &#34;&#34; if nResults == 1 else &#34;s&#34;
            self.console(f&#34;{nResults} {bucketType}{pluralR}&#34;)
        return results</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tf.browser.ner.sets.Sets" href="sets.html#tf.browser.ner.sets.Sets">Sets</a></li>
<li><a title="tf.browser.ner.data.Data" href="data.html#tf.browser.ner.data.Data">Data</a></li>
<li><a title="tf.browser.ner.corpus.Corpus" href="corpus.html#tf.browser.ner.corpus.Corpus">Corpus</a></li>
<li><a title="tf.browser.ner.settings.Settings" href="settings.html#tf.browser.ner.settings.Settings">Settings</a></li>
<li><a title="tf.browser.ner.show.Show" href="show.html#tf.browser.ner.show.Show">Show</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tf.browser.ner.power.PowerNER" href="power.html#tf.browser.ner.power.PowerNER">PowerNER</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tf.browser.ner.annotate.Annotate.filterContent"><code class="name flex">
<span>def <span class="ident">filterContent</span></span>(<span>self, buckets=None, node=None, bFind=None, bFindC=None, bFindRe=None, anyEnt=None, eVals=None, qTokens=None, valSelect=None, freeState=None, showStats=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter the buckets according to a variety of criteria.</p>
<p>Either the buckets of the whole corpus are filtered, or a given subset
of buckets, or a subset of buckets, namely those contained in a
particular node, see parameters <code>node</code>, and <code>buckets</code>.</p>
<p><strong>Bucket filtering</strong></p>
<p>The parameters <code>bFind</code>, <code>bFindC</code>, <code>bFindRe</code>
specify a regular expression
search on the texts of the buckets.</p>
<p>The positions of the found occurrences is included in the result.</p>
<p>The parameter <code>anyEnt</code> is a filter on the presence or absence of entities in
buckets in general.</p>
<p><strong>Entity filtering</strong></p>
<p>The parameter <code>eVals</code> holds the values of a specific entity to look for.</p>
<p><strong>Occurrence filtering</strong></p>
<p>The parameter <code>qTokens</code> is a sequence of tokens to look for.
The occurrences that are found, can be filtered further by <code>valSelect</code>
and <code>freeState</code>.</p>
<p>In entity filtering and occurrence filtering, the matching occurrences
are included in the result.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>buckets</code></strong> :&ensp;<code>set</code> of <code>integer</code>, optional <code>None</code></dt>
<dd>The set of buckets to filter, instead of the whole corpus.
Works also if the parameter <code>node</code> is specified, which also restricts
the buckets to filter. If both are specified, their effect will be
combined.</dd>
<dt><strong><code>node</code></strong> :&ensp;<code>integer</code>, optional <code>None</code></dt>
<dd>Gets the context of the node, typically the intermediate-level section
in which the node occurs. Then restricts the filtering to the buckets
contained in the context, instead of the whole corpus.</dd>
<dt><strong><code>bFind</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>A search pattern that filters the buckets, before applying the search
for a token sequence.</dd>
<dt><strong><code>bFindC</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>Whether the search is case sensitive or not.</dd>
<dt><strong><code>bFindRe</code></strong> :&ensp;<code>object</code>, optional <code>None</code></dt>
<dd>A compiled regular expression.
This function searches on <code>bFindRe</code>, but if it is None, it compiles
<code>bFind</code> as regular expression and searches on that. If <code>bFind</code> itself
is not None, of course.</dd>
<dt><strong><code>anyEnt</code></strong> :&ensp;<code>boolean</code>, optional <code>None</code></dt>
<dd>If True, it wants all buckets that contain at least one already
marked entity; if False, it wants all buckets that do not contain any
already marked entity.</dd>
<dt><strong><code>eVals</code></strong> :&ensp;<code>tuple</code>, optional <code>None</code></dt>
<dd>A sequence of values corresponding with the entity features <code>eid</code>
and <code>kind</code>. If given, the function wants buckets that contain at least
an entity with those properties.</dd>
<dt><strong><code>qTokens</code></strong> :&ensp;<code>tuple</code>, optional <code>None</code></dt>
<dd>A sequence of tokens whose occurrences in the corpus will be looked up.</dd>
<dt><strong><code>valSelect</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>
<p>If present, the keys are the entity features (<code>eid</code> and <code>kind</code>),
and the values are iterables of values that are allowed.</p>
<p>The feature values to filter on.
The results of searching for <code>eVals</code> or <code>qTokens</code> are filtered further.
If a result is also an instance of an already marked entity,
the properties of that entity will be compared feature by feature with
the allowed values that <code>valSelect</code> specifies for that feature.</p>
</dd>
<dt><strong><code>freeState</code></strong> :&ensp;<code>boolean</code>, optional <code>None</code></dt>
<dd>If True, found occurrences may not intersect with already marked up
features.
If False, found occurrences must intersect with already marked up features.</dd>
<dt><strong><code>showStats</code></strong> :&ensp;<code>boolean</code>, optional <code>None</code></dt>
<dd>Whether to show statistics of the find.
If None, it only shows gross totals, if False, it shows nothing,
if True, it shows totals by feature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>tuples</code></dt>
<dd>
<p>For each bucket that passes the filter, a tuple with the following
members is added to the list:</p>
<ul>
<li>the TF node of the bucket;</li>
<li>tokens: the tokens of the bucket, each token is a tuple consisting
of the TF-slot of the token and its string value;</li>
<li>matches: the match positions of the found occurrences or entity;</li>
<li>positions: the token positions of where the text of the bucket
starts matching the <code>bFindRe</code>;</li>
</ul>
<p>If <code>browse</code> is True, also some stats are passed next to the list
of results.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/7fdf25fed954698d7bcf1c0099489ed4c8456fe6/tf/browser/ner/annotate.py#L163-L399" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def filterContent(
    self,
    buckets=None,
    node=None,
    bFind=None,
    bFindC=None,
    bFindRe=None,
    anyEnt=None,
    eVals=None,
    qTokens=None,
    valSelect=None,
    freeState=None,
    showStats=None,
):
    &#34;&#34;&#34;Filter the buckets according to a variety of criteria.

    Either the buckets of the whole corpus are filtered, or a given subset
    of buckets, or a subset of buckets, namely those contained in a
    particular node, see parameters `node`, and `buckets`.

    **Bucket filtering**

    The parameters `bFind`, `bFindC`, `bFindRe`  specify a regular expression
    search on the texts of the buckets.

    The positions of the found occurrences is included in the result.

    The parameter `anyEnt` is a filter on the presence or absence of entities in
    buckets in general.

    **Entity filtering**

    The parameter `eVals` holds the values of a specific entity to look for.

    **Occurrence filtering**

    The parameter `qTokens` is a sequence of tokens to look for.
    The occurrences that are found, can be filtered further by `valSelect`
    and `freeState`.

    In entity filtering and occurrence filtering, the matching occurrences
    are included in the result.

    Parameters
    ----------
    buckets: set of integer, optional None
        The set of buckets to filter, instead of the whole corpus.
        Works also if the parameter `node` is specified, which also restricts
        the buckets to filter. If both are specified, their effect will be
        combined.
    node: integer, optional None
        Gets the context of the node, typically the intermediate-level section
        in which the node occurs. Then restricts the filtering to the buckets
        contained in the context, instead of the whole corpus.
    bFind: string, optional None
        A search pattern that filters the buckets, before applying the search
        for a token sequence.
    bFindC: string, optional None
        Whether the search is case sensitive or not.
    bFindRe: object, optional None
        A compiled regular expression.
        This function searches on `bFindRe`, but if it is None, it compiles
        `bFind` as regular expression and searches on that. If `bFind` itself
        is not None, of course.
    anyEnt: boolean, optional None
        If True, it wants all buckets that contain at least one already
        marked entity; if False, it wants all buckets that do not contain any
        already marked entity.
    eVals: tuple, optional None
        A sequence of values corresponding with the entity features `eid`
        and `kind`. If given, the function wants buckets that contain at least
        an entity with those properties.
    qTokens: tuple, optional None
        A sequence of tokens whose occurrences in the corpus will be looked up.
    valSelect: dict, optional None
        If present, the keys are the entity features (`eid` and `kind`),
        and the values are iterables of values that are allowed.

        The feature values to filter on.
        The results of searching for `eVals` or `qTokens` are filtered further.
        If a result is also an instance of an already marked entity,
        the properties of that entity will be compared feature by feature with
        the allowed values that `valSelect` specifies for that feature.
    freeState: boolean, optional None
        If True, found occurrences may not intersect with already marked up
        features.
        If False, found occurrences must intersect with already marked up features.
    showStats: boolean, optional None
        Whether to show statistics of the find.
        If None, it only shows gross totals, if False, it shows nothing,
        if True, it shows totals by feature.

    Returns
    -------
    list of tuples
        For each bucket that passes the filter, a tuple with the following
        members is added to the list:

        *   the TF node of the bucket;
        *   tokens: the tokens of the bucket, each token is a tuple consisting
            of the TF-slot of the token and its string value;
        *   matches: the match positions of the found occurrences or entity;
        *   positions: the token positions of where the text of the bucket
            starts matching the `bFindRe`;

        If `browse` is True, also some stats are passed next to the list
        of results.
    &#34;&#34;&#34;
    settings = self.settings
    bucketType = settings.bucketType
    features = settings.features

    getTextR = self.getTextR
    getTokens = self.getTokens

    browse = self.browse
    setData = self.getSetData()
    entityIndex = setData.entityIndex
    entityVal = setData.entityVal
    entitySlotVal = setData.entitySlotVal
    entitySlotAll = setData.entitySlotAll
    entitySlotIndex = setData.entitySlotIndex

    bucketUniverse = (
        setData.buckets
        if buckets is None
        else tuple(sorted(self.checkBuckets(buckets)))
    )
    buckets = (
        bucketUniverse
        if node is None
        else tuple(sorted(set(bucketUniverse) &amp; set(self.getContext(node))))
    )

    nFind = 0
    nEnt = {feat: collections.Counter() for feat in (&#34;&#34;,) + features}
    nVisible = {feat: collections.Counter() for feat in (&#34;&#34;,) + features}

    if bFindRe is None:
        if bFind is not None:
            (bFind, bFindRe, errorMsg) = findCompile(bFind, bFindC)
            if errorMsg:
                self.console(errorMsg, error=True)

    hasEnt = eVals is not None
    hasQTokens = qTokens is not None and len(qTokens)
    hasOcc = not hasEnt and hasQTokens

    if eVals is not None and eVals in entityVal:
        eSlots = entityVal[eVals]
        eStarts = {s[0]: s[-1] for s in eSlots}
    else:
        eStarts = {}

    useQTokens = qTokens if hasOcc else None

    requireFree = (
        True if freeState == &#34;free&#34; else False if freeState == &#34;bound&#34; else None
    )

    results = []

    for b in buckets:
        fValStats = {feat: collections.Counter() for feat in features}
        (fits, result) = entityMatch(
            entityIndex,
            eStarts,
            entitySlotVal,
            entitySlotAll,
            entitySlotIndex,
            getTextR,
            getTokens,
            b,
            bFindRe,
            anyEnt,
            eVals,
            useQTokens,
            valSelect,
            requireFree,
            fValStats,
        )

        blocked = fits is not None and not fits

        if not blocked:
            nFind += 1

        for feat in features:
            theseStats = fValStats[feat]
            if len(theseStats):
                theseNEnt = nEnt[feat]
                theseNVisible = nVisible[feat]

                for ek, n in theseStats.items():
                    theseNEnt[ek] += n
                    if not blocked:
                        theseNVisible[ek] += n

        nMatches = len(result[1])

        if nMatches:
            nEnt[&#34;&#34;][None] += nMatches
            if not blocked:
                nVisible[&#34;&#34;][None] += nMatches

        if node is None:
            if fits is not None and not fits:
                continue

            if (hasEnt or hasQTokens) and nMatches == 0:
                continue

        results.append((b, *result))

    if browse:
        return (results, nFind, nVisible, nEnt)

    nResults = len(results)

    if showStats:
        pluralF = &#34;&#34; if nFind == 1 else &#34;s&#34;
        self.console(f&#34;{nFind} {bucketType}{pluralF} satisfy the filter&#34;)
        for feat in (&#34;&#34;,) + (() if anyEnt else features):
            if feat == &#34;&#34;:
                self.console(&#34;Combined features match:&#34;)
                for ek, n in sorted(nEnt[feat].items()):
                    v = nVisible[feat][ek]
                    self.console(f&#34;\t{v:&gt;5} of {n:&gt;5} x&#34;)
            else:
                self.console(f&#34;Feature {feat}: found the following values:&#34;)
                for ek, n in sorted(nEnt[feat].items()):
                    v = nVisible[feat][ek]
                    self.console(f&#34;\t{v:&gt;5} of {n:&gt;5} x {ek}&#34;)
    if showStats or showStats is None:
        pluralR = &#34;&#34; if nResults == 1 else &#34;s&#34;
        self.console(f&#34;{nResults} {bucketType}{pluralR}&#34;)
    return results</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.annotate.Annotate.findOccs"><code class="name flex">
<span>def <span class="ident">findOccs</span></span>(<span>self, qTokenSet=set())</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the occurrences of multiple sequences of tokens.</p>
<p>This is meant to efficiently list all occurrences of many token
sequences in the corpus.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>qTokenSet</code></strong> :&ensp;<code>set</code>, optional <code>set()</code></dt>
<dd>A set of sequences of tokens. Each sequence in the set will be used as a
search pattern in the whole corpus, and it occurrences are collected.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Keyed by each member of parameter <code>qTokenSet</code> the values are
the occurrences of that member in the corpus.
A single occurrence is represented as a tuple of slots.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/7fdf25fed954698d7bcf1c0099489ed4c8456fe6/tf/browser/ner/annotate.py#L131-L161" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findOccs(self, qTokenSet=set()):
    &#34;&#34;&#34;Finds the occurrences of multiple sequences of tokens.

    This is meant to efficiently list all occurrences of many token
    sequences in the corpus.

    Parameters
    ----------
    qTokenSet: set, optional set()
        A set of sequences of tokens. Each sequence in the set will be used as a
        search pattern in the whole corpus, and it occurrences are collected.

    Returns
    -------
    dict
        Keyed by each member of parameter `qTokenSet` the values are
        the occurrences of that member in the corpus.
        A single occurrence is represented as a tuple of slots.

    &#34;&#34;&#34;
    setData = self.getSetData()
    getTokens = self.getTokens

    buckets = setData.buckets or ()

    results = {}

    for b in buckets:
        occMatch(getTokens, b, qTokenSet, results)

    return results</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tf.browser.ner.sets.Sets" href="sets.html#tf.browser.ner.sets.Sets">Sets</a></b></code>:
<ul class="hlist">
<li><code><a title="tf.browser.ner.sets.Sets.addEntities" href="data.html#tf.browser.ner.data.Data.addEntities">addEntities</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.addEntity" href="data.html#tf.browser.ner.data.Data.addEntity">addEntity</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.addEntityRich" href="data.html#tf.browser.ner.data.Data.addEntityRich">addEntityRich</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.annoSet" href="sets.html#tf.browser.ner.sets.Sets.annoSet">annoSet</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.annoSetRep" href="sets.html#tf.browser.ner.sets.Sets.annoSetRep">annoSetRep</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.checkBuckets" href="corpus.html#tf.browser.ner.corpus.Corpus.checkBuckets">checkBuckets</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.checkFeature" href="corpus.html#tf.browser.ner.corpus.Corpus.checkFeature">checkFeature</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.console" href="settings.html#tf.browser.ner.settings.Settings.console">console</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.delEntity" href="data.html#tf.browser.ner.data.Data.delEntity">delEntity</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.delEntityRich" href="data.html#tf.browser.ner.data.Data.delEntityRich">delEntityRich</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.featureDefault" href="corpus.html#tf.browser.ner.corpus.Corpus.featureDefault">featureDefault</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.fromSource" href="data.html#tf.browser.ner.data.Data.fromSource">fromSource</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.get0" href="corpus.html#tf.browser.ner.corpus.Corpus.get0">get0</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.get1" href="corpus.html#tf.browser.ner.corpus.Corpus.get1">get1</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.getAfter" href="corpus.html#tf.browser.ner.corpus.Corpus.getAfter">getAfter</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.getBucketNodes" href="corpus.html#tf.browser.ner.corpus.Corpus.getBucketNodes">getBucketNodes</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.getContext" href="corpus.html#tf.browser.ner.corpus.Corpus.getContext">getContext</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.getEntityNodes" href="corpus.html#tf.browser.ner.corpus.Corpus.getEntityNodes">getEntityNodes</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.getFVal" href="corpus.html#tf.browser.ner.corpus.Corpus.getFVal">getFVal</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.getSetData" href="sets.html#tf.browser.ner.sets.Sets.getSetData">getSetData</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.getSlots" href="corpus.html#tf.browser.ner.corpus.Corpus.getSlots">getSlots</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.getStr" href="corpus.html#tf.browser.ner.corpus.Corpus.getStr">getStr</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.getStrings" href="corpus.html#tf.browser.ner.corpus.Corpus.getStrings">getStrings</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.getText" href="corpus.html#tf.browser.ner.corpus.Corpus.getText">getText</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.getTextR" href="corpus.html#tf.browser.ner.corpus.Corpus.getTextR">getTextR</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.getTokens" href="corpus.html#tf.browser.ner.corpus.Corpus.getTokens">getTokens</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.loadData" href="data.html#tf.browser.ner.data.Data.loadData">loadData</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.mergeEntities" href="data.html#tf.browser.ner.data.Data.mergeEntities">mergeEntities</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.process" href="data.html#tf.browser.ner.data.Data.process">process</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.resetSet" href="sets.html#tf.browser.ner.sets.Sets.resetSet">resetSet</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.saveEntitiesAs" href="data.html#tf.browser.ner.data.Data.saveEntitiesAs">saveEntitiesAs</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.sectionHead" href="corpus.html#tf.browser.ner.corpus.Corpus.sectionHead">sectionHead</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.setDel" href="sets.html#tf.browser.ner.sets.Sets.setDel">setDel</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.setDup" href="sets.html#tf.browser.ner.sets.Sets.setDup">setDup</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.setMove" href="sets.html#tf.browser.ner.sets.Sets.setMove">setMove</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.setNames" href="sets.html#tf.browser.ner.sets.Sets.setNames">setNames</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.setSet" href="sets.html#tf.browser.ner.sets.Sets.setSet">setSet</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.slotType" href="corpus.html#tf.browser.ner.corpus.Corpus.slotType">slotType</a></code></li>
<li><code><a title="tf.browser.ner.sets.Sets.weedEntities" href="data.html#tf.browser.ner.data.Data.weedEntities">weedEntities</a></code></li>
</ul>
</li>
<li><code><b><a title="tf.browser.ner.show.Show" href="show.html#tf.browser.ner.show.Show">Show</a></b></code>:
<ul class="hlist">
<li><code><a title="tf.browser.ner.show.Show.showContent" href="show.html#tf.browser.ner.show.Show.showContent">showContent</a></code></li>
<li><code><a title="tf.browser.ner.show.Show.showEntities" href="show.html#tf.browser.ner.show.Show.showEntities">showEntities</a></code></li>
<li><code><a title="tf.browser.ner.show.Show.showEntityOverview" href="show.html#tf.browser.ner.show.Show.showEntityOverview">showEntityOverview</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.browser.ner" href="index.html">tf.browser.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.browser.ner.annotate.Annotate" href="#tf.browser.ner.annotate.Annotate">Annotate</a></code></h4>
<ul class="">
<li><code><a title="tf.browser.ner.annotate.Annotate.filterContent" href="#tf.browser.ner.annotate.Annotate.filterContent">filterContent</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.findOccs" href="#tf.browser.ner.annotate.Annotate.findOccs">findOccs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>