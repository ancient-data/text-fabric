<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.browser.ner.annotate API documentation</title>
<meta name="description" content="API for marking entities." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.browser.ner.annotate</code></h1>
</header>
<section id="section-intro">
<p>API for marking entities.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/annotate.py#L1-L336" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;API for marking entities.


&#34;&#34;&#34;

import collections


from ...core.helpers import console as cs

from .settings import TOOLKEY

from .helpers import findCompile, makeCss
from .sets import Sets
from .show import Show
from .match import entityMatch, occMatch


class Annotate(Sets, Show):
    def __init__(self, app, data=None, browse=False):
        &#34;&#34;&#34;Entity annotation.

        Basic methods to handle the various aspects of entity annotation.
        These methods can be used by code that runs in the Text-Fabric browser
        and by code that runs in a Jupyter notebook.

        This class handles data, it does not contain code to generate HTML.
        But it has a parent class, `Show`, that can generate HTML.

        This class works with a fixed annotation set.
        But it has a parent class, `Sets` that has method to manipulate such sets
        and switch between them.

        We consider the corpus as a list of buckets (typically level-3 sectional
        units; in TEI-derived corpora called `chunk`s, being generalizations of
        `p` (paragraph) elements). What type exactly the buckets are is configured
        in the `ner/config.yaml` file.

        Parameters
        ----------
        app: object
            The object that corresponds to a loaded TF app for a corpus.
        data: object, optional None
            Entity data to start with. If this class is initialized by the browser,
            the browser hands over the in-memory data that the tool needs.
            That way, it can maintain access to the same data between requests.
            If None, no data is habded over, and the in-memory data will be
            created in this object.
        browse: boolean, optional False
            If True, the object is informed that it is run by the Text-Fabric
            browser. This will influence how results are reported back.
        &#34;&#34;&#34;
        self.app = app
        super().__init__(data=data)

        self.F = app.api.F
        self.browse = browse

        settings = self.settings
        features = settings.features
        keywordFeatures = settings.keywordFeatures

        app.loadToolCss(TOOLKEY, makeCss(features, keywordFeatures))

        if not browse:
            self.loadData()

    def console(self, msg, **kwargs):
        &#34;&#34;&#34;Print something to the output.

        This works exactly as `tf.core.helpers.console`

        It is handy to have this as a method on the Annotate object,
        so that we can issue temporary console statements during development
        without the need to add an `import` statement to the code.
        &#34;&#34;&#34;
        cs(msg, **kwargs)

    def findOccs(self, qTokenSet=set()):
        &#34;&#34;&#34;Finds the occurrences of multiple sequences of tokens.

        This is meant to efficiently list all occurrences of many token
        sequences in the corpus.

        Parameters
        ----------
        qTokenSet: set, optional set()
            A set of sequences of tokens. Each sequence in the set will be used as a
            search pattern in the whole corpus, and it occurrences are collected.

        Returns
        -------
        dict
            Keyed by each member of parameter `qTokenSet` the values are
            the occurrences of that member in the corpus.
            A single occurrence is represented as a tuple of slots.

        &#34;&#34;&#34;
        app = self.app
        setData = self.getSetData()
        api = app.api
        L = api.L
        F = api.F

        buckets = setData.buckets or ()

        results = {}

        for b in buckets:
            occMatch(L, F, b, qTokenSet, results)

        return results

    def filterContent(
        self,
        node=None,
        bFind=None,
        bFindC=None,
        bFindRe=None,
        anyEnt=None,
        eVals=None,
        qTokens=None,
        valSelect=None,
        freeState=None,
        showStats=None,
    ):
        &#34;&#34;&#34;Filter the buckets according to a variety of criteria.

        Either the buckets of the whole corpus are filtered, or a subset of buckets,
        namely those contained in a particular node.

        **Bucket filtering**

        The parameters `bFind`, `bFindC`, `bFindRe`  specify a regular expression
        search on the texts of the buckets.

        The positions of the found occurrences is included in the result.

        The parameter `anyEnt` is a filter on the presence or absence of entities in
        buckets in general.

        **Entity filtering**

        The parameter `eVals` holds the values of a specific entity to look for.

        **Occurrence filtering**

        The parameter `qTokens` is a sequence of tokens to look for.
        The occurrences that are found, can be filtered further by `valSelect`
        and `freeState`.

        In entity filtering and occurrence filtering, the matching occurrences
        are included in the result.

        Parameters
        ----------
        bFind: string, optional None
            A search pattern that filters the buckets, before applying the search
            for a token sequence.
        bFindC: string, optional None
            Whether the search is case sensitive or not.
        bFindRe: object, optional None
            A compiled regular expression.
            This function searches on `bFindRe`, but if it is None, it compiles
            `bFind` as regular expression and searches on that. If `bFind` itself
            is not None, of course.
        anyEnt: boolean, optional None
            If True, it wants all buckets that contain at least one already
            marked entity; if False, it wants all buckets that do not contain any
            already marked entity.
        eVals: tuple, optional None
            A sequence of values corresponding with the entity features `eid`
            and `kind`. If given, the function wants buckets that contain at least
            an entity with those properties.
        qTokens: tuple, optional None
            A sequence of tokens whose occurrences in the corpus will be looked up.
        valSelect: dict, optional None
            If present, the keys are the entity features (`eid` and `kind`),
            and the values are iterables of values that are allowed.

            The feature values to filter on.
            The results of searching for `eVals` or `qTokens` are filtered further.
            If a result is also an instance of an already marked entity,
            the properties of that entity will be compared feature by feature with
            the allowed values that `valSelect` specifies for that feature.
        freeState: boolean, optional None
            If True, found occurrences may not intersect with already marked up
            features.
            If False, found occurrences must intersect with already marked up features.
        showStats: boolean, optional None
            Whether to show statistics of the find.
            If None, it only shows gross totals, if False, it shows nothing,
            if True, it shows totals by feature.

        Returns
        -------
        list of tuples
            For each bucket that passes the filter, a tuple with the following
            members is added to the list:

            *   tokens: the tokens of the bucket
            *   matches: the match positions of the found occurrences or entity
            *   positions: the token positions of where the text of the bucket
                starts matching the `bFindRe`

            If `browse` is True, also some stats are passed next to the list
            of results.
        &#34;&#34;&#34;
        settings = self.settings
        bucketType = settings.bucketType
        features = settings.features

        browse = self.browse
        app = self.app
        setData = self.getSetData()
        entityIndex = setData.entityIndex
        entityVal = setData.entityVal
        entitySlotVal = setData.entitySlotVal
        entitySlotAll = setData.entitySlotAll
        entitySlotIndex = setData.entitySlotIndex

        api = app.api
        L = api.L
        F = api.F
        T = api.T

        buckets = (
            setData.buckets or ()
            if node is None
            else L.d(T.sectionTuple(node)[1], otype=bucketType)
        )

        nFind = 0
        nEnt = {feat: collections.Counter() for feat in (&#34;&#34;,) + features}
        nVisible = {feat: collections.Counter() for feat in (&#34;&#34;,) + features}

        if bFindRe is None:
            if bFind is not None:
                (bFind, bFindRe, errorMsg) = findCompile(bFind, bFindC)
                if errorMsg:
                    app.error(errorMsg)

        hasEnt = eVals is not None
        hasQTokens = qTokens is not None and len(qTokens)
        hasOcc = not hasEnt and hasQTokens

        if eVals is not None:
            eSlots = entityVal[eVals]
            eStarts = {s[0]: s[-1] for s in eSlots}
        else:
            eStarts = None

        useQTokens = qTokens if hasOcc else None

        requireFree = (
            True if freeState == &#34;free&#34; else False if freeState == &#34;bound&#34; else None
        )

        results = []

        for b in buckets:
            fValStats = {feat: collections.Counter() for feat in features}
            (fits, result) = entityMatch(
                entityIndex,
                eStarts,
                entitySlotVal,
                entitySlotAll,
                entitySlotIndex,
                L,
                F,
                T,
                b,
                bFindRe,
                anyEnt,
                eVals,
                useQTokens,
                valSelect,
                requireFree,
                fValStats,
            )

            blocked = fits is not None and not fits

            if not blocked:
                nFind += 1

            for feat in features:
                theseStats = fValStats[feat]
                if len(theseStats):
                    theseNEnt = nEnt[feat]
                    theseNVisible = nVisible[feat]

                    for ek, n in theseStats.items():
                        theseNEnt[ek] += n
                        if not blocked:
                            theseNVisible[ek] += n

            nMatches = len(result[1])

            if nMatches:
                nEnt[&#34;&#34;][None] += nMatches
                if not blocked:
                    nVisible[&#34;&#34;][None] += nMatches

            if node is None:
                if fits is not None and not fits:
                    continue

                if (hasEnt or hasQTokens) and nMatches == 0:
                    continue

            results.append((b, *result))

        if browse:
            return (results, nFind, nVisible, nEnt)

        nResults = len(results)

        if showStats:
            pluralF = &#34;&#34; if nFind == 1 else &#34;s&#34;
            self.console(f&#34;{nFind} {bucketType}{pluralF} satisfy the filter&#34;)
            for feat in (&#34;&#34;,) + (() if anyEnt else features):
                if feat == &#34;&#34;:
                    self.console(&#34;Combined features match:&#34;)
                    for ek, n in sorted(nEnt[feat].items()):
                        v = nVisible[feat][ek]
                        self.console(f&#34;\t{v:&gt;5} of {n:&gt;5} x&#34;)
                else:
                    self.console(f&#34;Feature {feat}: found the following values:&#34;)
                    for ek, n in sorted(nEnt[feat].items()):
                        v = nVisible[feat][ek]
                        self.console(f&#34;\t{v:&gt;5} of {n:&gt;5} x {ek}&#34;)
        if showStats or showStats is None:
            pluralR = &#34;&#34; if nResults == 1 else &#34;s&#34;
            self.console(f&#34;{nResults} {bucketType}{pluralR}&#34;)
        return results</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.browser.ner.annotate.Annotate"><code class="flex name class">
<span>class <span class="ident">Annotate</span></span>
<span>(</span><span>app, data=None, browse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Entity annotation.</p>
<p>Basic methods to handle the various aspects of entity annotation.
These methods can be used by code that runs in the Text-Fabric browser
and by code that runs in a Jupyter notebook.</p>
<p>This class handles data, it does not contain code to generate HTML.
But it has a parent class, <code>Show</code>, that can generate HTML.</p>
<p>This class works with a fixed annotation set.
But it has a parent class, <code>Sets</code> that has method to manipulate such sets
and switch between them.</p>
<p>We consider the corpus as a list of buckets (typically level-3 sectional
units; in TEI-derived corpora called <code>chunk</code>s, being generalizations of
<code>p</code> (paragraph) elements). What type exactly the buckets are is configured
in the <code>ner/config.yaml</code> file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>object</code></dt>
<dd>The object that corresponds to a loaded TF app for a corpus.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>object</code>, optional <code>None</code></dt>
<dd>Entity data to start with. If this class is initialized by the browser,
the browser hands over the in-memory data that the tool needs.
That way, it can maintain access to the same data between requests.
If None, no data is habded over, and the in-memory data will be
created in this object.</dd>
<dt><strong><code>browse</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, the object is informed that it is run by the Text-Fabric
browser. This will influence how results are reported back.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/annotate.py#L19-L336" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Annotate(Sets, Show):
    def __init__(self, app, data=None, browse=False):
        &#34;&#34;&#34;Entity annotation.

        Basic methods to handle the various aspects of entity annotation.
        These methods can be used by code that runs in the Text-Fabric browser
        and by code that runs in a Jupyter notebook.

        This class handles data, it does not contain code to generate HTML.
        But it has a parent class, `Show`, that can generate HTML.

        This class works with a fixed annotation set.
        But it has a parent class, `Sets` that has method to manipulate such sets
        and switch between them.

        We consider the corpus as a list of buckets (typically level-3 sectional
        units; in TEI-derived corpora called `chunk`s, being generalizations of
        `p` (paragraph) elements). What type exactly the buckets are is configured
        in the `ner/config.yaml` file.

        Parameters
        ----------
        app: object
            The object that corresponds to a loaded TF app for a corpus.
        data: object, optional None
            Entity data to start with. If this class is initialized by the browser,
            the browser hands over the in-memory data that the tool needs.
            That way, it can maintain access to the same data between requests.
            If None, no data is habded over, and the in-memory data will be
            created in this object.
        browse: boolean, optional False
            If True, the object is informed that it is run by the Text-Fabric
            browser. This will influence how results are reported back.
        &#34;&#34;&#34;
        self.app = app
        super().__init__(data=data)

        self.F = app.api.F
        self.browse = browse

        settings = self.settings
        features = settings.features
        keywordFeatures = settings.keywordFeatures

        app.loadToolCss(TOOLKEY, makeCss(features, keywordFeatures))

        if not browse:
            self.loadData()

    def console(self, msg, **kwargs):
        &#34;&#34;&#34;Print something to the output.

        This works exactly as `tf.core.helpers.console`

        It is handy to have this as a method on the Annotate object,
        so that we can issue temporary console statements during development
        without the need to add an `import` statement to the code.
        &#34;&#34;&#34;
        cs(msg, **kwargs)

    def findOccs(self, qTokenSet=set()):
        &#34;&#34;&#34;Finds the occurrences of multiple sequences of tokens.

        This is meant to efficiently list all occurrences of many token
        sequences in the corpus.

        Parameters
        ----------
        qTokenSet: set, optional set()
            A set of sequences of tokens. Each sequence in the set will be used as a
            search pattern in the whole corpus, and it occurrences are collected.

        Returns
        -------
        dict
            Keyed by each member of parameter `qTokenSet` the values are
            the occurrences of that member in the corpus.
            A single occurrence is represented as a tuple of slots.

        &#34;&#34;&#34;
        app = self.app
        setData = self.getSetData()
        api = app.api
        L = api.L
        F = api.F

        buckets = setData.buckets or ()

        results = {}

        for b in buckets:
            occMatch(L, F, b, qTokenSet, results)

        return results

    def filterContent(
        self,
        node=None,
        bFind=None,
        bFindC=None,
        bFindRe=None,
        anyEnt=None,
        eVals=None,
        qTokens=None,
        valSelect=None,
        freeState=None,
        showStats=None,
    ):
        &#34;&#34;&#34;Filter the buckets according to a variety of criteria.

        Either the buckets of the whole corpus are filtered, or a subset of buckets,
        namely those contained in a particular node.

        **Bucket filtering**

        The parameters `bFind`, `bFindC`, `bFindRe`  specify a regular expression
        search on the texts of the buckets.

        The positions of the found occurrences is included in the result.

        The parameter `anyEnt` is a filter on the presence or absence of entities in
        buckets in general.

        **Entity filtering**

        The parameter `eVals` holds the values of a specific entity to look for.

        **Occurrence filtering**

        The parameter `qTokens` is a sequence of tokens to look for.
        The occurrences that are found, can be filtered further by `valSelect`
        and `freeState`.

        In entity filtering and occurrence filtering, the matching occurrences
        are included in the result.

        Parameters
        ----------
        bFind: string, optional None
            A search pattern that filters the buckets, before applying the search
            for a token sequence.
        bFindC: string, optional None
            Whether the search is case sensitive or not.
        bFindRe: object, optional None
            A compiled regular expression.
            This function searches on `bFindRe`, but if it is None, it compiles
            `bFind` as regular expression and searches on that. If `bFind` itself
            is not None, of course.
        anyEnt: boolean, optional None
            If True, it wants all buckets that contain at least one already
            marked entity; if False, it wants all buckets that do not contain any
            already marked entity.
        eVals: tuple, optional None
            A sequence of values corresponding with the entity features `eid`
            and `kind`. If given, the function wants buckets that contain at least
            an entity with those properties.
        qTokens: tuple, optional None
            A sequence of tokens whose occurrences in the corpus will be looked up.
        valSelect: dict, optional None
            If present, the keys are the entity features (`eid` and `kind`),
            and the values are iterables of values that are allowed.

            The feature values to filter on.
            The results of searching for `eVals` or `qTokens` are filtered further.
            If a result is also an instance of an already marked entity,
            the properties of that entity will be compared feature by feature with
            the allowed values that `valSelect` specifies for that feature.
        freeState: boolean, optional None
            If True, found occurrences may not intersect with already marked up
            features.
            If False, found occurrences must intersect with already marked up features.
        showStats: boolean, optional None
            Whether to show statistics of the find.
            If None, it only shows gross totals, if False, it shows nothing,
            if True, it shows totals by feature.

        Returns
        -------
        list of tuples
            For each bucket that passes the filter, a tuple with the following
            members is added to the list:

            *   tokens: the tokens of the bucket
            *   matches: the match positions of the found occurrences or entity
            *   positions: the token positions of where the text of the bucket
                starts matching the `bFindRe`

            If `browse` is True, also some stats are passed next to the list
            of results.
        &#34;&#34;&#34;
        settings = self.settings
        bucketType = settings.bucketType
        features = settings.features

        browse = self.browse
        app = self.app
        setData = self.getSetData()
        entityIndex = setData.entityIndex
        entityVal = setData.entityVal
        entitySlotVal = setData.entitySlotVal
        entitySlotAll = setData.entitySlotAll
        entitySlotIndex = setData.entitySlotIndex

        api = app.api
        L = api.L
        F = api.F
        T = api.T

        buckets = (
            setData.buckets or ()
            if node is None
            else L.d(T.sectionTuple(node)[1], otype=bucketType)
        )

        nFind = 0
        nEnt = {feat: collections.Counter() for feat in (&#34;&#34;,) + features}
        nVisible = {feat: collections.Counter() for feat in (&#34;&#34;,) + features}

        if bFindRe is None:
            if bFind is not None:
                (bFind, bFindRe, errorMsg) = findCompile(bFind, bFindC)
                if errorMsg:
                    app.error(errorMsg)

        hasEnt = eVals is not None
        hasQTokens = qTokens is not None and len(qTokens)
        hasOcc = not hasEnt and hasQTokens

        if eVals is not None:
            eSlots = entityVal[eVals]
            eStarts = {s[0]: s[-1] for s in eSlots}
        else:
            eStarts = None

        useQTokens = qTokens if hasOcc else None

        requireFree = (
            True if freeState == &#34;free&#34; else False if freeState == &#34;bound&#34; else None
        )

        results = []

        for b in buckets:
            fValStats = {feat: collections.Counter() for feat in features}
            (fits, result) = entityMatch(
                entityIndex,
                eStarts,
                entitySlotVal,
                entitySlotAll,
                entitySlotIndex,
                L,
                F,
                T,
                b,
                bFindRe,
                anyEnt,
                eVals,
                useQTokens,
                valSelect,
                requireFree,
                fValStats,
            )

            blocked = fits is not None and not fits

            if not blocked:
                nFind += 1

            for feat in features:
                theseStats = fValStats[feat]
                if len(theseStats):
                    theseNEnt = nEnt[feat]
                    theseNVisible = nVisible[feat]

                    for ek, n in theseStats.items():
                        theseNEnt[ek] += n
                        if not blocked:
                            theseNVisible[ek] += n

            nMatches = len(result[1])

            if nMatches:
                nEnt[&#34;&#34;][None] += nMatches
                if not blocked:
                    nVisible[&#34;&#34;][None] += nMatches

            if node is None:
                if fits is not None and not fits:
                    continue

                if (hasEnt or hasQTokens) and nMatches == 0:
                    continue

            results.append((b, *result))

        if browse:
            return (results, nFind, nVisible, nEnt)

        nResults = len(results)

        if showStats:
            pluralF = &#34;&#34; if nFind == 1 else &#34;s&#34;
            self.console(f&#34;{nFind} {bucketType}{pluralF} satisfy the filter&#34;)
            for feat in (&#34;&#34;,) + (() if anyEnt else features):
                if feat == &#34;&#34;:
                    self.console(&#34;Combined features match:&#34;)
                    for ek, n in sorted(nEnt[feat].items()):
                        v = nVisible[feat][ek]
                        self.console(f&#34;\t{v:&gt;5} of {n:&gt;5} x&#34;)
                else:
                    self.console(f&#34;Feature {feat}: found the following values:&#34;)
                    for ek, n in sorted(nEnt[feat].items()):
                        v = nVisible[feat][ek]
                        self.console(f&#34;\t{v:&gt;5} of {n:&gt;5} x {ek}&#34;)
        if showStats or showStats is None:
            pluralR = &#34;&#34; if nResults == 1 else &#34;s&#34;
            self.console(f&#34;{nResults} {bucketType}{pluralR}&#34;)
        return results</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tf.browser.ner.sets.Sets" href="sets.html#tf.browser.ner.sets.Sets">Sets</a></li>
<li><a title="tf.browser.ner.data.Data" href="data.html#tf.browser.ner.data.Data">Data</a></li>
<li><a title="tf.browser.ner.settings.Settings" href="settings.html#tf.browser.ner.settings.Settings">Settings</a></li>
<li><a title="tf.browser.ner.show.Show" href="show.html#tf.browser.ner.show.Show">Show</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tf.browser.ner.power.PowerNER" href="power.html#tf.browser.ner.power.PowerNER">PowerNER</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tf.browser.ner.annotate.Annotate.console"><code class="name flex">
<span>def <span class="ident">console</span></span>(<span>self, msg, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Print something to the output.</p>
<p>This works exactly as <code><a title="tf.core.helpers.console" href="../../core/helpers.html#tf.core.helpers.console">console()</a></code></p>
<p>It is handy to have this as a method on the Annotate object,
so that we can issue temporary console statements during development
without the need to add an <code>import</code> statement to the code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/annotate.py#L68-L77" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def console(self, msg, **kwargs):
    &#34;&#34;&#34;Print something to the output.

    This works exactly as `tf.core.helpers.console`

    It is handy to have this as a method on the Annotate object,
    so that we can issue temporary console statements during development
    without the need to add an `import` statement to the code.
    &#34;&#34;&#34;
    cs(msg, **kwargs)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.annotate.Annotate.filterContent"><code class="name flex">
<span>def <span class="ident">filterContent</span></span>(<span>self, node=None, bFind=None, bFindC=None, bFindRe=None, anyEnt=None, eVals=None, qTokens=None, valSelect=None, freeState=None, showStats=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter the buckets according to a variety of criteria.</p>
<p>Either the buckets of the whole corpus are filtered, or a subset of buckets,
namely those contained in a particular node.</p>
<p><strong>Bucket filtering</strong></p>
<p>The parameters <code>bFind</code>, <code>bFindC</code>, <code>bFindRe</code>
specify a regular expression
search on the texts of the buckets.</p>
<p>The positions of the found occurrences is included in the result.</p>
<p>The parameter <code>anyEnt</code> is a filter on the presence or absence of entities in
buckets in general.</p>
<p><strong>Entity filtering</strong></p>
<p>The parameter <code>eVals</code> holds the values of a specific entity to look for.</p>
<p><strong>Occurrence filtering</strong></p>
<p>The parameter <code>qTokens</code> is a sequence of tokens to look for.
The occurrences that are found, can be filtered further by <code>valSelect</code>
and <code>freeState</code>.</p>
<p>In entity filtering and occurrence filtering, the matching occurrences
are included in the result.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bFind</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>A search pattern that filters the buckets, before applying the search
for a token sequence.</dd>
<dt><strong><code>bFindC</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>Whether the search is case sensitive or not.</dd>
<dt><strong><code>bFindRe</code></strong> :&ensp;<code>object</code>, optional <code>None</code></dt>
<dd>A compiled regular expression.
This function searches on <code>bFindRe</code>, but if it is None, it compiles
<code>bFind</code> as regular expression and searches on that. If <code>bFind</code> itself
is not None, of course.</dd>
<dt><strong><code>anyEnt</code></strong> :&ensp;<code>boolean</code>, optional <code>None</code></dt>
<dd>If True, it wants all buckets that contain at least one already
marked entity; if False, it wants all buckets that do not contain any
already marked entity.</dd>
<dt><strong><code>eVals</code></strong> :&ensp;<code>tuple</code>, optional <code>None</code></dt>
<dd>A sequence of values corresponding with the entity features <code>eid</code>
and <code>kind</code>. If given, the function wants buckets that contain at least
an entity with those properties.</dd>
<dt><strong><code>qTokens</code></strong> :&ensp;<code>tuple</code>, optional <code>None</code></dt>
<dd>A sequence of tokens whose occurrences in the corpus will be looked up.</dd>
<dt><strong><code>valSelect</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>
<p>If present, the keys are the entity features (<code>eid</code> and <code>kind</code>),
and the values are iterables of values that are allowed.</p>
<p>The feature values to filter on.
The results of searching for <code>eVals</code> or <code>qTokens</code> are filtered further.
If a result is also an instance of an already marked entity,
the properties of that entity will be compared feature by feature with
the allowed values that <code>valSelect</code> specifies for that feature.</p>
</dd>
<dt><strong><code>freeState</code></strong> :&ensp;<code>boolean</code>, optional <code>None</code></dt>
<dd>If True, found occurrences may not intersect with already marked up
features.
If False, found occurrences must intersect with already marked up features.</dd>
<dt><strong><code>showStats</code></strong> :&ensp;<code>boolean</code>, optional <code>None</code></dt>
<dd>Whether to show statistics of the find.
If None, it only shows gross totals, if False, it shows nothing,
if True, it shows totals by feature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>tuples</code></dt>
<dd>
<p>For each bucket that passes the filter, a tuple with the following
members is added to the list:</p>
<ul>
<li>tokens: the tokens of the bucket</li>
<li>matches: the match positions of the found occurrences or entity</li>
<li>positions: the token positions of where the text of the bucket
starts matching the <code>bFindRe</code></li>
</ul>
<p>If <code>browse</code> is True, also some stats are passed next to the list
of results.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/annotate.py#L114-L336" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def filterContent(
    self,
    node=None,
    bFind=None,
    bFindC=None,
    bFindRe=None,
    anyEnt=None,
    eVals=None,
    qTokens=None,
    valSelect=None,
    freeState=None,
    showStats=None,
):
    &#34;&#34;&#34;Filter the buckets according to a variety of criteria.

    Either the buckets of the whole corpus are filtered, or a subset of buckets,
    namely those contained in a particular node.

    **Bucket filtering**

    The parameters `bFind`, `bFindC`, `bFindRe`  specify a regular expression
    search on the texts of the buckets.

    The positions of the found occurrences is included in the result.

    The parameter `anyEnt` is a filter on the presence or absence of entities in
    buckets in general.

    **Entity filtering**

    The parameter `eVals` holds the values of a specific entity to look for.

    **Occurrence filtering**

    The parameter `qTokens` is a sequence of tokens to look for.
    The occurrences that are found, can be filtered further by `valSelect`
    and `freeState`.

    In entity filtering and occurrence filtering, the matching occurrences
    are included in the result.

    Parameters
    ----------
    bFind: string, optional None
        A search pattern that filters the buckets, before applying the search
        for a token sequence.
    bFindC: string, optional None
        Whether the search is case sensitive or not.
    bFindRe: object, optional None
        A compiled regular expression.
        This function searches on `bFindRe`, but if it is None, it compiles
        `bFind` as regular expression and searches on that. If `bFind` itself
        is not None, of course.
    anyEnt: boolean, optional None
        If True, it wants all buckets that contain at least one already
        marked entity; if False, it wants all buckets that do not contain any
        already marked entity.
    eVals: tuple, optional None
        A sequence of values corresponding with the entity features `eid`
        and `kind`. If given, the function wants buckets that contain at least
        an entity with those properties.
    qTokens: tuple, optional None
        A sequence of tokens whose occurrences in the corpus will be looked up.
    valSelect: dict, optional None
        If present, the keys are the entity features (`eid` and `kind`),
        and the values are iterables of values that are allowed.

        The feature values to filter on.
        The results of searching for `eVals` or `qTokens` are filtered further.
        If a result is also an instance of an already marked entity,
        the properties of that entity will be compared feature by feature with
        the allowed values that `valSelect` specifies for that feature.
    freeState: boolean, optional None
        If True, found occurrences may not intersect with already marked up
        features.
        If False, found occurrences must intersect with already marked up features.
    showStats: boolean, optional None
        Whether to show statistics of the find.
        If None, it only shows gross totals, if False, it shows nothing,
        if True, it shows totals by feature.

    Returns
    -------
    list of tuples
        For each bucket that passes the filter, a tuple with the following
        members is added to the list:

        *   tokens: the tokens of the bucket
        *   matches: the match positions of the found occurrences or entity
        *   positions: the token positions of where the text of the bucket
            starts matching the `bFindRe`

        If `browse` is True, also some stats are passed next to the list
        of results.
    &#34;&#34;&#34;
    settings = self.settings
    bucketType = settings.bucketType
    features = settings.features

    browse = self.browse
    app = self.app
    setData = self.getSetData()
    entityIndex = setData.entityIndex
    entityVal = setData.entityVal
    entitySlotVal = setData.entitySlotVal
    entitySlotAll = setData.entitySlotAll
    entitySlotIndex = setData.entitySlotIndex

    api = app.api
    L = api.L
    F = api.F
    T = api.T

    buckets = (
        setData.buckets or ()
        if node is None
        else L.d(T.sectionTuple(node)[1], otype=bucketType)
    )

    nFind = 0
    nEnt = {feat: collections.Counter() for feat in (&#34;&#34;,) + features}
    nVisible = {feat: collections.Counter() for feat in (&#34;&#34;,) + features}

    if bFindRe is None:
        if bFind is not None:
            (bFind, bFindRe, errorMsg) = findCompile(bFind, bFindC)
            if errorMsg:
                app.error(errorMsg)

    hasEnt = eVals is not None
    hasQTokens = qTokens is not None and len(qTokens)
    hasOcc = not hasEnt and hasQTokens

    if eVals is not None:
        eSlots = entityVal[eVals]
        eStarts = {s[0]: s[-1] for s in eSlots}
    else:
        eStarts = None

    useQTokens = qTokens if hasOcc else None

    requireFree = (
        True if freeState == &#34;free&#34; else False if freeState == &#34;bound&#34; else None
    )

    results = []

    for b in buckets:
        fValStats = {feat: collections.Counter() for feat in features}
        (fits, result) = entityMatch(
            entityIndex,
            eStarts,
            entitySlotVal,
            entitySlotAll,
            entitySlotIndex,
            L,
            F,
            T,
            b,
            bFindRe,
            anyEnt,
            eVals,
            useQTokens,
            valSelect,
            requireFree,
            fValStats,
        )

        blocked = fits is not None and not fits

        if not blocked:
            nFind += 1

        for feat in features:
            theseStats = fValStats[feat]
            if len(theseStats):
                theseNEnt = nEnt[feat]
                theseNVisible = nVisible[feat]

                for ek, n in theseStats.items():
                    theseNEnt[ek] += n
                    if not blocked:
                        theseNVisible[ek] += n

        nMatches = len(result[1])

        if nMatches:
            nEnt[&#34;&#34;][None] += nMatches
            if not blocked:
                nVisible[&#34;&#34;][None] += nMatches

        if node is None:
            if fits is not None and not fits:
                continue

            if (hasEnt or hasQTokens) and nMatches == 0:
                continue

        results.append((b, *result))

    if browse:
        return (results, nFind, nVisible, nEnt)

    nResults = len(results)

    if showStats:
        pluralF = &#34;&#34; if nFind == 1 else &#34;s&#34;
        self.console(f&#34;{nFind} {bucketType}{pluralF} satisfy the filter&#34;)
        for feat in (&#34;&#34;,) + (() if anyEnt else features):
            if feat == &#34;&#34;:
                self.console(&#34;Combined features match:&#34;)
                for ek, n in sorted(nEnt[feat].items()):
                    v = nVisible[feat][ek]
                    self.console(f&#34;\t{v:&gt;5} of {n:&gt;5} x&#34;)
            else:
                self.console(f&#34;Feature {feat}: found the following values:&#34;)
                for ek, n in sorted(nEnt[feat].items()):
                    v = nVisible[feat][ek]
                    self.console(f&#34;\t{v:&gt;5} of {n:&gt;5} x {ek}&#34;)
    if showStats or showStats is None:
        pluralR = &#34;&#34; if nResults == 1 else &#34;s&#34;
        self.console(f&#34;{nResults} {bucketType}{pluralR}&#34;)
    return results</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.annotate.Annotate.findOccs"><code class="name flex">
<span>def <span class="ident">findOccs</span></span>(<span>self, qTokenSet=set())</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the occurrences of multiple sequences of tokens.</p>
<p>This is meant to efficiently list all occurrences of many token
sequences in the corpus.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>qTokenSet</code></strong> :&ensp;<code>set</code>, optional <code>set()</code></dt>
<dd>A set of sequences of tokens. Each sequence in the set will be used as a
search pattern in the whole corpus, and it occurrences are collected.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Keyed by each member of parameter <code>qTokenSet</code> the values are
the occurrences of that member in the corpus.
A single occurrence is represented as a tuple of slots.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/annotate.py#L79-L112" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findOccs(self, qTokenSet=set()):
    &#34;&#34;&#34;Finds the occurrences of multiple sequences of tokens.

    This is meant to efficiently list all occurrences of many token
    sequences in the corpus.

    Parameters
    ----------
    qTokenSet: set, optional set()
        A set of sequences of tokens. Each sequence in the set will be used as a
        search pattern in the whole corpus, and it occurrences are collected.

    Returns
    -------
    dict
        Keyed by each member of parameter `qTokenSet` the values are
        the occurrences of that member in the corpus.
        A single occurrence is represented as a tuple of slots.

    &#34;&#34;&#34;
    app = self.app
    setData = self.getSetData()
    api = app.api
    L = api.L
    F = api.F

    buckets = setData.buckets or ()

    results = {}

    for b in buckets:
        occMatch(L, F, b, qTokenSet, results)

    return results</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tf.browser.ner.sets.Sets" href="sets.html#tf.browser.ner.sets.Sets">Sets</a></b></code>:
<ul class="hlist">
<li><code><a title="tf.browser.ner.sets.Sets.loadData" href="data.html#tf.browser.ner.data.Data.loadData">loadData</a></code></li>
</ul>
</li>
<li><code><b><a title="tf.browser.ner.show.Show" href="show.html#tf.browser.ner.show.Show">Show</a></b></code>:
<ul class="hlist">
<li><code><a title="tf.browser.ner.show.Show.showEntityOverview" href="show.html#tf.browser.ner.show.Show.showEntityOverview">showEntityOverview</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.browser.ner" href="index.html">tf.browser.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.browser.ner.annotate.Annotate" href="#tf.browser.ner.annotate.Annotate">Annotate</a></code></h4>
<ul class="">
<li><code><a title="tf.browser.ner.annotate.Annotate.console" href="#tf.browser.ner.annotate.Annotate.console">console</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.filterContent" href="#tf.browser.ner.annotate.Annotate.filterContent">filterContent</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.findOccs" href="#tf.browser.ner.annotate.Annotate.findOccs">findOccs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>