<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.browser.ner.triggers API documentation</title>
<meta name="description" content="" />
<!-- integrity SRI from https://cdnjs.com/libraries/10up-sanitize.css/11.0.1 -->
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha512-kcbluZFacWN57NgWZ4aH6eUMBEaTyErFhIFD3y5qYZbKuuyImH0K/AKsBbfXlivh2z5C+3IDTIhI11YmKomzmA=="
crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha512-uVeAgzAmieLUTGba0qr9vXQgVD7fko2kcbYIKIraXUIDg9iJLxveTFUrg3DJhqn3cAf3HFDbgmhq0eGko5wEAA=="
crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.browser.ner.triggers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/a7d9f3f5a3ce7e037e0fa8fa92427aab66ddd523/tf/browser/ner/triggers.py#L1-L623" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import collections
import re

from .helpers import tnorm, normalize, toId, toSmallId, toTokens, log
from ...core.helpers import console
from ...core.files import dirContents


DS_STORE = &#34;.DS_Store&#34;
SHEET_RE = re.compile(r&#34;&#34;&#34;^([0-9]+)((?:-[0-9]+)?)\.xlsx$&#34;&#34;&#34;, re.I)


class Triggers:
    def __init__(self, Ner):
        self.loadXls = Ner.load_workbook
        self.sheetDir = Ner.sheetDir
        self.reportDir = Ner.reportDir
        settings = Ner.settings
        self.spaceEscaped = settings.spaceEscaped
        self.transform = settings.transform
        keywordFeatures = settings.keywordFeatures
        kindFeature = keywordFeatures[0]
        self.kindFeature = kindFeature
        defaultValues = settings.defaultValues
        self.defaultKind = defaultValues.get(kindFeature, &#34;&#34;)

        self.nameMap = {}
        &#34;&#34;&#34;Will contain a mapping from entities to names.

        The entities are keyed by their (eid, kind) tuple.
        The values are names plus the sheet where they are first defined.
        &#34;&#34;&#34;

        self.instructions = None
        &#34;&#34;&#34;Will contain the information in a spreadsheet for marking up entities.&#34;&#34;&#34;

    def intake(self, sheetName):
        &#34;&#34;&#34;Read the spreadsheets and translate them in actionable data for search.

        Parameters
        ----------
        sheetName: string
            The base name of the sheet, without extension.
            It is assume that a spreadsheet with that name and extension `.xlsx` exists
            in the expected location.

            Next to it a subdirectory of the same name may exist, which contains
            additional spreadsheets and subdirectories that contain
            increasingly specific tweaks on top of the base spreadsheet.
        &#34;&#34;&#34;
        self.sheetName = sheetName
        self.read()
        self.combine()
        self.compile()
        self.prepare()

    def read(self):
        &#34;&#34;&#34;Read all the spreadsheets, the main one and the tweaks.

        Store the results in a hierarchy that mimicks the way they are organized in the
        file system.
        &#34;&#34;&#34;
        sheetName = self.sheetName
        sheetDir = self.sheetDir
        loadXls = self.loadXls
        defaultKind = self.defaultKind
        transform = self.transform
        nameMap = self.nameMap
        spaceEscaped = self.spaceEscaped

        reportDir = self.reportDir
        reportFile = f&#34;{reportDir}/read.txt&#34;
        rh = open(reportFile, &#34;w&#34;)
        log(rh, &#34;Reading the spreadsheets&#34;)

        def readXls(sheetRela):
            sep = &#34;/&#34; if sheetRela else &#34;&#34;
            sheetRep = f&#34;[{sheetRela}]&#34;

            sheetPath = f&#34;{sheetDir}/{sheetName}{sep}{sheetRela}.xlsx&#34;

            wb = loadXls(sheetPath, data_only=True)
            ws = wb.active

            (headRow, subHeadRow, *rows) = list(ws.rows)
            rows = [row for row in rows if any(c.value for c in row)]

            sheet = {}

            idFirstRow = {}

            for r, row in enumerate(ws.rows):
                if r in {0, 1}:
                    continue
                if not any(c.value for c in row):
                    continue

                (name, kind, triggerStr) = (
                    normalize(row[i].value or &#34;&#34;) for i in range(3)
                )
                triggers = (
                    set()
                    if not triggerStr
                    else {
                        y
                        for x in triggerStr.split(&#34;;&#34;)
                        if (y := tnorm(x, spaceEscaped=spaceEscaped)) != &#34;&#34;
                    }
                )
                if not name:
                    name = list(triggers)[0] if triggers else &#34;&#34;
                    if name == &#34;&#34;:
                        if kind:
                            log(
                                rh,
                                f&#34;{sheetRep} row {r + 1:&gt;3}: {kind}: &#34;
                                &#34;no entity name and no triggers&#34;,
                            )
                        continue
                    else:
                        log(
                            rh,
                            f&#34;{sheetRep} row {r + 1:&gt;3}: {kind}: &#34;
                            f&#34;no entity name, supplied synonym {name}&#34;,
                        )

                if not kind:
                    kind = defaultKind
                    log(
                        rh,
                        f&#34;{sheetRep} row {r + 1:&gt;3}: &#34;
                        f&#34;no kind name, supplied {defaultKind}&#34;,
                    )

                eid = toSmallId(name, transform=transform)
                eidkind = (eid, kind)
                firstRowEid = idFirstRow.get((eidkind), None)

                if firstRowEid is None:
                    idFirstRow[eidkind] = (r, name)
                    sheet[eidkind] = triggers

                    prev = nameMap.get(eidkind, None)

                    if prev is None:
                        nameMap[eidkind] = (name, sheetRela)
                    else:
                        (prevName, prevSheet) = prev

                        if prevName != name:
                            if toId(prevName) == toId(name):
                                severity = &#34;minor&#34;
                                error = False
                            else:
                                severity = &#34;major&#34;
                                error = True

                            log(
                                rh,
                                f&#34;{sheetRep} {severity} name variant for {eidkind}:\n&#34;
                                f&#34;  in {prevSheet:&lt;30} : &#39;{prevName}&#39;\n&#34;
                                f&#34;  in {sheetRep:&lt;30} : &#39;{name}&#39;&#34;,
                                error=error,
                            )
                            log(rh, f&#34;  will use &#39;{prevName}&#39; for {eidkind}&#34;)

                else:
                    (firstRow, firstName) = firstRowEid
                    if firstName == name:
                        severity = &#34;identical&#34;
                        error = False
                    elif toId(firstName) == toId(name):
                        severity = &#34;minor variant in&#34;
                        error = False
                    else:
                        severity = &#34;major variant in&#34;
                        error = True

                    log(
                        rh,
                        f&#34;{sheetRep} {severity} name for {eidkind}:\n&#34;
                        f&#34;  in {firstRow + 1:&lt;3} : &#39;{firstName}&#39;\n&#34;
                        f&#34;  in {r + 1:&lt;3} : &#39;{name}&#39;\n&#34;,
                        error=error,
                    )
                    log(rh, f&#34;  will merge triggers {triggers} with {sheet[eidkind]}&#34;)
                    sheet[eidkind] |= triggers

            return sheet

        def readDir(sheetRela, level):
            sheetRep = f&#34;[{sheetRela}]&#34;
            sep = &#34;/&#34; if sheetRela else &#34;&#34;

            (files, dirs) = dirContents(f&#34;{sheetDir}/{sheetName}{sep}{sheetRela}&#34;)

            sheetSingle = {}
            sheetRange = {}

            for file in files:
                if file == DS_STORE:
                    continue

                match = SHEET_RE.match(file)
                if not match:
                    log(rh, f&#34;{sheetRep} contains unrecognized file {file}&#34;)
                    continue

                (start, end) = match.group(1, 2)
                fileBase = f&#34;{start}{end}&#34;

                start = int(start)
                end = int(end[1:]) if end else None
                key = start if end is None else (start, end)

                sheetDest = sheetSingle if end is None else sheetRange
                sheetDest[key] = readXls(f&#34;{sheetRela}/{fileBase}&#34;)

            sheetSubdirs = {}

            for dr in dirs:
                if level &gt;= 3:
                    log(rh, f&#34;{sheetRep} is at max depth, yet contains subdir {dr}&#34;)
                    continue

                if not dr.isdecimal():
                    log(rh, f&#34;{sheetRep} contains non-numeric subdir {dr}&#34;)
                    continue

                sheetSubdirs[int(dr)] = readDir(f&#34;{sheetRela}{sep}{dr}&#34;, level + 1)

            return dict(sng=sheetSingle, rng=sheetRange, sdr=sheetSubdirs)

        sheetMain = readXls(&#34;&#34;)
        sheetSubdirs = readDir(&#34;&#34;, 1)
        self.raw = dict(main=sheetMain, sdr=sheetSubdirs)
        rh.close()

    def combine(self):
        &#34;&#34;&#34;Combines the spreadsheet info in single-section spreadsheets.

        Among the tweaks, there may be *ranged* spreadsheets, i.e. having the name
        *start*`-`*end*, which indicate that they contain tweaks for sections
        *start* to *end*. These will be converted to individual spreadsheet
        *start*, *start + 1*, ..., *end - 1*, *end*.
        &#34;&#34;&#34;
        raw = self.raw

        sheetMain = raw[&#34;main&#34;]
        sheetTweaked = raw[&#34;sdr&#34;]

        # combine the info in ranged sheets into single number sheets

        combined = dict(sheet=sheetMain, tweaks={})
        self.combined = combined

        console(&#34;Combining the spreadsheets&#34;)

        def combineDir(data, dest):
            ranged = data.get(&#34;rng&#34;, {})
            single = data.get(&#34;sng&#34;, {})
            subdirs = data.get(&#34;sdr&#34;, {})

            for (start, end), sheet in sorted(ranged.items()):
                for i in range(start, end + 1):
                    updateDest = dest.setdefault(i, {}).setdefault(&#34;sheet&#34;, {})
                    for eidkind, triggers in sheet.items():
                        updateDest[eidkind] = triggers

            for i, sheet in single.items():
                updateDest = dest.setdefault(i, {}).setdefault(&#34;sheet&#34;, {})
                for eidkind, triggers in sheet.items():
                    updateDest[eidkind] = triggers

            for i, tweaks in subdirs.items():
                updateDest = dest.setdefault(i, {}).setdefault(&#34;tweaks&#34;, {})
                combineDir(tweaks, updateDest)

        combineDir(sheetTweaked, combined[&#34;tweaks&#34;])

    def compile(self):
        &#34;&#34;&#34;Compiles the info in tweaked sheets into complete sheets.

        For every tweak spreadsheet, a copy of its parent sheet will be made,
        and the info of the tweak sheet will be applied to that copy,
        adding to or overriding the parent sheet.

        A sheet is basically a mapping of triggers to names.

        We also maintain a mapping from tweak sheets to triggers, so that we can
        know later on which sheet assigned which trigger to which name.

        The tweak may remove triggers from the sheet. We have to adapt the tMap
        for that.
        &#34;&#34;&#34;

        combined = self.combined

        compiled = {}
        self.compiled = compiled

        console(&#34;Compiling the spreadsheets&#34;)

        def compileSheet(path, parentData, data, dest):
            parentSheet = parentData[&#34;sheet&#34;]
            sheet = data[&#34;sheet&#34;]
            newSheet = {}
            dest[&#34;sheet&#34;] = newSheet
            parentTMap = parentData.get(&#34;tMap&#34;, {})
            newTMap = {}
            dest[&#34;tMap&#34;] = newTMap

            for eidkind, triggers in parentSheet.items():
                newSheet[eidkind] = triggers

            for eidkind, triggers in sheet.items():
                newSheet[eidkind] = triggers

                for trigger in triggers:
                    newTMap[trigger] = tuple(str(k) for k in path)

            for eidkind, triggers in newSheet.items():
                for trigger in triggers:
                    if trigger not in newTMap:
                        newTMap[trigger] = parentTMap[trigger]

        def compileDir(path, parentData, data, dest):
            if &#34;sheet&#34; in data:
                compileSheet(path, parentData, data, dest)
                parentData = dict(sheet=dest[&#34;sheet&#34;], tMap=dest[&#34;tMap&#34;])

            tweaks = data.get(&#34;tweaks&#34;, {})
            tweakDest = dest.setdefault(&#34;tweaks&#34;, {})

            for k in sorted(tweaks):
                compileDir(
                    path + (k,), parentData, tweaks[k], tweakDest.setdefault(k, {})
                )

        compileDir((), combined, combined, compiled)

    def prepare(self):
        &#34;&#34;&#34;Transform the sheets into instructions.

        Now we have complete sheets for every context, the inheritance is resolved.
        Every sheet specifies a mapping from triggers to names, and remembers
        which (possibly other) sheet mapped a specific trigger to its name.

        We perform additional checks on the consistency and completeness of the
        resulting sheets.

        Then we generate instructions out of the sheets: data that the search
        algorithm needs to do its work.

        For each path to tweaked sheet we collect a portion of data:

        *   `tPos`: a compilation of all triggers in the sheet, so that
            we can search for them simultaneously;
        *   `tMap`: a mapping from triggers to the path of the sheet that defined this
            trigger;
        *   `idMap`: a mapping from triggers their corresponding entities.

        So every portion of data is addressed by a `path` key. This key is a tuple
        of section/subsection/subsubsection heading.

        By means of this key we can select the proper search instructions for specific
        parts of the corpus.

        About reporting:

        We report the entities without triggers.
        When we report the tweaks, only those triggerless entities are reported that
        were not already triggerless in the main sheet.

        We report the ambiguus triggers.
        When we report the tweaks, only those triggers that are redefined in that tweak
        are reported.
        &#34;&#34;&#34;

        spaceEscaped = self.spaceEscaped
        nameMap = self.nameMap
        compiled = self.compiled

        instructions = {}
        self.instructions = instructions

        reportDir = self.reportDir
        reportFile = f&#34;{reportDir}/check.tsv&#34;

        console(&#34;Checking the spreadsheets&#34;)

        checkData = [&#34;sheet\tentities\tnotriggers\ttriggers\tambiguous\n&#34;]
        ambiData = []
        notrigData = []

        mainNotrigData = set()

        def prepareSheet(path, info):
            isMain = len(path) == 0
            sheet = info[&#34;sheet&#34;]
            tMap = info[&#34;tMap&#34;]
            sheetR = &#34;.&#34;.join(path)
            sheetRep = f&#34;[{sheetR}]&#34;

            triggerSet = set()
            tPos = collections.defaultdict(lambda: collections.defaultdict(set))
            idMap = collections.defaultdict(list)

            data = dict(tPos=tPos, tMap=tMap)

            instructions[path] = data

            for eidkind, triggers in sheet.items():
                if len(triggers) == 0:
                    name = nameMap[eidkind][0]

                    if isMain:
                        mainNotrigData.add(name)
                    else:
                        if name not in mainNotrigData:
                            notrigData.append((name, sheetR))

                for trigger in triggers:
                    triggerT = toTokens(trigger, spaceEscaped=spaceEscaped)
                    triggerSet.add(triggerT)
                    idMap[trigger].append(eidkind)

            for triggerT in triggerSet:
                for i, token in enumerate(triggerT):
                    tPos[i][token].add(triggerT)

            data[&#34;idMap&#34;] = {
                trigger: eidkinds[0] for (trigger, eidkinds) in idMap.items()
            }

            nEnt = len(sheet)
            nTriggers = sum(len(triggers) for triggers in sheet.values())
            noTriggers = sum(1 for triggers in sheet.values() if len(triggers) == 0)
            noTrigMsg = &#34;&#34; if noTriggers == 0 else f&#34;, {noTriggers} without triggers;&#34;

            ambi = 0
            msgs = []

            for trigger, eidkinds in sorted(idMap.items()):
                if len(eidkinds) &lt;= 1:
                    continue

                tPath = tMap[trigger]

                if path != tPath:
                    continue

                msgs.append(f&#34;&#34;&#34;  trigger &#39;{trigger}&#39; used for:&#34;&#34;&#34;)

                for eidkind in eidkinds:
                    name = nameMap[eidkind][0]
                    msgs.append(f&#34;\t{name}&#34;)

                    ambiData.append((trigger, sheetR, name))

                ambi += 1

            ambiMsg = &#34;&#34; if ambi == 0 else f&#34;, {ambi} ambiguous&#34;

            entMsg = f&#34;entities: {nEnt} {noTrigMsg}&#34;
            triggerMsg = f&#34;triggers: {nTriggers} {ambiMsg}&#34;

            console(f&#34;{sheetRep:&lt;25}: {entMsg:&lt;35} {triggerMsg}&#34;)

            if len(msgs):
                console(&#34;\n&#34;.join(msgs))

            checkData.append(f&#34;{sheetR}\t{nEnt}\t{noTriggers}\t{nTriggers}\t{ambi}\n&#34;)

        def prepareDir(path, data):
            if &#34;sheet&#34; in data:
                prepareSheet(path, data)

            tweaks = data.get(&#34;tweaks&#34;, {})

            for k in sorted(tweaks):
                prepareDir(path + (str(k),), tweaks[k])

        prepareDir((), compiled)

        with open(reportFile, &#34;w&#34;) as rh:
            for c in checkData:
                rh.write(c)

        notrigFile = f&#34;{reportDir}/notriggers.tsv&#34;

        with open(notrigFile, &#34;w&#34;) as nh:
            nh.write(&#34;name\tsheet\n&#34;)

            for name in sorted(mainNotrigData):
                nh.write(f&#34;{name}\t\n&#34;)
            for (name, sheet) in sorted(notrigData):
                nh.write(f&#34;{name}\t{sheet}\n&#34;)

        ambiFile = f&#34;{reportDir}/ambitriggers.tsv&#34;

        with open(ambiFile, &#34;w&#34;) as ah:
            ah.write(&#34;trigger\tname\tsheet\n&#34;)

            for (trigger, sheet, name) in sorted(ambiData):
                ah.write(f&#34;{trigger}\t{sheet}\t{name}\n&#34;)

    def showRaw(self, main=False):
        nameMap = self.nameMap
        src = self.raw

        def showSheet(sheet, tab):
            for eidkind, triggers in sorted(sheet.items()):
                (name, sheetRela) = nameMap[eidkind]
                triggerRep = &#34;|&#34;.join(
                    t for t in sorted(triggers, key=lambda x: (-len(x), x))
                )
                console(f&#34;{tab}  &#39;{name}&#39; {eidkind} : {triggerRep}&#34;)
            console(f&#34;{tab}  ---&#34;)

        def showDir(head, tweaks, level):
            tab = &#34;  &#34; * level
            console(f&#34;{tab}{head}&#34;)

            rng = tweaks.get(&#34;rng&#34;, {})
            for b, e in sorted(rng):
                console(f&#34;{tab}  {b}-{e}.xslx&#34;)
                showSheet(rng[(b, e)], tab)

            sng = tweaks.get(&#34;sng&#34;, {})
            for k in sorted(sng):
                console(f&#34;{tab}  {k}.xslx&#34;)
                showSheet(sng[k], tab)

            sdr = tweaks.get(&#34;sdr&#34;, {})

            for k in sorted(sdr):
                showDir(k, sdr[k], level + 1)

        if main:
            showSheet(src[&#34;main&#34;], &#34;&#34;)

        showDir(&#34;&#34;, src[&#34;sdr&#34;], 0)

    def showCombined(self, main=False):
        nameMap = self.nameMap
        src = self.combined

        def showSheet(sheet, tab):
            for eidkind, triggers in sorted(sheet.items()):
                (name, sheetRela) = nameMap[eidkind]
                triggerRep = &#34;|&#34;.join(
                    t for t in sorted(triggers, key=lambda x: (-len(x), x))
                )
                console(f&#34;{tab}  &#39;{name}&#39; {eidkind} : {triggerRep}&#34;)
            console(f&#34;{tab}  ---&#34;)

        def showDir(head, data, level):
            tab = &#34;  &#34; * level
            console(f&#34;{tab}{head}&#34;)

            if &#34;sheet&#34; in data:
                if main or level &gt; 0:
                    showSheet(data[&#34;sheet&#34;], tab)

            tweaks = data.get(&#34;tweaks&#34;, {})

            for k in sorted(tweaks):
                showDir(k, tweaks[k], level + 1)

        showDir(&#34;&#34;, src, 0)

    def showCompiled(self, main=False):
        nameMap = self.nameMap
        src = self.compiled

        def showSheet(data, tab):
            sheet = data[&#34;sheet&#34;]
            tMap = data[&#34;tMap&#34;]

            for eidkind, triggers in sorted(sheet.items()):
                triggerSources = {tMap[t] for t in triggers}
                nTriggers = len(triggers)

                if not main and (nTriggers == 0 or triggerSources == {()}):
                    continue

                (name, sheetRela) = nameMap[eidkind]

                if nTriggers == 0:
                    triggerInfo = &#34;X&#34;
                else:
                    sourceRep = (
                        &#34;X&#34;
                        if len(triggerSources) == 0
                        else list(list(triggerSources)[0])
                    )
                    triggerRep = &#34;|&#34;.join(
                        t for t in sorted(triggers, key=lambda x: (-len(x), x))
                    )
                    triggerInfo = f&#34;{sourceRep} =&gt; {triggerRep}&#34;

                console(f&#34;{tab}  &#39;{name}&#39; {eidkind} : {triggerInfo}&#34;)
            console(f&#34;{tab}  ---&#34;)

        def showDir(head, data, level):
            tab = &#34;  &#34; * level
            console(f&#34;{tab}{head}&#34;)

            if &#34;sheet&#34; in data:
                if main or level &gt; 0:
                    showSheet(data, tab)

            tweaks = data.get(&#34;tweaks&#34;, {})

            for k in sorted(tweaks):
                showDir(k, tweaks[k], level + 1)

        showDir(&#34;&#34;, src, 0)

    def showInstructions(self):
        instructions = self.instructions
        console(&#34;\n&#34;.join(f&#34;{path}&#34; for path in instructions))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.browser.ner.triggers.Triggers"><code class="flex name class">
<span>class <span class="ident">Triggers</span></span>
<span>(</span><span>Ner)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/a7d9f3f5a3ce7e037e0fa8fa92427aab66ddd523/tf/browser/ner/triggers.py#L13-L623" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Triggers:
    def __init__(self, Ner):
        self.loadXls = Ner.load_workbook
        self.sheetDir = Ner.sheetDir
        self.reportDir = Ner.reportDir
        settings = Ner.settings
        self.spaceEscaped = settings.spaceEscaped
        self.transform = settings.transform
        keywordFeatures = settings.keywordFeatures
        kindFeature = keywordFeatures[0]
        self.kindFeature = kindFeature
        defaultValues = settings.defaultValues
        self.defaultKind = defaultValues.get(kindFeature, &#34;&#34;)

        self.nameMap = {}
        &#34;&#34;&#34;Will contain a mapping from entities to names.

        The entities are keyed by their (eid, kind) tuple.
        The values are names plus the sheet where they are first defined.
        &#34;&#34;&#34;

        self.instructions = None
        &#34;&#34;&#34;Will contain the information in a spreadsheet for marking up entities.&#34;&#34;&#34;

    def intake(self, sheetName):
        &#34;&#34;&#34;Read the spreadsheets and translate them in actionable data for search.

        Parameters
        ----------
        sheetName: string
            The base name of the sheet, without extension.
            It is assume that a spreadsheet with that name and extension `.xlsx` exists
            in the expected location.

            Next to it a subdirectory of the same name may exist, which contains
            additional spreadsheets and subdirectories that contain
            increasingly specific tweaks on top of the base spreadsheet.
        &#34;&#34;&#34;
        self.sheetName = sheetName
        self.read()
        self.combine()
        self.compile()
        self.prepare()

    def read(self):
        &#34;&#34;&#34;Read all the spreadsheets, the main one and the tweaks.

        Store the results in a hierarchy that mimicks the way they are organized in the
        file system.
        &#34;&#34;&#34;
        sheetName = self.sheetName
        sheetDir = self.sheetDir
        loadXls = self.loadXls
        defaultKind = self.defaultKind
        transform = self.transform
        nameMap = self.nameMap
        spaceEscaped = self.spaceEscaped

        reportDir = self.reportDir
        reportFile = f&#34;{reportDir}/read.txt&#34;
        rh = open(reportFile, &#34;w&#34;)
        log(rh, &#34;Reading the spreadsheets&#34;)

        def readXls(sheetRela):
            sep = &#34;/&#34; if sheetRela else &#34;&#34;
            sheetRep = f&#34;[{sheetRela}]&#34;

            sheetPath = f&#34;{sheetDir}/{sheetName}{sep}{sheetRela}.xlsx&#34;

            wb = loadXls(sheetPath, data_only=True)
            ws = wb.active

            (headRow, subHeadRow, *rows) = list(ws.rows)
            rows = [row for row in rows if any(c.value for c in row)]

            sheet = {}

            idFirstRow = {}

            for r, row in enumerate(ws.rows):
                if r in {0, 1}:
                    continue
                if not any(c.value for c in row):
                    continue

                (name, kind, triggerStr) = (
                    normalize(row[i].value or &#34;&#34;) for i in range(3)
                )
                triggers = (
                    set()
                    if not triggerStr
                    else {
                        y
                        for x in triggerStr.split(&#34;;&#34;)
                        if (y := tnorm(x, spaceEscaped=spaceEscaped)) != &#34;&#34;
                    }
                )
                if not name:
                    name = list(triggers)[0] if triggers else &#34;&#34;
                    if name == &#34;&#34;:
                        if kind:
                            log(
                                rh,
                                f&#34;{sheetRep} row {r + 1:&gt;3}: {kind}: &#34;
                                &#34;no entity name and no triggers&#34;,
                            )
                        continue
                    else:
                        log(
                            rh,
                            f&#34;{sheetRep} row {r + 1:&gt;3}: {kind}: &#34;
                            f&#34;no entity name, supplied synonym {name}&#34;,
                        )

                if not kind:
                    kind = defaultKind
                    log(
                        rh,
                        f&#34;{sheetRep} row {r + 1:&gt;3}: &#34;
                        f&#34;no kind name, supplied {defaultKind}&#34;,
                    )

                eid = toSmallId(name, transform=transform)
                eidkind = (eid, kind)
                firstRowEid = idFirstRow.get((eidkind), None)

                if firstRowEid is None:
                    idFirstRow[eidkind] = (r, name)
                    sheet[eidkind] = triggers

                    prev = nameMap.get(eidkind, None)

                    if prev is None:
                        nameMap[eidkind] = (name, sheetRela)
                    else:
                        (prevName, prevSheet) = prev

                        if prevName != name:
                            if toId(prevName) == toId(name):
                                severity = &#34;minor&#34;
                                error = False
                            else:
                                severity = &#34;major&#34;
                                error = True

                            log(
                                rh,
                                f&#34;{sheetRep} {severity} name variant for {eidkind}:\n&#34;
                                f&#34;  in {prevSheet:&lt;30} : &#39;{prevName}&#39;\n&#34;
                                f&#34;  in {sheetRep:&lt;30} : &#39;{name}&#39;&#34;,
                                error=error,
                            )
                            log(rh, f&#34;  will use &#39;{prevName}&#39; for {eidkind}&#34;)

                else:
                    (firstRow, firstName) = firstRowEid
                    if firstName == name:
                        severity = &#34;identical&#34;
                        error = False
                    elif toId(firstName) == toId(name):
                        severity = &#34;minor variant in&#34;
                        error = False
                    else:
                        severity = &#34;major variant in&#34;
                        error = True

                    log(
                        rh,
                        f&#34;{sheetRep} {severity} name for {eidkind}:\n&#34;
                        f&#34;  in {firstRow + 1:&lt;3} : &#39;{firstName}&#39;\n&#34;
                        f&#34;  in {r + 1:&lt;3} : &#39;{name}&#39;\n&#34;,
                        error=error,
                    )
                    log(rh, f&#34;  will merge triggers {triggers} with {sheet[eidkind]}&#34;)
                    sheet[eidkind] |= triggers

            return sheet

        def readDir(sheetRela, level):
            sheetRep = f&#34;[{sheetRela}]&#34;
            sep = &#34;/&#34; if sheetRela else &#34;&#34;

            (files, dirs) = dirContents(f&#34;{sheetDir}/{sheetName}{sep}{sheetRela}&#34;)

            sheetSingle = {}
            sheetRange = {}

            for file in files:
                if file == DS_STORE:
                    continue

                match = SHEET_RE.match(file)
                if not match:
                    log(rh, f&#34;{sheetRep} contains unrecognized file {file}&#34;)
                    continue

                (start, end) = match.group(1, 2)
                fileBase = f&#34;{start}{end}&#34;

                start = int(start)
                end = int(end[1:]) if end else None
                key = start if end is None else (start, end)

                sheetDest = sheetSingle if end is None else sheetRange
                sheetDest[key] = readXls(f&#34;{sheetRela}/{fileBase}&#34;)

            sheetSubdirs = {}

            for dr in dirs:
                if level &gt;= 3:
                    log(rh, f&#34;{sheetRep} is at max depth, yet contains subdir {dr}&#34;)
                    continue

                if not dr.isdecimal():
                    log(rh, f&#34;{sheetRep} contains non-numeric subdir {dr}&#34;)
                    continue

                sheetSubdirs[int(dr)] = readDir(f&#34;{sheetRela}{sep}{dr}&#34;, level + 1)

            return dict(sng=sheetSingle, rng=sheetRange, sdr=sheetSubdirs)

        sheetMain = readXls(&#34;&#34;)
        sheetSubdirs = readDir(&#34;&#34;, 1)
        self.raw = dict(main=sheetMain, sdr=sheetSubdirs)
        rh.close()

    def combine(self):
        &#34;&#34;&#34;Combines the spreadsheet info in single-section spreadsheets.

        Among the tweaks, there may be *ranged* spreadsheets, i.e. having the name
        *start*`-`*end*, which indicate that they contain tweaks for sections
        *start* to *end*. These will be converted to individual spreadsheet
        *start*, *start + 1*, ..., *end - 1*, *end*.
        &#34;&#34;&#34;
        raw = self.raw

        sheetMain = raw[&#34;main&#34;]
        sheetTweaked = raw[&#34;sdr&#34;]

        # combine the info in ranged sheets into single number sheets

        combined = dict(sheet=sheetMain, tweaks={})
        self.combined = combined

        console(&#34;Combining the spreadsheets&#34;)

        def combineDir(data, dest):
            ranged = data.get(&#34;rng&#34;, {})
            single = data.get(&#34;sng&#34;, {})
            subdirs = data.get(&#34;sdr&#34;, {})

            for (start, end), sheet in sorted(ranged.items()):
                for i in range(start, end + 1):
                    updateDest = dest.setdefault(i, {}).setdefault(&#34;sheet&#34;, {})
                    for eidkind, triggers in sheet.items():
                        updateDest[eidkind] = triggers

            for i, sheet in single.items():
                updateDest = dest.setdefault(i, {}).setdefault(&#34;sheet&#34;, {})
                for eidkind, triggers in sheet.items():
                    updateDest[eidkind] = triggers

            for i, tweaks in subdirs.items():
                updateDest = dest.setdefault(i, {}).setdefault(&#34;tweaks&#34;, {})
                combineDir(tweaks, updateDest)

        combineDir(sheetTweaked, combined[&#34;tweaks&#34;])

    def compile(self):
        &#34;&#34;&#34;Compiles the info in tweaked sheets into complete sheets.

        For every tweak spreadsheet, a copy of its parent sheet will be made,
        and the info of the tweak sheet will be applied to that copy,
        adding to or overriding the parent sheet.

        A sheet is basically a mapping of triggers to names.

        We also maintain a mapping from tweak sheets to triggers, so that we can
        know later on which sheet assigned which trigger to which name.

        The tweak may remove triggers from the sheet. We have to adapt the tMap
        for that.
        &#34;&#34;&#34;

        combined = self.combined

        compiled = {}
        self.compiled = compiled

        console(&#34;Compiling the spreadsheets&#34;)

        def compileSheet(path, parentData, data, dest):
            parentSheet = parentData[&#34;sheet&#34;]
            sheet = data[&#34;sheet&#34;]
            newSheet = {}
            dest[&#34;sheet&#34;] = newSheet
            parentTMap = parentData.get(&#34;tMap&#34;, {})
            newTMap = {}
            dest[&#34;tMap&#34;] = newTMap

            for eidkind, triggers in parentSheet.items():
                newSheet[eidkind] = triggers

            for eidkind, triggers in sheet.items():
                newSheet[eidkind] = triggers

                for trigger in triggers:
                    newTMap[trigger] = tuple(str(k) for k in path)

            for eidkind, triggers in newSheet.items():
                for trigger in triggers:
                    if trigger not in newTMap:
                        newTMap[trigger] = parentTMap[trigger]

        def compileDir(path, parentData, data, dest):
            if &#34;sheet&#34; in data:
                compileSheet(path, parentData, data, dest)
                parentData = dict(sheet=dest[&#34;sheet&#34;], tMap=dest[&#34;tMap&#34;])

            tweaks = data.get(&#34;tweaks&#34;, {})
            tweakDest = dest.setdefault(&#34;tweaks&#34;, {})

            for k in sorted(tweaks):
                compileDir(
                    path + (k,), parentData, tweaks[k], tweakDest.setdefault(k, {})
                )

        compileDir((), combined, combined, compiled)

    def prepare(self):
        &#34;&#34;&#34;Transform the sheets into instructions.

        Now we have complete sheets for every context, the inheritance is resolved.
        Every sheet specifies a mapping from triggers to names, and remembers
        which (possibly other) sheet mapped a specific trigger to its name.

        We perform additional checks on the consistency and completeness of the
        resulting sheets.

        Then we generate instructions out of the sheets: data that the search
        algorithm needs to do its work.

        For each path to tweaked sheet we collect a portion of data:

        *   `tPos`: a compilation of all triggers in the sheet, so that
            we can search for them simultaneously;
        *   `tMap`: a mapping from triggers to the path of the sheet that defined this
            trigger;
        *   `idMap`: a mapping from triggers their corresponding entities.

        So every portion of data is addressed by a `path` key. This key is a tuple
        of section/subsection/subsubsection heading.

        By means of this key we can select the proper search instructions for specific
        parts of the corpus.

        About reporting:

        We report the entities without triggers.
        When we report the tweaks, only those triggerless entities are reported that
        were not already triggerless in the main sheet.

        We report the ambiguus triggers.
        When we report the tweaks, only those triggers that are redefined in that tweak
        are reported.
        &#34;&#34;&#34;

        spaceEscaped = self.spaceEscaped
        nameMap = self.nameMap
        compiled = self.compiled

        instructions = {}
        self.instructions = instructions

        reportDir = self.reportDir
        reportFile = f&#34;{reportDir}/check.tsv&#34;

        console(&#34;Checking the spreadsheets&#34;)

        checkData = [&#34;sheet\tentities\tnotriggers\ttriggers\tambiguous\n&#34;]
        ambiData = []
        notrigData = []

        mainNotrigData = set()

        def prepareSheet(path, info):
            isMain = len(path) == 0
            sheet = info[&#34;sheet&#34;]
            tMap = info[&#34;tMap&#34;]
            sheetR = &#34;.&#34;.join(path)
            sheetRep = f&#34;[{sheetR}]&#34;

            triggerSet = set()
            tPos = collections.defaultdict(lambda: collections.defaultdict(set))
            idMap = collections.defaultdict(list)

            data = dict(tPos=tPos, tMap=tMap)

            instructions[path] = data

            for eidkind, triggers in sheet.items():
                if len(triggers) == 0:
                    name = nameMap[eidkind][0]

                    if isMain:
                        mainNotrigData.add(name)
                    else:
                        if name not in mainNotrigData:
                            notrigData.append((name, sheetR))

                for trigger in triggers:
                    triggerT = toTokens(trigger, spaceEscaped=spaceEscaped)
                    triggerSet.add(triggerT)
                    idMap[trigger].append(eidkind)

            for triggerT in triggerSet:
                for i, token in enumerate(triggerT):
                    tPos[i][token].add(triggerT)

            data[&#34;idMap&#34;] = {
                trigger: eidkinds[0] for (trigger, eidkinds) in idMap.items()
            }

            nEnt = len(sheet)
            nTriggers = sum(len(triggers) for triggers in sheet.values())
            noTriggers = sum(1 for triggers in sheet.values() if len(triggers) == 0)
            noTrigMsg = &#34;&#34; if noTriggers == 0 else f&#34;, {noTriggers} without triggers;&#34;

            ambi = 0
            msgs = []

            for trigger, eidkinds in sorted(idMap.items()):
                if len(eidkinds) &lt;= 1:
                    continue

                tPath = tMap[trigger]

                if path != tPath:
                    continue

                msgs.append(f&#34;&#34;&#34;  trigger &#39;{trigger}&#39; used for:&#34;&#34;&#34;)

                for eidkind in eidkinds:
                    name = nameMap[eidkind][0]
                    msgs.append(f&#34;\t{name}&#34;)

                    ambiData.append((trigger, sheetR, name))

                ambi += 1

            ambiMsg = &#34;&#34; if ambi == 0 else f&#34;, {ambi} ambiguous&#34;

            entMsg = f&#34;entities: {nEnt} {noTrigMsg}&#34;
            triggerMsg = f&#34;triggers: {nTriggers} {ambiMsg}&#34;

            console(f&#34;{sheetRep:&lt;25}: {entMsg:&lt;35} {triggerMsg}&#34;)

            if len(msgs):
                console(&#34;\n&#34;.join(msgs))

            checkData.append(f&#34;{sheetR}\t{nEnt}\t{noTriggers}\t{nTriggers}\t{ambi}\n&#34;)

        def prepareDir(path, data):
            if &#34;sheet&#34; in data:
                prepareSheet(path, data)

            tweaks = data.get(&#34;tweaks&#34;, {})

            for k in sorted(tweaks):
                prepareDir(path + (str(k),), tweaks[k])

        prepareDir((), compiled)

        with open(reportFile, &#34;w&#34;) as rh:
            for c in checkData:
                rh.write(c)

        notrigFile = f&#34;{reportDir}/notriggers.tsv&#34;

        with open(notrigFile, &#34;w&#34;) as nh:
            nh.write(&#34;name\tsheet\n&#34;)

            for name in sorted(mainNotrigData):
                nh.write(f&#34;{name}\t\n&#34;)
            for (name, sheet) in sorted(notrigData):
                nh.write(f&#34;{name}\t{sheet}\n&#34;)

        ambiFile = f&#34;{reportDir}/ambitriggers.tsv&#34;

        with open(ambiFile, &#34;w&#34;) as ah:
            ah.write(&#34;trigger\tname\tsheet\n&#34;)

            for (trigger, sheet, name) in sorted(ambiData):
                ah.write(f&#34;{trigger}\t{sheet}\t{name}\n&#34;)

    def showRaw(self, main=False):
        nameMap = self.nameMap
        src = self.raw

        def showSheet(sheet, tab):
            for eidkind, triggers in sorted(sheet.items()):
                (name, sheetRela) = nameMap[eidkind]
                triggerRep = &#34;|&#34;.join(
                    t for t in sorted(triggers, key=lambda x: (-len(x), x))
                )
                console(f&#34;{tab}  &#39;{name}&#39; {eidkind} : {triggerRep}&#34;)
            console(f&#34;{tab}  ---&#34;)

        def showDir(head, tweaks, level):
            tab = &#34;  &#34; * level
            console(f&#34;{tab}{head}&#34;)

            rng = tweaks.get(&#34;rng&#34;, {})
            for b, e in sorted(rng):
                console(f&#34;{tab}  {b}-{e}.xslx&#34;)
                showSheet(rng[(b, e)], tab)

            sng = tweaks.get(&#34;sng&#34;, {})
            for k in sorted(sng):
                console(f&#34;{tab}  {k}.xslx&#34;)
                showSheet(sng[k], tab)

            sdr = tweaks.get(&#34;sdr&#34;, {})

            for k in sorted(sdr):
                showDir(k, sdr[k], level + 1)

        if main:
            showSheet(src[&#34;main&#34;], &#34;&#34;)

        showDir(&#34;&#34;, src[&#34;sdr&#34;], 0)

    def showCombined(self, main=False):
        nameMap = self.nameMap
        src = self.combined

        def showSheet(sheet, tab):
            for eidkind, triggers in sorted(sheet.items()):
                (name, sheetRela) = nameMap[eidkind]
                triggerRep = &#34;|&#34;.join(
                    t for t in sorted(triggers, key=lambda x: (-len(x), x))
                )
                console(f&#34;{tab}  &#39;{name}&#39; {eidkind} : {triggerRep}&#34;)
            console(f&#34;{tab}  ---&#34;)

        def showDir(head, data, level):
            tab = &#34;  &#34; * level
            console(f&#34;{tab}{head}&#34;)

            if &#34;sheet&#34; in data:
                if main or level &gt; 0:
                    showSheet(data[&#34;sheet&#34;], tab)

            tweaks = data.get(&#34;tweaks&#34;, {})

            for k in sorted(tweaks):
                showDir(k, tweaks[k], level + 1)

        showDir(&#34;&#34;, src, 0)

    def showCompiled(self, main=False):
        nameMap = self.nameMap
        src = self.compiled

        def showSheet(data, tab):
            sheet = data[&#34;sheet&#34;]
            tMap = data[&#34;tMap&#34;]

            for eidkind, triggers in sorted(sheet.items()):
                triggerSources = {tMap[t] for t in triggers}
                nTriggers = len(triggers)

                if not main and (nTriggers == 0 or triggerSources == {()}):
                    continue

                (name, sheetRela) = nameMap[eidkind]

                if nTriggers == 0:
                    triggerInfo = &#34;X&#34;
                else:
                    sourceRep = (
                        &#34;X&#34;
                        if len(triggerSources) == 0
                        else list(list(triggerSources)[0])
                    )
                    triggerRep = &#34;|&#34;.join(
                        t for t in sorted(triggers, key=lambda x: (-len(x), x))
                    )
                    triggerInfo = f&#34;{sourceRep} =&gt; {triggerRep}&#34;

                console(f&#34;{tab}  &#39;{name}&#39; {eidkind} : {triggerInfo}&#34;)
            console(f&#34;{tab}  ---&#34;)

        def showDir(head, data, level):
            tab = &#34;  &#34; * level
            console(f&#34;{tab}{head}&#34;)

            if &#34;sheet&#34; in data:
                if main or level &gt; 0:
                    showSheet(data, tab)

            tweaks = data.get(&#34;tweaks&#34;, {})

            for k in sorted(tweaks):
                showDir(k, tweaks[k], level + 1)

        showDir(&#34;&#34;, src, 0)

    def showInstructions(self):
        instructions = self.instructions
        console(&#34;\n&#34;.join(f&#34;{path}&#34; for path in instructions))</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tf.browser.ner.triggers.Triggers.instructions"><code class="name">var <span class="ident">instructions</span></code></dt>
<dd>
<div class="desc"><p>Will contain the information in a spreadsheet for marking up entities.</p></div>
</dd>
<dt id="tf.browser.ner.triggers.Triggers.nameMap"><code class="name">var <span class="ident">nameMap</span></code></dt>
<dd>
<div class="desc"><p>Will contain a mapping from entities to names.</p>
<p>The entities are keyed by their (eid, kind) tuple.
The values are names plus the sheet where they are first defined.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tf.browser.ner.triggers.Triggers.combine"><code class="name flex">
<span>def <span class="ident">combine</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Combines the spreadsheet info in single-section spreadsheets.</p>
<p>Among the tweaks, there may be <em>ranged</em> spreadsheets, i.e. having the name
<em>start</em><code>-</code><em>end</em>, which indicate that they contain tweaks for sections
<em>start</em> to <em>end</em>. These will be converted to individual spreadsheet
<em>start</em>, <em>start + 1</em>, &hellip;, <em>end - 1</em>, <em>end</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/a7d9f3f5a3ce7e037e0fa8fa92427aab66ddd523/tf/browser/ner/triggers.py#L239-L279" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def combine(self):
    &#34;&#34;&#34;Combines the spreadsheet info in single-section spreadsheets.

    Among the tweaks, there may be *ranged* spreadsheets, i.e. having the name
    *start*`-`*end*, which indicate that they contain tweaks for sections
    *start* to *end*. These will be converted to individual spreadsheet
    *start*, *start + 1*, ..., *end - 1*, *end*.
    &#34;&#34;&#34;
    raw = self.raw

    sheetMain = raw[&#34;main&#34;]
    sheetTweaked = raw[&#34;sdr&#34;]

    # combine the info in ranged sheets into single number sheets

    combined = dict(sheet=sheetMain, tweaks={})
    self.combined = combined

    console(&#34;Combining the spreadsheets&#34;)

    def combineDir(data, dest):
        ranged = data.get(&#34;rng&#34;, {})
        single = data.get(&#34;sng&#34;, {})
        subdirs = data.get(&#34;sdr&#34;, {})

        for (start, end), sheet in sorted(ranged.items()):
            for i in range(start, end + 1):
                updateDest = dest.setdefault(i, {}).setdefault(&#34;sheet&#34;, {})
                for eidkind, triggers in sheet.items():
                    updateDest[eidkind] = triggers

        for i, sheet in single.items():
            updateDest = dest.setdefault(i, {}).setdefault(&#34;sheet&#34;, {})
            for eidkind, triggers in sheet.items():
                updateDest[eidkind] = triggers

        for i, tweaks in subdirs.items():
            updateDest = dest.setdefault(i, {}).setdefault(&#34;tweaks&#34;, {})
            combineDir(tweaks, updateDest)

    combineDir(sheetTweaked, combined[&#34;tweaks&#34;])</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.triggers.Triggers.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compiles the info in tweaked sheets into complete sheets.</p>
<p>For every tweak spreadsheet, a copy of its parent sheet will be made,
and the info of the tweak sheet will be applied to that copy,
adding to or overriding the parent sheet.</p>
<p>A sheet is basically a mapping of triggers to names.</p>
<p>We also maintain a mapping from tweak sheets to triggers, so that we can
know later on which sheet assigned which trigger to which name.</p>
<p>The tweak may remove triggers from the sheet. We have to adapt the tMap
for that.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/a7d9f3f5a3ce7e037e0fa8fa92427aab66ddd523/tf/browser/ner/triggers.py#L281-L340" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def compile(self):
    &#34;&#34;&#34;Compiles the info in tweaked sheets into complete sheets.

    For every tweak spreadsheet, a copy of its parent sheet will be made,
    and the info of the tweak sheet will be applied to that copy,
    adding to or overriding the parent sheet.

    A sheet is basically a mapping of triggers to names.

    We also maintain a mapping from tweak sheets to triggers, so that we can
    know later on which sheet assigned which trigger to which name.

    The tweak may remove triggers from the sheet. We have to adapt the tMap
    for that.
    &#34;&#34;&#34;

    combined = self.combined

    compiled = {}
    self.compiled = compiled

    console(&#34;Compiling the spreadsheets&#34;)

    def compileSheet(path, parentData, data, dest):
        parentSheet = parentData[&#34;sheet&#34;]
        sheet = data[&#34;sheet&#34;]
        newSheet = {}
        dest[&#34;sheet&#34;] = newSheet
        parentTMap = parentData.get(&#34;tMap&#34;, {})
        newTMap = {}
        dest[&#34;tMap&#34;] = newTMap

        for eidkind, triggers in parentSheet.items():
            newSheet[eidkind] = triggers

        for eidkind, triggers in sheet.items():
            newSheet[eidkind] = triggers

            for trigger in triggers:
                newTMap[trigger] = tuple(str(k) for k in path)

        for eidkind, triggers in newSheet.items():
            for trigger in triggers:
                if trigger not in newTMap:
                    newTMap[trigger] = parentTMap[trigger]

    def compileDir(path, parentData, data, dest):
        if &#34;sheet&#34; in data:
            compileSheet(path, parentData, data, dest)
            parentData = dict(sheet=dest[&#34;sheet&#34;], tMap=dest[&#34;tMap&#34;])

        tweaks = data.get(&#34;tweaks&#34;, {})
        tweakDest = dest.setdefault(&#34;tweaks&#34;, {})

        for k in sorted(tweaks):
            compileDir(
                path + (k,), parentData, tweaks[k], tweakDest.setdefault(k, {})
            )

    compileDir((), combined, combined, compiled)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.triggers.Triggers.intake"><code class="name flex">
<span>def <span class="ident">intake</span></span>(<span>self, sheetName)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the spreadsheets and translate them in actionable data for search.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sheetName</code></strong> :&ensp;<code>string</code></dt>
<dd>
<p>The base name of the sheet, without extension.
It is assume that a spreadsheet with that name and extension <code>.xlsx</code> exists
in the expected location.</p>
<p>Next to it a subdirectory of the same name may exist, which contains
additional spreadsheets and subdirectories that contain
increasingly specific tweaks on top of the base spreadsheet.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/a7d9f3f5a3ce7e037e0fa8fa92427aab66ddd523/tf/browser/ner/triggers.py#L37-L55" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def intake(self, sheetName):
    &#34;&#34;&#34;Read the spreadsheets and translate them in actionable data for search.

    Parameters
    ----------
    sheetName: string
        The base name of the sheet, without extension.
        It is assume that a spreadsheet with that name and extension `.xlsx` exists
        in the expected location.

        Next to it a subdirectory of the same name may exist, which contains
        additional spreadsheets and subdirectories that contain
        increasingly specific tweaks on top of the base spreadsheet.
    &#34;&#34;&#34;
    self.sheetName = sheetName
    self.read()
    self.combine()
    self.compile()
    self.prepare()</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.triggers.Triggers.prepare"><code class="name flex">
<span>def <span class="ident">prepare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the sheets into instructions.</p>
<p>Now we have complete sheets for every context, the inheritance is resolved.
Every sheet specifies a mapping from triggers to names, and remembers
which (possibly other) sheet mapped a specific trigger to its name.</p>
<p>We perform additional checks on the consistency and completeness of the
resulting sheets.</p>
<p>Then we generate instructions out of the sheets: data that the search
algorithm needs to do its work.</p>
<p>For each path to tweaked sheet we collect a portion of data:</p>
<ul>
<li><code>tPos</code>: a compilation of all triggers in the sheet, so that
we can search for them simultaneously;</li>
<li><code>tMap</code>: a mapping from triggers to the path of the sheet that defined this
trigger;</li>
<li><code>idMap</code>: a mapping from triggers their corresponding entities.</li>
</ul>
<p>So every portion of data is addressed by a <code>path</code> key. This key is a tuple
of section/subsection/subsubsection heading.</p>
<p>By means of this key we can select the proper search instructions for specific
parts of the corpus.</p>
<p>About reporting:</p>
<p>We report the entities without triggers.
When we report the tweaks, only those triggerless entities are reported that
were not already triggerless in the main sheet.</p>
<p>We report the ambiguus triggers.
When we report the tweaks, only those triggers that are redefined in that tweak
are reported.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/a7d9f3f5a3ce7e037e0fa8fa92427aab66ddd523/tf/browser/ner/triggers.py#L342-L506" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def prepare(self):
    &#34;&#34;&#34;Transform the sheets into instructions.

    Now we have complete sheets for every context, the inheritance is resolved.
    Every sheet specifies a mapping from triggers to names, and remembers
    which (possibly other) sheet mapped a specific trigger to its name.

    We perform additional checks on the consistency and completeness of the
    resulting sheets.

    Then we generate instructions out of the sheets: data that the search
    algorithm needs to do its work.

    For each path to tweaked sheet we collect a portion of data:

    *   `tPos`: a compilation of all triggers in the sheet, so that
        we can search for them simultaneously;
    *   `tMap`: a mapping from triggers to the path of the sheet that defined this
        trigger;
    *   `idMap`: a mapping from triggers their corresponding entities.

    So every portion of data is addressed by a `path` key. This key is a tuple
    of section/subsection/subsubsection heading.

    By means of this key we can select the proper search instructions for specific
    parts of the corpus.

    About reporting:

    We report the entities without triggers.
    When we report the tweaks, only those triggerless entities are reported that
    were not already triggerless in the main sheet.

    We report the ambiguus triggers.
    When we report the tweaks, only those triggers that are redefined in that tweak
    are reported.
    &#34;&#34;&#34;

    spaceEscaped = self.spaceEscaped
    nameMap = self.nameMap
    compiled = self.compiled

    instructions = {}
    self.instructions = instructions

    reportDir = self.reportDir
    reportFile = f&#34;{reportDir}/check.tsv&#34;

    console(&#34;Checking the spreadsheets&#34;)

    checkData = [&#34;sheet\tentities\tnotriggers\ttriggers\tambiguous\n&#34;]
    ambiData = []
    notrigData = []

    mainNotrigData = set()

    def prepareSheet(path, info):
        isMain = len(path) == 0
        sheet = info[&#34;sheet&#34;]
        tMap = info[&#34;tMap&#34;]
        sheetR = &#34;.&#34;.join(path)
        sheetRep = f&#34;[{sheetR}]&#34;

        triggerSet = set()
        tPos = collections.defaultdict(lambda: collections.defaultdict(set))
        idMap = collections.defaultdict(list)

        data = dict(tPos=tPos, tMap=tMap)

        instructions[path] = data

        for eidkind, triggers in sheet.items():
            if len(triggers) == 0:
                name = nameMap[eidkind][0]

                if isMain:
                    mainNotrigData.add(name)
                else:
                    if name not in mainNotrigData:
                        notrigData.append((name, sheetR))

            for trigger in triggers:
                triggerT = toTokens(trigger, spaceEscaped=spaceEscaped)
                triggerSet.add(triggerT)
                idMap[trigger].append(eidkind)

        for triggerT in triggerSet:
            for i, token in enumerate(triggerT):
                tPos[i][token].add(triggerT)

        data[&#34;idMap&#34;] = {
            trigger: eidkinds[0] for (trigger, eidkinds) in idMap.items()
        }

        nEnt = len(sheet)
        nTriggers = sum(len(triggers) for triggers in sheet.values())
        noTriggers = sum(1 for triggers in sheet.values() if len(triggers) == 0)
        noTrigMsg = &#34;&#34; if noTriggers == 0 else f&#34;, {noTriggers} without triggers;&#34;

        ambi = 0
        msgs = []

        for trigger, eidkinds in sorted(idMap.items()):
            if len(eidkinds) &lt;= 1:
                continue

            tPath = tMap[trigger]

            if path != tPath:
                continue

            msgs.append(f&#34;&#34;&#34;  trigger &#39;{trigger}&#39; used for:&#34;&#34;&#34;)

            for eidkind in eidkinds:
                name = nameMap[eidkind][0]
                msgs.append(f&#34;\t{name}&#34;)

                ambiData.append((trigger, sheetR, name))

            ambi += 1

        ambiMsg = &#34;&#34; if ambi == 0 else f&#34;, {ambi} ambiguous&#34;

        entMsg = f&#34;entities: {nEnt} {noTrigMsg}&#34;
        triggerMsg = f&#34;triggers: {nTriggers} {ambiMsg}&#34;

        console(f&#34;{sheetRep:&lt;25}: {entMsg:&lt;35} {triggerMsg}&#34;)

        if len(msgs):
            console(&#34;\n&#34;.join(msgs))

        checkData.append(f&#34;{sheetR}\t{nEnt}\t{noTriggers}\t{nTriggers}\t{ambi}\n&#34;)

    def prepareDir(path, data):
        if &#34;sheet&#34; in data:
            prepareSheet(path, data)

        tweaks = data.get(&#34;tweaks&#34;, {})

        for k in sorted(tweaks):
            prepareDir(path + (str(k),), tweaks[k])

    prepareDir((), compiled)

    with open(reportFile, &#34;w&#34;) as rh:
        for c in checkData:
            rh.write(c)

    notrigFile = f&#34;{reportDir}/notriggers.tsv&#34;

    with open(notrigFile, &#34;w&#34;) as nh:
        nh.write(&#34;name\tsheet\n&#34;)

        for name in sorted(mainNotrigData):
            nh.write(f&#34;{name}\t\n&#34;)
        for (name, sheet) in sorted(notrigData):
            nh.write(f&#34;{name}\t{sheet}\n&#34;)

    ambiFile = f&#34;{reportDir}/ambitriggers.tsv&#34;

    with open(ambiFile, &#34;w&#34;) as ah:
        ah.write(&#34;trigger\tname\tsheet\n&#34;)

        for (trigger, sheet, name) in sorted(ambiData):
            ah.write(f&#34;{trigger}\t{sheet}\t{name}\n&#34;)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.triggers.Triggers.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read all the spreadsheets, the main one and the tweaks.</p>
<p>Store the results in a hierarchy that mimicks the way they are organized in the
file system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/a7d9f3f5a3ce7e037e0fa8fa92427aab66ddd523/tf/browser/ner/triggers.py#L57-L237" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read(self):
    &#34;&#34;&#34;Read all the spreadsheets, the main one and the tweaks.

    Store the results in a hierarchy that mimicks the way they are organized in the
    file system.
    &#34;&#34;&#34;
    sheetName = self.sheetName
    sheetDir = self.sheetDir
    loadXls = self.loadXls
    defaultKind = self.defaultKind
    transform = self.transform
    nameMap = self.nameMap
    spaceEscaped = self.spaceEscaped

    reportDir = self.reportDir
    reportFile = f&#34;{reportDir}/read.txt&#34;
    rh = open(reportFile, &#34;w&#34;)
    log(rh, &#34;Reading the spreadsheets&#34;)

    def readXls(sheetRela):
        sep = &#34;/&#34; if sheetRela else &#34;&#34;
        sheetRep = f&#34;[{sheetRela}]&#34;

        sheetPath = f&#34;{sheetDir}/{sheetName}{sep}{sheetRela}.xlsx&#34;

        wb = loadXls(sheetPath, data_only=True)
        ws = wb.active

        (headRow, subHeadRow, *rows) = list(ws.rows)
        rows = [row for row in rows if any(c.value for c in row)]

        sheet = {}

        idFirstRow = {}

        for r, row in enumerate(ws.rows):
            if r in {0, 1}:
                continue
            if not any(c.value for c in row):
                continue

            (name, kind, triggerStr) = (
                normalize(row[i].value or &#34;&#34;) for i in range(3)
            )
            triggers = (
                set()
                if not triggerStr
                else {
                    y
                    for x in triggerStr.split(&#34;;&#34;)
                    if (y := tnorm(x, spaceEscaped=spaceEscaped)) != &#34;&#34;
                }
            )
            if not name:
                name = list(triggers)[0] if triggers else &#34;&#34;
                if name == &#34;&#34;:
                    if kind:
                        log(
                            rh,
                            f&#34;{sheetRep} row {r + 1:&gt;3}: {kind}: &#34;
                            &#34;no entity name and no triggers&#34;,
                        )
                    continue
                else:
                    log(
                        rh,
                        f&#34;{sheetRep} row {r + 1:&gt;3}: {kind}: &#34;
                        f&#34;no entity name, supplied synonym {name}&#34;,
                    )

            if not kind:
                kind = defaultKind
                log(
                    rh,
                    f&#34;{sheetRep} row {r + 1:&gt;3}: &#34;
                    f&#34;no kind name, supplied {defaultKind}&#34;,
                )

            eid = toSmallId(name, transform=transform)
            eidkind = (eid, kind)
            firstRowEid = idFirstRow.get((eidkind), None)

            if firstRowEid is None:
                idFirstRow[eidkind] = (r, name)
                sheet[eidkind] = triggers

                prev = nameMap.get(eidkind, None)

                if prev is None:
                    nameMap[eidkind] = (name, sheetRela)
                else:
                    (prevName, prevSheet) = prev

                    if prevName != name:
                        if toId(prevName) == toId(name):
                            severity = &#34;minor&#34;
                            error = False
                        else:
                            severity = &#34;major&#34;
                            error = True

                        log(
                            rh,
                            f&#34;{sheetRep} {severity} name variant for {eidkind}:\n&#34;
                            f&#34;  in {prevSheet:&lt;30} : &#39;{prevName}&#39;\n&#34;
                            f&#34;  in {sheetRep:&lt;30} : &#39;{name}&#39;&#34;,
                            error=error,
                        )
                        log(rh, f&#34;  will use &#39;{prevName}&#39; for {eidkind}&#34;)

            else:
                (firstRow, firstName) = firstRowEid
                if firstName == name:
                    severity = &#34;identical&#34;
                    error = False
                elif toId(firstName) == toId(name):
                    severity = &#34;minor variant in&#34;
                    error = False
                else:
                    severity = &#34;major variant in&#34;
                    error = True

                log(
                    rh,
                    f&#34;{sheetRep} {severity} name for {eidkind}:\n&#34;
                    f&#34;  in {firstRow + 1:&lt;3} : &#39;{firstName}&#39;\n&#34;
                    f&#34;  in {r + 1:&lt;3} : &#39;{name}&#39;\n&#34;,
                    error=error,
                )
                log(rh, f&#34;  will merge triggers {triggers} with {sheet[eidkind]}&#34;)
                sheet[eidkind] |= triggers

        return sheet

    def readDir(sheetRela, level):
        sheetRep = f&#34;[{sheetRela}]&#34;
        sep = &#34;/&#34; if sheetRela else &#34;&#34;

        (files, dirs) = dirContents(f&#34;{sheetDir}/{sheetName}{sep}{sheetRela}&#34;)

        sheetSingle = {}
        sheetRange = {}

        for file in files:
            if file == DS_STORE:
                continue

            match = SHEET_RE.match(file)
            if not match:
                log(rh, f&#34;{sheetRep} contains unrecognized file {file}&#34;)
                continue

            (start, end) = match.group(1, 2)
            fileBase = f&#34;{start}{end}&#34;

            start = int(start)
            end = int(end[1:]) if end else None
            key = start if end is None else (start, end)

            sheetDest = sheetSingle if end is None else sheetRange
            sheetDest[key] = readXls(f&#34;{sheetRela}/{fileBase}&#34;)

        sheetSubdirs = {}

        for dr in dirs:
            if level &gt;= 3:
                log(rh, f&#34;{sheetRep} is at max depth, yet contains subdir {dr}&#34;)
                continue

            if not dr.isdecimal():
                log(rh, f&#34;{sheetRep} contains non-numeric subdir {dr}&#34;)
                continue

            sheetSubdirs[int(dr)] = readDir(f&#34;{sheetRela}{sep}{dr}&#34;, level + 1)

        return dict(sng=sheetSingle, rng=sheetRange, sdr=sheetSubdirs)

    sheetMain = readXls(&#34;&#34;)
    sheetSubdirs = readDir(&#34;&#34;, 1)
    self.raw = dict(main=sheetMain, sdr=sheetSubdirs)
    rh.close()</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.triggers.Triggers.showCombined"><code class="name flex">
<span>def <span class="ident">showCombined</span></span>(<span>self, main=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/a7d9f3f5a3ce7e037e0fa8fa92427aab66ddd523/tf/browser/ner/triggers.py#L545-L571" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showCombined(self, main=False):
    nameMap = self.nameMap
    src = self.combined

    def showSheet(sheet, tab):
        for eidkind, triggers in sorted(sheet.items()):
            (name, sheetRela) = nameMap[eidkind]
            triggerRep = &#34;|&#34;.join(
                t for t in sorted(triggers, key=lambda x: (-len(x), x))
            )
            console(f&#34;{tab}  &#39;{name}&#39; {eidkind} : {triggerRep}&#34;)
        console(f&#34;{tab}  ---&#34;)

    def showDir(head, data, level):
        tab = &#34;  &#34; * level
        console(f&#34;{tab}{head}&#34;)

        if &#34;sheet&#34; in data:
            if main or level &gt; 0:
                showSheet(data[&#34;sheet&#34;], tab)

        tweaks = data.get(&#34;tweaks&#34;, {})

        for k in sorted(tweaks):
            showDir(k, tweaks[k], level + 1)

    showDir(&#34;&#34;, src, 0)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.triggers.Triggers.showCompiled"><code class="name flex">
<span>def <span class="ident">showCompiled</span></span>(<span>self, main=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/a7d9f3f5a3ce7e037e0fa8fa92427aab66ddd523/tf/browser/ner/triggers.py#L573-L619" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showCompiled(self, main=False):
    nameMap = self.nameMap
    src = self.compiled

    def showSheet(data, tab):
        sheet = data[&#34;sheet&#34;]
        tMap = data[&#34;tMap&#34;]

        for eidkind, triggers in sorted(sheet.items()):
            triggerSources = {tMap[t] for t in triggers}
            nTriggers = len(triggers)

            if not main and (nTriggers == 0 or triggerSources == {()}):
                continue

            (name, sheetRela) = nameMap[eidkind]

            if nTriggers == 0:
                triggerInfo = &#34;X&#34;
            else:
                sourceRep = (
                    &#34;X&#34;
                    if len(triggerSources) == 0
                    else list(list(triggerSources)[0])
                )
                triggerRep = &#34;|&#34;.join(
                    t for t in sorted(triggers, key=lambda x: (-len(x), x))
                )
                triggerInfo = f&#34;{sourceRep} =&gt; {triggerRep}&#34;

            console(f&#34;{tab}  &#39;{name}&#39; {eidkind} : {triggerInfo}&#34;)
        console(f&#34;{tab}  ---&#34;)

    def showDir(head, data, level):
        tab = &#34;  &#34; * level
        console(f&#34;{tab}{head}&#34;)

        if &#34;sheet&#34; in data:
            if main or level &gt; 0:
                showSheet(data, tab)

        tweaks = data.get(&#34;tweaks&#34;, {})

        for k in sorted(tweaks):
            showDir(k, tweaks[k], level + 1)

    showDir(&#34;&#34;, src, 0)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.triggers.Triggers.showInstructions"><code class="name flex">
<span>def <span class="ident">showInstructions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/a7d9f3f5a3ce7e037e0fa8fa92427aab66ddd523/tf/browser/ner/triggers.py#L621-L623" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showInstructions(self):
    instructions = self.instructions
    console(&#34;\n&#34;.join(f&#34;{path}&#34; for path in instructions))</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.triggers.Triggers.showRaw"><code class="name flex">
<span>def <span class="ident">showRaw</span></span>(<span>self, main=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/a7d9f3f5a3ce7e037e0fa8fa92427aab66ddd523/tf/browser/ner/triggers.py#L508-L543" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showRaw(self, main=False):
    nameMap = self.nameMap
    src = self.raw

    def showSheet(sheet, tab):
        for eidkind, triggers in sorted(sheet.items()):
            (name, sheetRela) = nameMap[eidkind]
            triggerRep = &#34;|&#34;.join(
                t for t in sorted(triggers, key=lambda x: (-len(x), x))
            )
            console(f&#34;{tab}  &#39;{name}&#39; {eidkind} : {triggerRep}&#34;)
        console(f&#34;{tab}  ---&#34;)

    def showDir(head, tweaks, level):
        tab = &#34;  &#34; * level
        console(f&#34;{tab}{head}&#34;)

        rng = tweaks.get(&#34;rng&#34;, {})
        for b, e in sorted(rng):
            console(f&#34;{tab}  {b}-{e}.xslx&#34;)
            showSheet(rng[(b, e)], tab)

        sng = tweaks.get(&#34;sng&#34;, {})
        for k in sorted(sng):
            console(f&#34;{tab}  {k}.xslx&#34;)
            showSheet(sng[k], tab)

        sdr = tweaks.get(&#34;sdr&#34;, {})

        for k in sorted(sdr):
            showDir(k, sdr[k], level + 1)

    if main:
        showSheet(src[&#34;main&#34;], &#34;&#34;)

    showDir(&#34;&#34;, src[&#34;sdr&#34;], 0)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.browser.ner" href="index.html">tf.browser.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.browser.ner.triggers.Triggers" href="#tf.browser.ner.triggers.Triggers">Triggers</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.browser.ner.triggers.Triggers.combine" href="#tf.browser.ner.triggers.Triggers.combine">combine</a></code></li>
<li><code><a title="tf.browser.ner.triggers.Triggers.compile" href="#tf.browser.ner.triggers.Triggers.compile">compile</a></code></li>
<li><code><a title="tf.browser.ner.triggers.Triggers.instructions" href="#tf.browser.ner.triggers.Triggers.instructions">instructions</a></code></li>
<li><code><a title="tf.browser.ner.triggers.Triggers.intake" href="#tf.browser.ner.triggers.Triggers.intake">intake</a></code></li>
<li><code><a title="tf.browser.ner.triggers.Triggers.nameMap" href="#tf.browser.ner.triggers.Triggers.nameMap">nameMap</a></code></li>
<li><code><a title="tf.browser.ner.triggers.Triggers.prepare" href="#tf.browser.ner.triggers.Triggers.prepare">prepare</a></code></li>
<li><code><a title="tf.browser.ner.triggers.Triggers.read" href="#tf.browser.ner.triggers.Triggers.read">read</a></code></li>
<li><code><a title="tf.browser.ner.triggers.Triggers.showCombined" href="#tf.browser.ner.triggers.Triggers.showCombined">showCombined</a></code></li>
<li><code><a title="tf.browser.ner.triggers.Triggers.showCompiled" href="#tf.browser.ner.triggers.Triggers.showCompiled">showCompiled</a></code></li>
<li><code><a title="tf.browser.ner.triggers.Triggers.showInstructions" href="#tf.browser.ner.triggers.Triggers.showInstructions">showInstructions</a></code></li>
<li><code><a title="tf.browser.ner.triggers.Triggers.showRaw" href="#tf.browser.ner.triggers.Triggers.showRaw">showRaw</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>