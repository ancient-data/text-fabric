<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.browser.ner.data API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.browser.ner.data</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/data.py#L1-L554" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import collections
import time

from ...core.generic import AttrDict
from ...core.files import (
    mTime,
    fileExists,
    initTree,
)
from .settings import Settings, getText


class Data(Settings):
    def __init__(self, data=None):
        super().__init__()

        if data is None:
            data = AttrDict()
            data.sets = AttrDict()

        self.data = data

        annoDir = self.annoDir
        initTree(annoDir, fresh=False)

    def loadData(self):
        &#34;&#34;&#34;Loads data of the given annotation set from disk into memory.

        The data of an annotation set consists of:

        *   a dict of entities, keyed by nodes or line numbers;
            each entity specifies a tuple of feature values and a list of slots
            that are part of the entity.

        If `annoSet` is empty, the annotation data is already in the TF data, and we do not
        do anything.

        After loading we process the data into derived datastructures.

        We try to be lazy. We only load data from disk if the data is not already in memory,
        or the data on disk has been updated since the last load.

        Likewise, we only process the data if the data has been loaded again.

        The resulting data is stored on the object
        and then under the key `sets` and then the name of the annotation set.

        For each such set we produce the following keys:

        *   `dateLoaded`: datetime when the data was last loaded from disk
        *   `dateProcessed`: datetime when the data was last processed
        *   `entities`: the list of entities as loaded from a tsv file

        We then process this into several data structures, each identified
        by a different key.
        &#34;&#34;&#34;
        data = self.data
        annoSet = self.annoSet

        if &#34;sets&#34; not in data:
            data.sets = AttrDict()

        sets = data.sets

        if annoSet not in sets:
            sets[annoSet] = AttrDict()

        # load bucket nodes

        changed = self.fromSource()
        self.process(changed)

    def fromSource(self):
        settings = self.settings
        bucketType = settings.bucketType
        app = self.app
        data = self.data
        annoSet = self.annoSet
        # annoSetRep = self.annoSetRep
        setData = data.sets[annoSet]
        annoDir = self.annoDir

        settings = self.settings
        entityType = settings.entityType
        features = settings.features
        nF = len(features)

        api = app.api
        F = api.F
        Fs = api.Fs
        L = api.L

        slotType = F.otype.slotType

        dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

        if &#34;buckets&#34; not in setData:
            setData.buckets = F.otype.s(bucketType)

        changed = False

        if annoSet:
            if (
                &#34;entities&#34; not in setData
                or &#34;dateLoaded&#34; not in setData
                or (len(setData.entities) &gt; 0 and not fileExists(dataFile))
                or (fileExists(dataFile) and setData.dateLoaded &lt; mTime(dataFile))
            ):
                # self.console(f&#34;Loading data for {annoSet} ... &#34;, newline=False)
                changed = True
                entities = {}

                if fileExists(dataFile):
                    with open(dataFile) as df:
                        for e, line in enumerate(df):
                            fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
                            entities[e] = (
                                tuple(fields[0:nF]),
                                tuple(int(f) for f in fields[nF:]),
                            )

                setData.entities = entities
                setData.dateLoaded = time.time()
                # self.console(&#34;done.&#34;)
            else:
                # self.console(f&#34;Data for {annoSetRep} already loaded&#34;)
                pass
        else:
            if &#34;entities&#34; not in setData:
                entities = {}
                hasFeature = {
                    feat: api.isLoaded(feat, pretty=False)[feat] is not None
                    for feat in features
                }

                for e in F.otype.s(entityType):
                    slots = L.d(e, otype=slotType)
                    entities[e] = (
                        tuple(
                            Fs(feat).v(e)
                            if hasFeature[feat]
                            else self.featureDefault[feat](F, slots)
                            for feat in features
                        ),
                        tuple(slots),
                    )

                setData.entities = entities

        return changed

    def process(self, changed):
        settings = self.settings
        features = settings.features
        summaryIndices = settings.summaryIndices

        app = self.app
        data = self.data
        annoSet = self.annoSet
        # annoSetRep = self.annoSetRep
        setData = data.sets[annoSet]

        api = app.api
        F = api.F

        dateLoaded = setData.dateLoaded
        dateProcessed = setData.dateProcessed

        if (
            changed
            or &#34;dateProcessed&#34; not in setData
            or &#34;entityText&#34; not in setData
            or &#34;entityTextVal&#34; not in setData
            or &#34;entitySummary&#34; not in setData
            or &#34;entityIdent&#34; not in setData
            or &#34;entityFreq&#34; not in setData
            or &#34;entityIndex&#34; not in setData
            or &#34;entityVal&#34; not in setData
            or &#34;entitySlotVal&#34; not in setData
            or &#34;entitySlotAll&#34; not in setData
            or &#34;entitySlotIndex&#34; not in setData
            or dateLoaded is not None
            and dateProcessed &lt; dateLoaded
        ):
            # self.console(f&#34;Processing data of {annoSetRep} ... &#34;, newline=False)

            entityItems = setData.entities.items()

            entityText = {}
            entityTextVal = {feat: collections.defaultdict(set) for feat in features}
            entitySummary = {}
            entityIdent = {}
            entityIdentFirst = {}
            entityFreq = {feat: collections.Counter() for feat in features}
            entityIndex = {feat: {} for feat in features}
            entityVal = {}
            entitySlotVal = {}
            entitySlotAll = {}
            entitySlotIndex = {}

            for e, (fVals, slots) in entityItems:
                txt = getText(F, slots)
                ident = fVals
                summary = tuple(fVals[i] for i in summaryIndices)

                entityText[e] = txt
                entityVal.setdefault(fVals, set()).add(slots)

                for feat, val in zip(features, fVals):
                    entityFreq[feat][val] += 1
                    entityIndex[feat].setdefault(slots, set()).add(val)
                    entityTextVal[feat][txt].add(val)

                entityIdent.setdefault(ident, []).append(e)
                if ident not in entityIdentFirst:
                    entityIdentFirst[ident] = e

                entitySummary.setdefault(summary, []).append(e)
                entitySlotVal.setdefault(slots, set()).add(fVals)

                firstSlot = slots[0]
                lastSlot = slots[-1]

                entitySlotAll.setdefault(firstSlot, set()).add(lastSlot)

                for slot in slots:
                    isFirst = slot == firstSlot
                    isLast = slot == lastSlot
                    if isFirst or isLast:
                        if isFirst:
                            entitySlotIndex.setdefault(slot, []).append(
                                [True, firstSlot - lastSlot - 1, ident]
                            )
                        if isLast:
                            entitySlotIndex.setdefault(slot, []).append(
                                [False, lastSlot - firstSlot + 1, ident]
                            )
                    else:
                        entitySlotIndex.setdefault(slot, []).append(None)

            setData.entityText = entityText
            setData.entityTextVal = entityTextVal
            setData.entitySummary = entitySummary
            setData.entityIdent = entityIdent
            setData.entityIdentFirst = entityIdentFirst
            setData.entityFreq = {
                feat: sorted(entityFreq[feat].items()) for feat in features
            }
            setData.entityIndex = entityIndex
            setData.entityVal = entityVal
            setData.entitySlotVal = entitySlotVal
            setData.entitySlotAll = entitySlotAll
            setData.entitySlotIndex = entitySlotIndex

            setData.dateProcessed = time.time()
            # self.console(&#34;done.&#34;)

        else:
            # self.console(f&#34;Data of {annoSetRep} already processed.&#34;)
            pass

    def delEntity(self, vals, allMatches=None, silent=True):
        setData = self.getSetData()

        oldEntities = setData.entities

        delEntities = set()

        oldEntitiesBySlots = set()

        for e, (fVals, slots) in oldEntities.items():
            if fVals == vals:
                oldEntitiesBySlots.add(slots)

        missing = 0
        deleted = 0

        delSlots = oldEntitiesBySlots if allMatches is None else allMatches

        for slots in delSlots:
            if slots not in oldEntitiesBySlots:
                missing += 1
                continue

            delEntities.add((vals, slots))
            deleted += 1

        if len(delEntities):
            self.weedEntities(delEntities)

        self.loadData()
        if not silent:
            self.console(f&#34;Not present: {missing:&gt;5} x&#34;)
            self.console(f&#34;Deleted:     {deleted:&gt;5} x&#34;)

    def delEntityRich(self, deletions, buckets, excludedTokens=set()):
        settings = self.settings
        features = settings.features
        browse = self.browse
        setData = self.getSetData()

        oldEntities = setData.entities

        report = []

        delEntities = set()
        delEntitiesByE = set()

        deletions = tuple([x] if type(x) is str else x for x in deletions)

        if any(len(x) &gt; 0 for x in deletions):
            oldEntitiesBySlots = collections.defaultdict(set)

            for e, info in oldEntities.items():
                oldEntitiesBySlots[info[1]].add(e)

            excl = 0

            fValTuples = [()]

            for vals in deletions:
                delTuples = []
                for val in vals:
                    delTuples.extend([ft + (val,) for ft in fValTuples])
                fValTuples = delTuples

            stats = collections.Counter()

            for b, bTokens, allMatches, positions in buckets:
                for slots in allMatches:
                    if slots[-1] in excludedTokens:
                        excl += 1
                        continue

                    candidates = oldEntitiesBySlots.get(slots, set())

                    for e in candidates:
                        toBeDeleted = False
                        fVals = oldEntities[e][0]

                        if fVals in fValTuples:
                            toBeDeleted = True

                        if toBeDeleted:
                            if e not in delEntitiesByE:
                                delEntitiesByE.add(e)
                                delEntities.add((fVals, slots))
                                stats[fVals] += 1

            report.append(
                tuple(sorted(stats.items())) if len(stats) else [&#34;Nothing deleted&#34;]
            )
            if excl:
                report.append(f&#34;Deletion: occurences excluded: {excl}&#34;)

        if len(delEntities):
            self.weedEntities(delEntities)

        if browse:
            return report

        self.loadData()
        (stats, *rest) = report
        if type(stats) is list:
            self.console(&#34;\n&#34;.join(stats))
        else:
            for vals, freq in stats:
                repVals = &#34; &#34;.join(
                    f&#34;{feat}={val}&#34; for (feat, val) in zip(features, vals)
                )
                self.console(f&#34;Deleted {freq:&gt;5} x {repVals}&#34;)
        if len(rest):
            self.console(&#34;\n&#34;.join(rest))

    def addEntity(self, vals, allMatches, silent=True):
        setData = self.getSetData()

        oldEntities = setData.entities

        addEntities = set()

        oldEntitiesBySlots = set()

        for e, (fVals, slots) in oldEntities.items():
            if fVals == vals:
                oldEntitiesBySlots.add(slots)

        present = 0
        added = 0

        for slots in allMatches:
            if slots in oldEntitiesBySlots:
                present += 1
                continue

            info = (vals, slots)
            if info not in addEntities:
                addEntities.add(info)
                added += 1

        if len(addEntities):
            self.mergeEntities(addEntities)

        self.loadData()
        if not silent:
            self.console(f&#34;Already present: {present:&gt;5} x&#34;)
            self.console(f&#34;Added:           {added:&gt;5} x&#34;)
        return (present, added)

    def addEntities(self, newEntities, silent=True):
        setData = self.getSetData()

        oldEntities = set(setData.entities.values())

        addEntities = set()

        present = 0
        added = 0

        for fVals, allMatches in newEntities:
            for slots in allMatches:
                if (fVals, slots) in oldEntities:
                    present += 1
                elif (fVals, slots) in addEntities:
                    continue
                else:
                    added += 1
                    addEntities.add((fVals, slots))

        if len(addEntities):
            self.mergeEntities(addEntities)

        self.loadData()
        if not silent:
            self.console(f&#34;Already present: {present:&gt;5} x&#34;)
            self.console(f&#34;Added:           {added:&gt;5} x&#34;)
        return (present, added)

    def addEntityRich(self, additions, buckets, excludedTokens=set()):
        settings = self.settings
        features = settings.features

        browse = self.browse
        setData = self.getSetData()

        oldEntities = setData.entities

        report = []

        addEntities = set()

        additions = tuple([x] if type(x) is str else x for x in additions)

        if all(len(x) &gt; 0 for x in additions):
            oldEntitiesBySlots = collections.defaultdict(set)

            for e, (fVals, slots) in oldEntities.items():
                oldEntitiesBySlots[slots].add(fVals)

            excl = 0

            fValTuples = [()]

            for vals in additions:
                newTuples = []
                for val in vals:
                    newTuples.extend([ft + (val,) for ft in fValTuples])
                fValTuples = newTuples

            stats = collections.Counter()

            for b, bTokens, allMatches, positions in buckets:
                for slots in allMatches:
                    if slots[-1] in excludedTokens:
                        excl += 1
                        continue

                    existing = oldEntitiesBySlots.get(slots, set())

                    for fVals in fValTuples:
                        if fVals in existing:
                            continue
                        info = (fVals, slots)
                        if info not in addEntities:
                            addEntities.add(info)
                            stats[fVals] += 1

            report.append(
                tuple(sorted(stats.items())) if len(stats) else [&#34;Nothing added&#34;]
            )
            if excl:
                report.append(f&#34;Addition: occurences excluded: {excl}&#34;)

        if len(addEntities):
            self.mergeEntities(addEntities)

        if browse:
            return report

        self.loadData()
        (stats, *rest) = report
        if type(stats) is list:
            self.console(&#34;\n&#34;.join(stats))
        else:
            for vals, freq in stats:
                repVals = &#34; &#34;.join(
                    f&#34;{feat}={val}&#34; for (feat, val) in zip(features, vals)
                )
                self.console(f&#34;Added {freq:&gt;5} x {repVals}&#34;)
        if len(rest):
            self.console(&#34;\n&#34;.join(rest))

    def weedEntities(self, delEntities):
        settings = self.settings
        features = settings.features
        nF = len(features)

        annoSet = self.annoSet
        annoDir = self.annoDir

        dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

        newEntities = []

        with open(dataFile) as fh:
            for line in fh:
                fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
                fVals = tuple(fields[0:nF])
                slots = tuple(int(f) for f in fields[nF:])
                info = (fVals, slots)
                if info in delEntities:
                    continue
                newEntities.append(line)

        with open(dataFile, &#34;w&#34;) as fh:
            fh.write(&#34;&#34;.join(newEntities))

    def mergeEntities(self, newEntities):
        annoSet = self.annoSet
        annoDir = self.annoDir

        dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

        with open(dataFile, &#34;a&#34;) as fh:
            for fVals, slots in newEntities:
                fh.write(&#34;\t&#34;.join(str(x) for x in (*fVals, *slots)) + &#34;\n&#34;)

    def saveEntitiesAs(self, dataFile):
        setData = self.getSetData()
        entities = setData.entities

        with open(dataFile, &#34;a&#34;) as fh:
            for fVals, slots in entities.values():
                fh.write(&#34;\t&#34;.join(str(x) for x in (*fVals, *slots)) + &#34;\n&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.browser.ner.data.Data"><code class="flex name class">
<span>class <span class="ident">Data</span></span>
<span>(</span><span>data=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/data.py#L13-L554" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Data(Settings):
    def __init__(self, data=None):
        super().__init__()

        if data is None:
            data = AttrDict()
            data.sets = AttrDict()

        self.data = data

        annoDir = self.annoDir
        initTree(annoDir, fresh=False)

    def loadData(self):
        &#34;&#34;&#34;Loads data of the given annotation set from disk into memory.

        The data of an annotation set consists of:

        *   a dict of entities, keyed by nodes or line numbers;
            each entity specifies a tuple of feature values and a list of slots
            that are part of the entity.

        If `annoSet` is empty, the annotation data is already in the TF data, and we do not
        do anything.

        After loading we process the data into derived datastructures.

        We try to be lazy. We only load data from disk if the data is not already in memory,
        or the data on disk has been updated since the last load.

        Likewise, we only process the data if the data has been loaded again.

        The resulting data is stored on the object
        and then under the key `sets` and then the name of the annotation set.

        For each such set we produce the following keys:

        *   `dateLoaded`: datetime when the data was last loaded from disk
        *   `dateProcessed`: datetime when the data was last processed
        *   `entities`: the list of entities as loaded from a tsv file

        We then process this into several data structures, each identified
        by a different key.
        &#34;&#34;&#34;
        data = self.data
        annoSet = self.annoSet

        if &#34;sets&#34; not in data:
            data.sets = AttrDict()

        sets = data.sets

        if annoSet not in sets:
            sets[annoSet] = AttrDict()

        # load bucket nodes

        changed = self.fromSource()
        self.process(changed)

    def fromSource(self):
        settings = self.settings
        bucketType = settings.bucketType
        app = self.app
        data = self.data
        annoSet = self.annoSet
        # annoSetRep = self.annoSetRep
        setData = data.sets[annoSet]
        annoDir = self.annoDir

        settings = self.settings
        entityType = settings.entityType
        features = settings.features
        nF = len(features)

        api = app.api
        F = api.F
        Fs = api.Fs
        L = api.L

        slotType = F.otype.slotType

        dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

        if &#34;buckets&#34; not in setData:
            setData.buckets = F.otype.s(bucketType)

        changed = False

        if annoSet:
            if (
                &#34;entities&#34; not in setData
                or &#34;dateLoaded&#34; not in setData
                or (len(setData.entities) &gt; 0 and not fileExists(dataFile))
                or (fileExists(dataFile) and setData.dateLoaded &lt; mTime(dataFile))
            ):
                # self.console(f&#34;Loading data for {annoSet} ... &#34;, newline=False)
                changed = True
                entities = {}

                if fileExists(dataFile):
                    with open(dataFile) as df:
                        for e, line in enumerate(df):
                            fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
                            entities[e] = (
                                tuple(fields[0:nF]),
                                tuple(int(f) for f in fields[nF:]),
                            )

                setData.entities = entities
                setData.dateLoaded = time.time()
                # self.console(&#34;done.&#34;)
            else:
                # self.console(f&#34;Data for {annoSetRep} already loaded&#34;)
                pass
        else:
            if &#34;entities&#34; not in setData:
                entities = {}
                hasFeature = {
                    feat: api.isLoaded(feat, pretty=False)[feat] is not None
                    for feat in features
                }

                for e in F.otype.s(entityType):
                    slots = L.d(e, otype=slotType)
                    entities[e] = (
                        tuple(
                            Fs(feat).v(e)
                            if hasFeature[feat]
                            else self.featureDefault[feat](F, slots)
                            for feat in features
                        ),
                        tuple(slots),
                    )

                setData.entities = entities

        return changed

    def process(self, changed):
        settings = self.settings
        features = settings.features
        summaryIndices = settings.summaryIndices

        app = self.app
        data = self.data
        annoSet = self.annoSet
        # annoSetRep = self.annoSetRep
        setData = data.sets[annoSet]

        api = app.api
        F = api.F

        dateLoaded = setData.dateLoaded
        dateProcessed = setData.dateProcessed

        if (
            changed
            or &#34;dateProcessed&#34; not in setData
            or &#34;entityText&#34; not in setData
            or &#34;entityTextVal&#34; not in setData
            or &#34;entitySummary&#34; not in setData
            or &#34;entityIdent&#34; not in setData
            or &#34;entityFreq&#34; not in setData
            or &#34;entityIndex&#34; not in setData
            or &#34;entityVal&#34; not in setData
            or &#34;entitySlotVal&#34; not in setData
            or &#34;entitySlotAll&#34; not in setData
            or &#34;entitySlotIndex&#34; not in setData
            or dateLoaded is not None
            and dateProcessed &lt; dateLoaded
        ):
            # self.console(f&#34;Processing data of {annoSetRep} ... &#34;, newline=False)

            entityItems = setData.entities.items()

            entityText = {}
            entityTextVal = {feat: collections.defaultdict(set) for feat in features}
            entitySummary = {}
            entityIdent = {}
            entityIdentFirst = {}
            entityFreq = {feat: collections.Counter() for feat in features}
            entityIndex = {feat: {} for feat in features}
            entityVal = {}
            entitySlotVal = {}
            entitySlotAll = {}
            entitySlotIndex = {}

            for e, (fVals, slots) in entityItems:
                txt = getText(F, slots)
                ident = fVals
                summary = tuple(fVals[i] for i in summaryIndices)

                entityText[e] = txt
                entityVal.setdefault(fVals, set()).add(slots)

                for feat, val in zip(features, fVals):
                    entityFreq[feat][val] += 1
                    entityIndex[feat].setdefault(slots, set()).add(val)
                    entityTextVal[feat][txt].add(val)

                entityIdent.setdefault(ident, []).append(e)
                if ident not in entityIdentFirst:
                    entityIdentFirst[ident] = e

                entitySummary.setdefault(summary, []).append(e)
                entitySlotVal.setdefault(slots, set()).add(fVals)

                firstSlot = slots[0]
                lastSlot = slots[-1]

                entitySlotAll.setdefault(firstSlot, set()).add(lastSlot)

                for slot in slots:
                    isFirst = slot == firstSlot
                    isLast = slot == lastSlot
                    if isFirst or isLast:
                        if isFirst:
                            entitySlotIndex.setdefault(slot, []).append(
                                [True, firstSlot - lastSlot - 1, ident]
                            )
                        if isLast:
                            entitySlotIndex.setdefault(slot, []).append(
                                [False, lastSlot - firstSlot + 1, ident]
                            )
                    else:
                        entitySlotIndex.setdefault(slot, []).append(None)

            setData.entityText = entityText
            setData.entityTextVal = entityTextVal
            setData.entitySummary = entitySummary
            setData.entityIdent = entityIdent
            setData.entityIdentFirst = entityIdentFirst
            setData.entityFreq = {
                feat: sorted(entityFreq[feat].items()) for feat in features
            }
            setData.entityIndex = entityIndex
            setData.entityVal = entityVal
            setData.entitySlotVal = entitySlotVal
            setData.entitySlotAll = entitySlotAll
            setData.entitySlotIndex = entitySlotIndex

            setData.dateProcessed = time.time()
            # self.console(&#34;done.&#34;)

        else:
            # self.console(f&#34;Data of {annoSetRep} already processed.&#34;)
            pass

    def delEntity(self, vals, allMatches=None, silent=True):
        setData = self.getSetData()

        oldEntities = setData.entities

        delEntities = set()

        oldEntitiesBySlots = set()

        for e, (fVals, slots) in oldEntities.items():
            if fVals == vals:
                oldEntitiesBySlots.add(slots)

        missing = 0
        deleted = 0

        delSlots = oldEntitiesBySlots if allMatches is None else allMatches

        for slots in delSlots:
            if slots not in oldEntitiesBySlots:
                missing += 1
                continue

            delEntities.add((vals, slots))
            deleted += 1

        if len(delEntities):
            self.weedEntities(delEntities)

        self.loadData()
        if not silent:
            self.console(f&#34;Not present: {missing:&gt;5} x&#34;)
            self.console(f&#34;Deleted:     {deleted:&gt;5} x&#34;)

    def delEntityRich(self, deletions, buckets, excludedTokens=set()):
        settings = self.settings
        features = settings.features
        browse = self.browse
        setData = self.getSetData()

        oldEntities = setData.entities

        report = []

        delEntities = set()
        delEntitiesByE = set()

        deletions = tuple([x] if type(x) is str else x for x in deletions)

        if any(len(x) &gt; 0 for x in deletions):
            oldEntitiesBySlots = collections.defaultdict(set)

            for e, info in oldEntities.items():
                oldEntitiesBySlots[info[1]].add(e)

            excl = 0

            fValTuples = [()]

            for vals in deletions:
                delTuples = []
                for val in vals:
                    delTuples.extend([ft + (val,) for ft in fValTuples])
                fValTuples = delTuples

            stats = collections.Counter()

            for b, bTokens, allMatches, positions in buckets:
                for slots in allMatches:
                    if slots[-1] in excludedTokens:
                        excl += 1
                        continue

                    candidates = oldEntitiesBySlots.get(slots, set())

                    for e in candidates:
                        toBeDeleted = False
                        fVals = oldEntities[e][0]

                        if fVals in fValTuples:
                            toBeDeleted = True

                        if toBeDeleted:
                            if e not in delEntitiesByE:
                                delEntitiesByE.add(e)
                                delEntities.add((fVals, slots))
                                stats[fVals] += 1

            report.append(
                tuple(sorted(stats.items())) if len(stats) else [&#34;Nothing deleted&#34;]
            )
            if excl:
                report.append(f&#34;Deletion: occurences excluded: {excl}&#34;)

        if len(delEntities):
            self.weedEntities(delEntities)

        if browse:
            return report

        self.loadData()
        (stats, *rest) = report
        if type(stats) is list:
            self.console(&#34;\n&#34;.join(stats))
        else:
            for vals, freq in stats:
                repVals = &#34; &#34;.join(
                    f&#34;{feat}={val}&#34; for (feat, val) in zip(features, vals)
                )
                self.console(f&#34;Deleted {freq:&gt;5} x {repVals}&#34;)
        if len(rest):
            self.console(&#34;\n&#34;.join(rest))

    def addEntity(self, vals, allMatches, silent=True):
        setData = self.getSetData()

        oldEntities = setData.entities

        addEntities = set()

        oldEntitiesBySlots = set()

        for e, (fVals, slots) in oldEntities.items():
            if fVals == vals:
                oldEntitiesBySlots.add(slots)

        present = 0
        added = 0

        for slots in allMatches:
            if slots in oldEntitiesBySlots:
                present += 1
                continue

            info = (vals, slots)
            if info not in addEntities:
                addEntities.add(info)
                added += 1

        if len(addEntities):
            self.mergeEntities(addEntities)

        self.loadData()
        if not silent:
            self.console(f&#34;Already present: {present:&gt;5} x&#34;)
            self.console(f&#34;Added:           {added:&gt;5} x&#34;)
        return (present, added)

    def addEntities(self, newEntities, silent=True):
        setData = self.getSetData()

        oldEntities = set(setData.entities.values())

        addEntities = set()

        present = 0
        added = 0

        for fVals, allMatches in newEntities:
            for slots in allMatches:
                if (fVals, slots) in oldEntities:
                    present += 1
                elif (fVals, slots) in addEntities:
                    continue
                else:
                    added += 1
                    addEntities.add((fVals, slots))

        if len(addEntities):
            self.mergeEntities(addEntities)

        self.loadData()
        if not silent:
            self.console(f&#34;Already present: {present:&gt;5} x&#34;)
            self.console(f&#34;Added:           {added:&gt;5} x&#34;)
        return (present, added)

    def addEntityRich(self, additions, buckets, excludedTokens=set()):
        settings = self.settings
        features = settings.features

        browse = self.browse
        setData = self.getSetData()

        oldEntities = setData.entities

        report = []

        addEntities = set()

        additions = tuple([x] if type(x) is str else x for x in additions)

        if all(len(x) &gt; 0 for x in additions):
            oldEntitiesBySlots = collections.defaultdict(set)

            for e, (fVals, slots) in oldEntities.items():
                oldEntitiesBySlots[slots].add(fVals)

            excl = 0

            fValTuples = [()]

            for vals in additions:
                newTuples = []
                for val in vals:
                    newTuples.extend([ft + (val,) for ft in fValTuples])
                fValTuples = newTuples

            stats = collections.Counter()

            for b, bTokens, allMatches, positions in buckets:
                for slots in allMatches:
                    if slots[-1] in excludedTokens:
                        excl += 1
                        continue

                    existing = oldEntitiesBySlots.get(slots, set())

                    for fVals in fValTuples:
                        if fVals in existing:
                            continue
                        info = (fVals, slots)
                        if info not in addEntities:
                            addEntities.add(info)
                            stats[fVals] += 1

            report.append(
                tuple(sorted(stats.items())) if len(stats) else [&#34;Nothing added&#34;]
            )
            if excl:
                report.append(f&#34;Addition: occurences excluded: {excl}&#34;)

        if len(addEntities):
            self.mergeEntities(addEntities)

        if browse:
            return report

        self.loadData()
        (stats, *rest) = report
        if type(stats) is list:
            self.console(&#34;\n&#34;.join(stats))
        else:
            for vals, freq in stats:
                repVals = &#34; &#34;.join(
                    f&#34;{feat}={val}&#34; for (feat, val) in zip(features, vals)
                )
                self.console(f&#34;Added {freq:&gt;5} x {repVals}&#34;)
        if len(rest):
            self.console(&#34;\n&#34;.join(rest))

    def weedEntities(self, delEntities):
        settings = self.settings
        features = settings.features
        nF = len(features)

        annoSet = self.annoSet
        annoDir = self.annoDir

        dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

        newEntities = []

        with open(dataFile) as fh:
            for line in fh:
                fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
                fVals = tuple(fields[0:nF])
                slots = tuple(int(f) for f in fields[nF:])
                info = (fVals, slots)
                if info in delEntities:
                    continue
                newEntities.append(line)

        with open(dataFile, &#34;w&#34;) as fh:
            fh.write(&#34;&#34;.join(newEntities))

    def mergeEntities(self, newEntities):
        annoSet = self.annoSet
        annoDir = self.annoDir

        dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

        with open(dataFile, &#34;a&#34;) as fh:
            for fVals, slots in newEntities:
                fh.write(&#34;\t&#34;.join(str(x) for x in (*fVals, *slots)) + &#34;\n&#34;)

    def saveEntitiesAs(self, dataFile):
        setData = self.getSetData()
        entities = setData.entities

        with open(dataFile, &#34;a&#34;) as fh:
            for fVals, slots in entities.values():
                fh.write(&#34;\t&#34;.join(str(x) for x in (*fVals, *slots)) + &#34;\n&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tf.browser.ner.settings.Settings" href="settings.html#tf.browser.ner.settings.Settings">Settings</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tf.browser.ner.sets.Sets" href="sets.html#tf.browser.ner.sets.Sets">Sets</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tf.browser.ner.data.Data.addEntities"><code class="name flex">
<span>def <span class="ident">addEntities</span></span>(<span>self, newEntities, silent=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/data.py#L410-L437" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addEntities(self, newEntities, silent=True):
    setData = self.getSetData()

    oldEntities = set(setData.entities.values())

    addEntities = set()

    present = 0
    added = 0

    for fVals, allMatches in newEntities:
        for slots in allMatches:
            if (fVals, slots) in oldEntities:
                present += 1
            elif (fVals, slots) in addEntities:
                continue
            else:
                added += 1
                addEntities.add((fVals, slots))

    if len(addEntities):
        self.mergeEntities(addEntities)

    self.loadData()
    if not silent:
        self.console(f&#34;Already present: {present:&gt;5} x&#34;)
        self.console(f&#34;Added:           {added:&gt;5} x&#34;)
    return (present, added)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.addEntity"><code class="name flex">
<span>def <span class="ident">addEntity</span></span>(<span>self, vals, allMatches, silent=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/data.py#L375-L408" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addEntity(self, vals, allMatches, silent=True):
    setData = self.getSetData()

    oldEntities = setData.entities

    addEntities = set()

    oldEntitiesBySlots = set()

    for e, (fVals, slots) in oldEntities.items():
        if fVals == vals:
            oldEntitiesBySlots.add(slots)

    present = 0
    added = 0

    for slots in allMatches:
        if slots in oldEntitiesBySlots:
            present += 1
            continue

        info = (vals, slots)
        if info not in addEntities:
            addEntities.add(info)
            added += 1

    if len(addEntities):
        self.mergeEntities(addEntities)

    self.loadData()
    if not silent:
        self.console(f&#34;Already present: {present:&gt;5} x&#34;)
        self.console(f&#34;Added:           {added:&gt;5} x&#34;)
    return (present, added)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.addEntityRich"><code class="name flex">
<span>def <span class="ident">addEntityRich</span></span>(<span>self, additions, buckets, excludedTokens=set())</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/data.py#L439-L511" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addEntityRich(self, additions, buckets, excludedTokens=set()):
    settings = self.settings
    features = settings.features

    browse = self.browse
    setData = self.getSetData()

    oldEntities = setData.entities

    report = []

    addEntities = set()

    additions = tuple([x] if type(x) is str else x for x in additions)

    if all(len(x) &gt; 0 for x in additions):
        oldEntitiesBySlots = collections.defaultdict(set)

        for e, (fVals, slots) in oldEntities.items():
            oldEntitiesBySlots[slots].add(fVals)

        excl = 0

        fValTuples = [()]

        for vals in additions:
            newTuples = []
            for val in vals:
                newTuples.extend([ft + (val,) for ft in fValTuples])
            fValTuples = newTuples

        stats = collections.Counter()

        for b, bTokens, allMatches, positions in buckets:
            for slots in allMatches:
                if slots[-1] in excludedTokens:
                    excl += 1
                    continue

                existing = oldEntitiesBySlots.get(slots, set())

                for fVals in fValTuples:
                    if fVals in existing:
                        continue
                    info = (fVals, slots)
                    if info not in addEntities:
                        addEntities.add(info)
                        stats[fVals] += 1

        report.append(
            tuple(sorted(stats.items())) if len(stats) else [&#34;Nothing added&#34;]
        )
        if excl:
            report.append(f&#34;Addition: occurences excluded: {excl}&#34;)

    if len(addEntities):
        self.mergeEntities(addEntities)

    if browse:
        return report

    self.loadData()
    (stats, *rest) = report
    if type(stats) is list:
        self.console(&#34;\n&#34;.join(stats))
    else:
        for vals, freq in stats:
            repVals = &#34; &#34;.join(
                f&#34;{feat}={val}&#34; for (feat, val) in zip(features, vals)
            )
            self.console(f&#34;Added {freq:&gt;5} x {repVals}&#34;)
    if len(rest):
        self.console(&#34;\n&#34;.join(rest))</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.delEntity"><code class="name flex">
<span>def <span class="ident">delEntity</span></span>(<span>self, vals, allMatches=None, silent=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/data.py#L262-L294" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delEntity(self, vals, allMatches=None, silent=True):
    setData = self.getSetData()

    oldEntities = setData.entities

    delEntities = set()

    oldEntitiesBySlots = set()

    for e, (fVals, slots) in oldEntities.items():
        if fVals == vals:
            oldEntitiesBySlots.add(slots)

    missing = 0
    deleted = 0

    delSlots = oldEntitiesBySlots if allMatches is None else allMatches

    for slots in delSlots:
        if slots not in oldEntitiesBySlots:
            missing += 1
            continue

        delEntities.add((vals, slots))
        deleted += 1

    if len(delEntities):
        self.weedEntities(delEntities)

    self.loadData()
    if not silent:
        self.console(f&#34;Not present: {missing:&gt;5} x&#34;)
        self.console(f&#34;Deleted:     {deleted:&gt;5} x&#34;)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.delEntityRich"><code class="name flex">
<span>def <span class="ident">delEntityRich</span></span>(<span>self, deletions, buckets, excludedTokens=set())</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/data.py#L296-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delEntityRich(self, deletions, buckets, excludedTokens=set()):
    settings = self.settings
    features = settings.features
    browse = self.browse
    setData = self.getSetData()

    oldEntities = setData.entities

    report = []

    delEntities = set()
    delEntitiesByE = set()

    deletions = tuple([x] if type(x) is str else x for x in deletions)

    if any(len(x) &gt; 0 for x in deletions):
        oldEntitiesBySlots = collections.defaultdict(set)

        for e, info in oldEntities.items():
            oldEntitiesBySlots[info[1]].add(e)

        excl = 0

        fValTuples = [()]

        for vals in deletions:
            delTuples = []
            for val in vals:
                delTuples.extend([ft + (val,) for ft in fValTuples])
            fValTuples = delTuples

        stats = collections.Counter()

        for b, bTokens, allMatches, positions in buckets:
            for slots in allMatches:
                if slots[-1] in excludedTokens:
                    excl += 1
                    continue

                candidates = oldEntitiesBySlots.get(slots, set())

                for e in candidates:
                    toBeDeleted = False
                    fVals = oldEntities[e][0]

                    if fVals in fValTuples:
                        toBeDeleted = True

                    if toBeDeleted:
                        if e not in delEntitiesByE:
                            delEntitiesByE.add(e)
                            delEntities.add((fVals, slots))
                            stats[fVals] += 1

        report.append(
            tuple(sorted(stats.items())) if len(stats) else [&#34;Nothing deleted&#34;]
        )
        if excl:
            report.append(f&#34;Deletion: occurences excluded: {excl}&#34;)

    if len(delEntities):
        self.weedEntities(delEntities)

    if browse:
        return report

    self.loadData()
    (stats, *rest) = report
    if type(stats) is list:
        self.console(&#34;\n&#34;.join(stats))
    else:
        for vals, freq in stats:
            repVals = &#34; &#34;.join(
                f&#34;{feat}={val}&#34; for (feat, val) in zip(features, vals)
            )
            self.console(f&#34;Deleted {freq:&gt;5} x {repVals}&#34;)
    if len(rest):
        self.console(&#34;\n&#34;.join(rest))</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.fromSource"><code class="name flex">
<span>def <span class="ident">fromSource</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/data.py#L73-L150" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fromSource(self):
    settings = self.settings
    bucketType = settings.bucketType
    app = self.app
    data = self.data
    annoSet = self.annoSet
    # annoSetRep = self.annoSetRep
    setData = data.sets[annoSet]
    annoDir = self.annoDir

    settings = self.settings
    entityType = settings.entityType
    features = settings.features
    nF = len(features)

    api = app.api
    F = api.F
    Fs = api.Fs
    L = api.L

    slotType = F.otype.slotType

    dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

    if &#34;buckets&#34; not in setData:
        setData.buckets = F.otype.s(bucketType)

    changed = False

    if annoSet:
        if (
            &#34;entities&#34; not in setData
            or &#34;dateLoaded&#34; not in setData
            or (len(setData.entities) &gt; 0 and not fileExists(dataFile))
            or (fileExists(dataFile) and setData.dateLoaded &lt; mTime(dataFile))
        ):
            # self.console(f&#34;Loading data for {annoSet} ... &#34;, newline=False)
            changed = True
            entities = {}

            if fileExists(dataFile):
                with open(dataFile) as df:
                    for e, line in enumerate(df):
                        fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
                        entities[e] = (
                            tuple(fields[0:nF]),
                            tuple(int(f) for f in fields[nF:]),
                        )

            setData.entities = entities
            setData.dateLoaded = time.time()
            # self.console(&#34;done.&#34;)
        else:
            # self.console(f&#34;Data for {annoSetRep} already loaded&#34;)
            pass
    else:
        if &#34;entities&#34; not in setData:
            entities = {}
            hasFeature = {
                feat: api.isLoaded(feat, pretty=False)[feat] is not None
                for feat in features
            }

            for e in F.otype.s(entityType):
                slots = L.d(e, otype=slotType)
                entities[e] = (
                    tuple(
                        Fs(feat).v(e)
                        if hasFeature[feat]
                        else self.featureDefault[feat](F, slots)
                        for feat in features
                    ),
                    tuple(slots),
                )

            setData.entities = entities

    return changed</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.loadData"><code class="name flex">
<span>def <span class="ident">loadData</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads data of the given annotation set from disk into memory.</p>
<p>The data of an annotation set consists of:</p>
<ul>
<li>a dict of entities, keyed by nodes or line numbers;
each entity specifies a tuple of feature values and a list of slots
that are part of the entity.</li>
</ul>
<p>If <code>annoSet</code> is empty, the annotation data is already in the TF data, and we do not
do anything.</p>
<p>After loading we process the data into derived datastructures.</p>
<p>We try to be lazy. We only load data from disk if the data is not already in memory,
or the data on disk has been updated since the last load.</p>
<p>Likewise, we only process the data if the data has been loaded again.</p>
<p>The resulting data is stored on the object
and then under the key <code>sets</code> and then the name of the annotation set.</p>
<p>For each such set we produce the following keys:</p>
<ul>
<li><code>dateLoaded</code>: datetime when the data was last loaded from disk</li>
<li><code>dateProcessed</code>: datetime when the data was last processed</li>
<li><code>entities</code>: the list of entities as loaded from a tsv file</li>
</ul>
<p>We then process this into several data structures, each identified
by a different key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/data.py#L26-L71" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loadData(self):
    &#34;&#34;&#34;Loads data of the given annotation set from disk into memory.

    The data of an annotation set consists of:

    *   a dict of entities, keyed by nodes or line numbers;
        each entity specifies a tuple of feature values and a list of slots
        that are part of the entity.

    If `annoSet` is empty, the annotation data is already in the TF data, and we do not
    do anything.

    After loading we process the data into derived datastructures.

    We try to be lazy. We only load data from disk if the data is not already in memory,
    or the data on disk has been updated since the last load.

    Likewise, we only process the data if the data has been loaded again.

    The resulting data is stored on the object
    and then under the key `sets` and then the name of the annotation set.

    For each such set we produce the following keys:

    *   `dateLoaded`: datetime when the data was last loaded from disk
    *   `dateProcessed`: datetime when the data was last processed
    *   `entities`: the list of entities as loaded from a tsv file

    We then process this into several data structures, each identified
    by a different key.
    &#34;&#34;&#34;
    data = self.data
    annoSet = self.annoSet

    if &#34;sets&#34; not in data:
        data.sets = AttrDict()

    sets = data.sets

    if annoSet not in sets:
        sets[annoSet] = AttrDict()

    # load bucket nodes

    changed = self.fromSource()
    self.process(changed)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.mergeEntities"><code class="name flex">
<span>def <span class="ident">mergeEntities</span></span>(<span>self, newEntities)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/data.py#L538-L546" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mergeEntities(self, newEntities):
    annoSet = self.annoSet
    annoDir = self.annoDir

    dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

    with open(dataFile, &#34;a&#34;) as fh:
        for fVals, slots in newEntities:
            fh.write(&#34;\t&#34;.join(str(x) for x in (*fVals, *slots)) + &#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self, changed)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/data.py#L152-L260" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def process(self, changed):
    settings = self.settings
    features = settings.features
    summaryIndices = settings.summaryIndices

    app = self.app
    data = self.data
    annoSet = self.annoSet
    # annoSetRep = self.annoSetRep
    setData = data.sets[annoSet]

    api = app.api
    F = api.F

    dateLoaded = setData.dateLoaded
    dateProcessed = setData.dateProcessed

    if (
        changed
        or &#34;dateProcessed&#34; not in setData
        or &#34;entityText&#34; not in setData
        or &#34;entityTextVal&#34; not in setData
        or &#34;entitySummary&#34; not in setData
        or &#34;entityIdent&#34; not in setData
        or &#34;entityFreq&#34; not in setData
        or &#34;entityIndex&#34; not in setData
        or &#34;entityVal&#34; not in setData
        or &#34;entitySlotVal&#34; not in setData
        or &#34;entitySlotAll&#34; not in setData
        or &#34;entitySlotIndex&#34; not in setData
        or dateLoaded is not None
        and dateProcessed &lt; dateLoaded
    ):
        # self.console(f&#34;Processing data of {annoSetRep} ... &#34;, newline=False)

        entityItems = setData.entities.items()

        entityText = {}
        entityTextVal = {feat: collections.defaultdict(set) for feat in features}
        entitySummary = {}
        entityIdent = {}
        entityIdentFirst = {}
        entityFreq = {feat: collections.Counter() for feat in features}
        entityIndex = {feat: {} for feat in features}
        entityVal = {}
        entitySlotVal = {}
        entitySlotAll = {}
        entitySlotIndex = {}

        for e, (fVals, slots) in entityItems:
            txt = getText(F, slots)
            ident = fVals
            summary = tuple(fVals[i] for i in summaryIndices)

            entityText[e] = txt
            entityVal.setdefault(fVals, set()).add(slots)

            for feat, val in zip(features, fVals):
                entityFreq[feat][val] += 1
                entityIndex[feat].setdefault(slots, set()).add(val)
                entityTextVal[feat][txt].add(val)

            entityIdent.setdefault(ident, []).append(e)
            if ident not in entityIdentFirst:
                entityIdentFirst[ident] = e

            entitySummary.setdefault(summary, []).append(e)
            entitySlotVal.setdefault(slots, set()).add(fVals)

            firstSlot = slots[0]
            lastSlot = slots[-1]

            entitySlotAll.setdefault(firstSlot, set()).add(lastSlot)

            for slot in slots:
                isFirst = slot == firstSlot
                isLast = slot == lastSlot
                if isFirst or isLast:
                    if isFirst:
                        entitySlotIndex.setdefault(slot, []).append(
                            [True, firstSlot - lastSlot - 1, ident]
                        )
                    if isLast:
                        entitySlotIndex.setdefault(slot, []).append(
                            [False, lastSlot - firstSlot + 1, ident]
                        )
                else:
                    entitySlotIndex.setdefault(slot, []).append(None)

        setData.entityText = entityText
        setData.entityTextVal = entityTextVal
        setData.entitySummary = entitySummary
        setData.entityIdent = entityIdent
        setData.entityIdentFirst = entityIdentFirst
        setData.entityFreq = {
            feat: sorted(entityFreq[feat].items()) for feat in features
        }
        setData.entityIndex = entityIndex
        setData.entityVal = entityVal
        setData.entitySlotVal = entitySlotVal
        setData.entitySlotAll = entitySlotAll
        setData.entitySlotIndex = entitySlotIndex

        setData.dateProcessed = time.time()
        # self.console(&#34;done.&#34;)

    else:
        # self.console(f&#34;Data of {annoSetRep} already processed.&#34;)
        pass</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.saveEntitiesAs"><code class="name flex">
<span>def <span class="ident">saveEntitiesAs</span></span>(<span>self, dataFile)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/data.py#L548-L554" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def saveEntitiesAs(self, dataFile):
    setData = self.getSetData()
    entities = setData.entities

    with open(dataFile, &#34;a&#34;) as fh:
        for fVals, slots in entities.values():
            fh.write(&#34;\t&#34;.join(str(x) for x in (*fVals, *slots)) + &#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.weedEntities"><code class="name flex">
<span>def <span class="ident">weedEntities</span></span>(<span>self, delEntities)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20bf0897d3b01627067fb68739f1d7ae0f0aad84/tf/browser/ner/data.py#L513-L536" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def weedEntities(self, delEntities):
    settings = self.settings
    features = settings.features
    nF = len(features)

    annoSet = self.annoSet
    annoDir = self.annoDir

    dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

    newEntities = []

    with open(dataFile) as fh:
        for line in fh:
            fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
            fVals = tuple(fields[0:nF])
            slots = tuple(int(f) for f in fields[nF:])
            info = (fVals, slots)
            if info in delEntities:
                continue
            newEntities.append(line)

    with open(dataFile, &#34;w&#34;) as fh:
        fh.write(&#34;&#34;.join(newEntities))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.browser.ner" href="index.html">tf.browser.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.browser.ner.data.Data" href="#tf.browser.ner.data.Data">Data</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.browser.ner.data.Data.addEntities" href="#tf.browser.ner.data.Data.addEntities">addEntities</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.addEntity" href="#tf.browser.ner.data.Data.addEntity">addEntity</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.addEntityRich" href="#tf.browser.ner.data.Data.addEntityRich">addEntityRich</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.delEntity" href="#tf.browser.ner.data.Data.delEntity">delEntity</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.delEntityRich" href="#tf.browser.ner.data.Data.delEntityRich">delEntityRich</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.fromSource" href="#tf.browser.ner.data.Data.fromSource">fromSource</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.loadData" href="#tf.browser.ner.data.Data.loadData">loadData</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.mergeEntities" href="#tf.browser.ner.data.Data.mergeEntities">mergeEntities</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.process" href="#tf.browser.ner.data.Data.process">process</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.saveEntitiesAs" href="#tf.browser.ner.data.Data.saveEntitiesAs">saveEntitiesAs</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.weedEntities" href="#tf.browser.ner.data.Data.weedEntities">weedEntities</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>