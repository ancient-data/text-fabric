<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.browser.ner.data API documentation</title>
<meta name="description" content="Annotation data module â€¦" />
<!-- integrity SRI from https://cdnjs.com/libraries/10up-sanitize.css/11.0.1 -->
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha512-kcbluZFacWN57NgWZ4aH6eUMBEaTyErFhIFD3y5qYZbKuuyImH0K/AKsBbfXlivh2z5C+3IDTIhI11YmKomzmA=="
crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha512-uVeAgzAmieLUTGba0qr9vXQgVD7fko2kcbYIKIraXUIDg9iJLxveTFUrg3DJhqn3cAf3HFDbgmhq0eGko5wEAA=="
crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.browser.ner.data</code></h1>
</header>
<section id="section-intro">
<p>Annotation data module.</p>
<p>This module manages the data of annotations.</p>
<p>To see how this fits among all the modules of this package, see
<code><a title="tf.browser.ner.annotate" href="annotate.html">tf.browser.ner.annotate</a></code> .</p>
<p>Annotation data is either the set of pre-existing data in the corpus or the
result of actions by the user of this tool, whether he uses the TF browser, or the API
in his own programs.</p>
<p>Annotation data must be stored on file, must be read from file,
and must be represented in memory in various ways in order to make the
API functions of the tool efficient.</p>
<p>We have set up the functions in such a way that data is only loaded and
processed if it is needed and out of date.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/703d3977ff845baafe67bbbaa3a678e8deb2b911/tf/browser/ner/data.py#L1-L935" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Annotation data module.

This module manages the data of annotations.

To see how this fits among all the modules of this package, see
`tf.browser.ner.annotate` .

Annotation data is either the set of pre-existing data in the corpus or the
result of actions by the user of this tool, whether he uses the TF browser, or the API
in his own programs.

Annotation data must be stored on file, must be read from file,
and must be represented in memory in various ways in order to make the
API functions of the tool efficient.

We have set up the functions in such a way that data is only loaded and
processed if it is needed and out of date.
&#34;&#34;&#34;

import collections
import time

from ...core.generic import AttrDict
from ...core.files import (
    fileOpen,
    mTime,
    fileExists,
    initTree,
)
from .corpus import Corpus


class Data(Corpus):
    def __init__(self, data=None):
        &#34;&#34;&#34;Manages annotation data.

        This class is also responsible for adding entities to a set and deleting
        entities from them.

        Both addition and deletion is implemented by first figuring out what has to be
        done, and then applying it to the entity data on disk; after that we
        perform a data load from the update file.

        Parameters
        ----------
        data: object, optional None
            Entity data to start with.
            If None, a fresh data store will be created.

            When the tool runs in browser context, each request will create a
            `Data` object from scratch. If no data is provided to the initializer,
            it will need to load the required data from file.
            This is wasteful.

            We have set up the web server in such a way that it incorporates the
            annotation data. The web server will pass it to the
            `tf.browser.ner.annotate.Annotate` object initializer, which passes
            it to the initializer here.

            In that way, the `Data` object can start with the data already in memory.
        &#34;&#34;&#34;
        super().__init__()
        if not self.properlySetup:
            return

        if data is None:
            data = AttrDict()
            data.sets = AttrDict()

        self.data = data

        annoDir = self.annoDir
        initTree(annoDir, fresh=False)

    def loadData(self):
        &#34;&#34;&#34;Loads data of the current annotation set into memory.

        It has two phases:

        *   loading the source data (see `Data.fromSource()`)
        *   processing the loaded source data (see `Data.process()`)
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        data = self.data
        annoSet = self.annoSet

        if &#34;sets&#34; not in data:
            data.sets = AttrDict()

        sets = data.sets

        if annoSet not in sets:
            sets[annoSet] = AttrDict()

        # load bucket nodes

        changed = self.fromSource()
        self.process(changed)

    def fromSource(self):
        &#34;&#34;&#34;Loads annotation data from source.

        If the current annotation set is `&#34;&#34;`, the annotation data is already in
        the TF data,
        and we compile that data into a dict of entity data keyed by entity node.

        Otherwise, we read the corresponding TSV file from disk and compile that
        data into a dict of entity data keyed by line number.

        After collection of this data it is stored in the set data; in fact we store
        data under the following keys:

        *   `dateLoaded`: datetime when the data was last loaded from disk;
        *   `entities`: the list of entities as loaded from the source;
            it is a dict of entities, keyed by nodes or line numbers;
            each entity specifies a tuple of feature values and a list of slots
            that are part of the entity.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return None

        settings = self.settings
        data = self.data
        annoSet = self.annoSet
        setData = data.sets[annoSet]
        annoDir = self.annoDir

        settings = self.settings
        features = settings.features

        featureDefault = self.featureDefault
        nF = len(features)

        checkFeature = self.checkFeature
        getFVal = self.getFVal
        getSlots = self.getSlots

        dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

        if &#34;buckets&#34; not in setData:
            setData.buckets = self.getBucketNodes()

        changed = False

        if annoSet:
            if (
                &#34;entities&#34; not in setData
                or &#34;dateLoaded&#34; not in setData
                or (len(setData.entities) &gt; 0 and not fileExists(dataFile))
                or (fileExists(dataFile) and setData.dateLoaded &lt; mTime(dataFile))
            ):
                # self.console(f&#34;Loading data for {annoSet} ... &#34;, newline=False)
                changed = True
                entities = {}

                if fileExists(dataFile):
                    with fileOpen(dataFile) as df:
                        for e, line in enumerate(df):
                            fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
                            entities[e] = (
                                tuple(fields[0:nF]),
                                tuple(int(f) for f in fields[nF:]),
                            )

                setData.entities = entities
                setData.dateLoaded = time.time()
                # self.console(&#34;done.&#34;)
            else:
                # self.console(f&#34;Data for {annoSetRep} already loaded&#34;)
                pass
        else:
            if &#34;entities&#34; not in setData:
                entities = {}
                hasFeature = {feat: checkFeature(feat) for feat in features}

                for e in self.getEntityNodes():
                    slots = getSlots(e)
                    entities[e] = (
                        tuple(
                            getFVal(feat, e)
                            if hasFeature[feat]
                            else featureDefault[feat](slots)
                            for feat in features
                        ),
                        tuple(slots),
                    )

                setData.entities = entities

        return changed

    def process(self, changed):
        &#34;&#34;&#34;Generated derived data structures out of the source data.

        After loading we process the data into derived data structures.

        We try to be lazy. We only load data from disk if the data is not
        already in memory, or the data on disk has been updated since the last load.

        The resulting data is stored in current set under the various keys.

        After processing, the time of processing is recorded, so that it can be
        observed if the processed data is no longer up to date w.r.t. the data as
        loaded from source.

        For each such set we produce several data structures, which we store
        under the following keys:

        *   `dateProcessed`: datetime when the data was last processed
        *   `entityText`: dict, text of entity by entity node or line number in
            TSV file;
        *   `entityTextVal`: dict of dict, set of feature values of entity, keyed by
            feature name and then by text of the entity;
        *   `entitySummary`: dict, list of entity nodes / line numbers, keyed by value
            of entity kind;
        *   `entityIdent`: dict, list of entity nodes./line numbers, keyed by tuple of
            entity feature values (these tuples are identifying for an entity);
        *   `entityFreq`: dict of counters, a counter for each feature name; the
            counter gives the number of times each value of that feature occurs in an
            entity;
        *   `entityIndex`: dict of dict, a dict for each feature name; the sub-dict
            gives for each position the values that entities occupying that position
            can have; positions are tuples of slots;
        *   `entityVal`: dict, keyed by value tuples gives the set of positions
            that entities with that value tuple occupy;
        *   `entitySlotVal`: dict, keyed by positions gives the set of values
            that entities occupying that position can have;
        *   `entitySlotAll`: dict, keyed by single first slots gives the set of
            ending slots that entities starting at that first slot have;
        *   `entitySlotIndex`: dict, keyed by single slot gives list of items
            corresponding to entities that occupy that slot;

            *   if an entity starts there, an entry `[True, -n, values]` is made;
            *   if an entity ends there, an entry `[False, n, values]` is made;
            *   if an entity occupies that slot without starting or ending there,
                an entry `None` is made;

            Above, `n` is the length of the entity in tokens and `values` is the
            tuple of feature values of that entity.

            This is precisely the information we need if we want to mark up a set of
            entities in the surrounding context of tokens.

        Parameters
        ----------
        changed: boolean
            Whether the data has changed since last processing.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        settings = self.settings
        features = settings.features
        getText = self.getText
        summaryIndices = settings.summaryIndices

        data = self.data
        annoSet = self.annoSet
        # annoSetRep = self.annoSetRep
        setData = data.sets[annoSet]

        dateLoaded = setData.dateLoaded
        dateProcessed = setData.dateProcessed

        if (
            changed
            or &#34;dateProcessed&#34; not in setData
            or &#34;entityText&#34; not in setData
            or &#34;entityTextVal&#34; not in setData
            or &#34;entitySummary&#34; not in setData
            or &#34;entityIdent&#34; not in setData
            or &#34;entityFreq&#34; not in setData
            or &#34;entityIndex&#34; not in setData
            or &#34;entityVal&#34; not in setData
            or &#34;entitySlotVal&#34; not in setData
            or &#34;entitySlotAll&#34; not in setData
            or &#34;entitySlotIndex&#34; not in setData
            or dateLoaded is not None
            and dateProcessed &lt; dateLoaded
        ):
            # self.console(f&#34;Processing data of {annoSetRep} ... &#34;, newline=False)

            entityItems = setData.entities.items()

            entityText = {}
            entityTextVal = {feat: collections.defaultdict(set) for feat in features}
            entitySummary = {}
            entityIdent = {}
            entityIdentFirst = {}
            entityFreq = {feat: collections.Counter() for feat in features}
            entityIndex = {feat: {} for feat in features}
            entityVal = {}
            entitySlotVal = {}
            entitySlotAll = {}
            entitySlotIndex = {}

            for e, (fVals, slots) in entityItems:
                txt = getText(slots)
                ident = fVals
                summary = tuple(fVals[i] for i in summaryIndices)

                entityText[e] = txt
                entityVal.setdefault(fVals, set()).add(slots)

                for feat, val in zip(features, fVals):
                    entityFreq[feat][val] += 1
                    entityIndex[feat].setdefault(slots, set()).add(val)
                    entityTextVal[feat][txt].add(val)

                entityIdent.setdefault(ident, []).append(e)
                if ident not in entityIdentFirst:
                    entityIdentFirst[ident] = e

                entitySummary.setdefault(summary, []).append(e)
                entitySlotVal.setdefault(slots, set()).add(fVals)

                firstSlot = slots[0]
                lastSlot = slots[-1]

                entitySlotAll.setdefault(firstSlot, set()).add(lastSlot)

                for slot in slots:
                    isFirst = slot == firstSlot
                    isLast = slot == lastSlot
                    if isFirst or isLast:
                        if isFirst:
                            entitySlotIndex.setdefault(slot, []).append(
                                [True, firstSlot - lastSlot - 1, ident]
                            )
                        if isLast:
                            entitySlotIndex.setdefault(slot, []).append(
                                [False, lastSlot - firstSlot + 1, ident]
                            )
                    else:
                        entitySlotIndex.setdefault(slot, []).append(None)

            setData.entityText = entityText
            setData.entityTextVal = entityTextVal
            setData.entitySummary = entitySummary
            setData.entityIdent = entityIdent
            setData.entityIdentFirst = entityIdentFirst
            setData.entityFreq = {
                feat: sorted(entityFreq[feat].items()) for feat in features
            }
            setData.entityIndex = entityIndex
            setData.entityVal = entityVal
            setData.entitySlotVal = entitySlotVal
            setData.entitySlotAll = entitySlotAll
            setData.entitySlotIndex = entitySlotIndex

            setData.dateProcessed = time.time()
            # self.console(&#34;done.&#34;)

        else:
            # self.console(f&#34;Data of {annoSetRep} already processed.&#34;)
            pass

    def delEntity(self, vals, allMatches=None, silent=True):
        &#34;&#34;&#34;Delete entity occurrences from the current set.

        This operation is not allowed if the current set is the read-only set with the
        empty name.

        The entities to delete are selected by their feature values.
        So you can use this function to delete all entities with a certain
        entity id and kind.

        Moreover, you can also specify a set of locations and restrict the entity
        removal to the entities that occupy those locations.

        Parameters
        ----------
        vals: tuple
            For each entity feature it has a value of that feature. This specifies
            which entities have to go.
        allMatches: iterable of tuple of int, optional None
            A number of slot tuples. They are the locations from which the candidate
            entities will be deleted.
            If it is None, the entity candidates will be removed wherever they occur.
        silent: boolean, optional False
            Reports how many entities have been deleted and how many were not present
            in the specified locations.

        Returns
        -------
        (int, int) or void
            If `silent`, it returns the number of non-existing entities that were
            asked to be deleted and the number of actually deleted entities.

            If the operation is not allowed, both integers above are set to -1.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        annoSet = self.annoSet
        annoSetRep = self.annoSetRep

        if not annoSet:
            if silent:
                return (-1, -1)
            self.console(f&#34;Entity deletion not allowed on {annoSetRep}&#34;, error=True)
            return

        setData = self.getSetData()

        oldEntities = setData.entities

        delEntities = set()

        oldEntitiesBySlots = set()

        for e, (fVals, slots) in oldEntities.items():
            if fVals == vals:
                oldEntitiesBySlots.add(slots)

        missing = 0
        deleted = 0

        delSlots = oldEntitiesBySlots if allMatches is None else allMatches

        for slots in delSlots:
            if slots not in oldEntitiesBySlots:
                missing += 1
                continue

            delEntities.add((vals, slots))
            deleted += 1

        if len(delEntities):
            self.weedEntities(delEntities)

        self.loadData()

        if silent:
            return (missing, deleted)

        self.console(f&#34;Not present: {missing:&gt;5} x&#34;)
        self.console(f&#34;Deleted:     {deleted:&gt;5} x&#34;)

    def delEntityRich(self, deletions, buckets, excludedTokens=set()):
        &#34;&#34;&#34;Delete specified entity occurrences from the current set.

        This operation is not allowed if the current set is the read-only set with the
        empty name.

        This function has more detailed instructions as to which entities
        should be deleted than `Data.delEntity()` .

        It is a handy function for the TF browser to call, but not so much when you
        are manipulating entities yourself in a Jupyter notebook.

        Parameters
        ----------
        deletions: tuple of tuple or string
            Each member of the tuple corresponds to an entity feature.
            It is either a single value of such a feature, or an iterable
            of such values.
            The tuple together specifies a set of entities whose entity features
            have values that are either equal to the corresponding member of
            `deletions` or contained in it.
        buckets: iterable of list
            This is typically the result of
            `tf.browser.ner.annotate.Annotate.filterContent()`.
            The only important thing is that member 2 of each bucket is the list
            of entity matches in that bucket.
            Only entities that occupy these places will be removed.
        excludedTokens: set, optional set()
            This is the set of token positions that define the entities that must be
            skipped from deletion. If the last slot of an entity is in this set,
            the entity will not be deleted.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        annoSet = self.annoSet
        annoSetRep = self.annoSetRep
        browse = self.browse

        if not annoSet:
            msg = f&#34;Entity deletion not allowed on {annoSetRep}&#34;
            if browse:
                return [[msg]]
            else:
                self.console(msg, error=True)
                return

        settings = self.settings
        features = settings.features
        setData = self.getSetData()

        oldEntities = setData.entities

        report = []

        delEntities = set()
        delEntitiesByE = set()

        deletions = tuple([x] if type(x) is str else x for x in deletions)

        if any(len(x) &gt; 0 for x in deletions):
            oldEntitiesBySlots = collections.defaultdict(set)

            for e, info in oldEntities.items():
                oldEntitiesBySlots[info[1]].add(e)

            excl = 0

            fValTuples = [()]

            for vals in deletions:
                delTuples = []
                for val in vals:
                    delTuples.extend([ft + (val,) for ft in fValTuples])
                fValTuples = delTuples

            stats = collections.Counter()

            for bucket in buckets:
                allMatches = bucket[2]

                for slots in allMatches:
                    if slots[-1] in excludedTokens:
                        excl += 1
                        continue

                    candidates = oldEntitiesBySlots.get(slots, set())

                    for e in candidates:
                        toBeDeleted = False
                        fVals = oldEntities[e][0]

                        if fVals in fValTuples:
                            toBeDeleted = True

                        if toBeDeleted:
                            if e not in delEntitiesByE:
                                delEntitiesByE.add(e)
                                delEntities.add((fVals, slots))
                                stats[fVals] += 1

            report.append(
                tuple(sorted(stats.items())) if len(stats) else [&#34;Nothing deleted&#34;]
            )
            if excl:
                report.append(f&#34;Deletion: occurrences excluded: {excl}&#34;)

        if len(delEntities):
            self.weedEntities(delEntities)

        if browse:
            return report

        self.loadData()
        (stats, *rest) = report
        if type(stats) is list:
            self.console(&#34;\n&#34;.join(stats))
        else:
            for vals, freq in stats:
                repVals = &#34; &#34;.join(
                    f&#34;{feat}={val}&#34; for (feat, val) in zip(features, vals)
                )
                self.console(f&#34;Deleted {freq:&gt;5} x {repVals}&#34;)
        if len(rest):
            self.console(&#34;\n&#34;.join(rest))

    def addEntity(self, vals, allMatches, silent=True):
        &#34;&#34;&#34;Add entity occurrences to the current set.

        This operation is not allowed if the current set is the read-only set with the
        empty name.

        The entities to add are specified by their feature values.
        So you can use this function to add entities with a certain
        entity id and kind.

        You also have to specify a set of locations where the entities should be added.

        Parameters
        ----------
        vals: tuple
            For each entity feature it has a value of that feature. This specifies
            which entities have will be added.
        allMatches: iterable of tuple of int
            A number of slot tuples. They are the locations where the entities will be
            added.
        silent: boolean, optional False
            Reports how many entities have been added and how many were already present
            in the specified locations.

        Returns
        -------
        (int, int) or void
            If `silent`, it returns the number of already existing entities that were
            asked to be deleted and the number of actually deleted entities.

            If the operation is not allowed, both integers above are set to -1.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        annoSet = self.annoSet
        annoSetRep = self.annoSetRep

        if not annoSet:
            if silent:
                return (-1, -1)
            self.console(f&#34;Entity addition not allowed on {annoSetRep}&#34;, error=True)
            return

        setData = self.getSetData()

        oldEntities = setData.entities

        addEntities = set()

        oldEntitiesBySlots = set()

        for e, (fVals, slots) in oldEntities.items():
            if fVals == vals:
                oldEntitiesBySlots.add(slots)

        present = 0
        added = 0

        for slots in allMatches:
            if slots in oldEntitiesBySlots:
                present += 1
                continue

            info = (vals, slots)
            if info not in addEntities:
                addEntities.add(info)
                added += 1

        if len(addEntities):
            self.mergeEntities(addEntities)

        self.loadData()

        if silent:
            return (present, added)

        self.console(f&#34;Already present: {present:&gt;5} x&#34;)
        self.console(f&#34;Added:           {added:&gt;5} x&#34;)

    def addEntities(self, newEntities, silent=True):
        &#34;&#34;&#34;Add multiple entities efficiently to the current set.

        This operation is not allowed if the current set is the read-only set with the
        empty name.

        If you have multiple entities to add, it is wasteful to do multiple passes over
        the corpus to find them.

        This method does them all in one fell swoop.
        It is used by the method `tf.browser.ner.ner.NER.markEntities()`.

        Parameters
        ----------
        newEntites: iterable of tuples of tuples
            each new entity consists of

            *   a tuple of entity feature values, specifying the entity to add
            *   a list of slot tuples, specifying where to add this entity

        silent: boolean, optional False
            Reports how many entities have been added and how many were already present
            in the specified locations.

        Returns
        -------
        (int, int) or void
            If `silent`, it returns the number of already existing entities that were
            asked to be deleted and the number of actually deleted entities.

            If the operation is not allowed, both integers above are set to -1.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        annoSet = self.annoSet
        annoSetRep = self.annoSetRep

        if not annoSet:
            if silent:
                return (-1, -1)
            self.console(f&#34;Entities addition not allowed on {annoSetRep}&#34;, error=True)
            return

        setData = self.getSetData()

        oldEntities = set(setData.entities.values())

        addEntities = set()

        present = 0
        added = 0

        for fVals, allMatches in newEntities:
            for slots in allMatches:
                if (fVals, slots) in oldEntities:
                    present += 1
                elif (fVals, slots) in addEntities:
                    continue
                else:
                    added += 1
                    addEntities.add((fVals, slots))

        if len(addEntities):
            self.mergeEntities(addEntities)

        self.loadData()
        if silent:
            return (present, added)

        self.console(f&#34;Already present: {present:&gt;5} x&#34;)
        self.console(f&#34;Added:           {added:&gt;5} x&#34;)

    def addEntityRich(self, additions, buckets, excludedTokens=set()):
        &#34;&#34;&#34;Add specified entity occurrences to the current set.

        This operation is not allowed if the current set is the read-only set with the
        empty name.

        This function has more detailed instructions as to which entities
        should be added than `Data.addEntity()` .

        It is a handy function for the TF browser to call, but not so much when you
        are manipulating entities yourself in a Jupyter notebook.

        Parameters
        ----------
        additions: tuple of tuple or string
            Each member of the tuple corresponds to an entity feature.
            It is either a single value of such a feature, or an iterable
            of such values.
            The tuple together specifies a set of entities whose entity features
            have values that are either equal to the corresponding member of
            `additions` or contained in it.
        buckets: iterable of list
            This is typically the result of
            `tf.browser.ner.annotate.Annotate.filterContent()`.
            The only important thing is that member 2 of each bucket is the list
            of entity matches in that bucket.
            Entities will only be added at these places.
        excludedTokens: set, optional set()
            This is the set of token positions that define the locations that must not
            receive new entities. If the last slot of an entity is in this set,
            no entity will be added there.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        annoSet = self.annoSet
        annoSetRep = self.annoSetRep
        browse = self.browse

        if not annoSet:
            msg = f&#34;Entity addition not allowed on {annoSetRep}&#34;
            if browse:
                return [[msg]]
            else:
                self.console(msg, error=True)
                return

        settings = self.settings
        features = settings.features

        setData = self.getSetData()

        oldEntities = setData.entities

        report = []

        addEntities = set()

        additions = tuple([x] if type(x) is str else x for x in additions)

        if all(len(x) &gt; 0 for x in additions):
            oldEntitiesBySlots = collections.defaultdict(set)

            for e, (fVals, slots) in oldEntities.items():
                oldEntitiesBySlots[slots].add(fVals)

            excl = 0

            fValTuples = [()]

            for vals in additions:
                newTuples = []
                for val in vals:
                    newTuples.extend([ft + (val,) for ft in fValTuples])
                fValTuples = newTuples

            stats = collections.Counter()

            for bucket in buckets:
                allMatches = bucket[2]
                for slots in allMatches:
                    if slots[-1] in excludedTokens:
                        excl += 1
                        continue

                    existing = oldEntitiesBySlots.get(slots, set())

                    for fVals in fValTuples:
                        if fVals in existing:
                            continue
                        info = (fVals, slots)
                        if info not in addEntities:
                            addEntities.add(info)
                            stats[fVals] += 1

            report.append(
                tuple(sorted(stats.items())) if len(stats) else [&#34;Nothing added&#34;]
            )
            if excl:
                report.append(f&#34;Addition: occurrences excluded: {excl}&#34;)

        if len(addEntities):
            self.mergeEntities(addEntities)

        if browse:
            return report

        self.loadData()
        (stats, *rest) = report
        if type(stats) is list:
            self.console(&#34;\n&#34;.join(stats))
        else:
            for vals, freq in stats:
                repVals = &#34; &#34;.join(
                    f&#34;{feat}={val}&#34; for (feat, val) in zip(features, vals)
                )
                self.console(f&#34;Added {freq:&gt;5} x {repVals}&#34;)
        if len(rest):
            self.console(&#34;\n&#34;.join(rest))

    def weedEntities(self, delEntities):
        &#34;&#34;&#34;Performs deletions to the current annotation set.

        This operation is not allowed if the current set is the read-only set with the
        empty name.

        Parameters
        ----------
        delEntities: set
            The set consists of entity specs: a tuple of values of entity features,
            and an iterable of slot tuples where the entity is located.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        annoSet = self.annoSet
        annoSetRep = self.annoSetRep

        if not annoSet:
            self.console(f&#34;Entity weeding not allowed on {annoSetRep}&#34;, error=True)
            return

        settings = self.settings
        features = settings.features
        nF = len(features)

        annoDir = self.annoDir

        dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

        newEntities = []

        with fileOpen(dataFile) as fh:
            for line in fh:
                fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
                fVals = tuple(fields[0:nF])
                slots = tuple(int(f) for f in fields[nF:])
                info = (fVals, slots)
                if info in delEntities:
                    continue
                newEntities.append(line)

        with fileOpen(dataFile, mode=&#34;w&#34;) as fh:
            fh.write(&#34;&#34;.join(newEntities))

    def mergeEntities(self, newEntities):
        &#34;&#34;&#34;Performs additions to the current annotation set.

        This operation is not allowed if the current set is the read-only set with the
        empty name.

        Parameters
        ----------
        newEntities: set
            The set consists of entity specs: a tuple of values of entity features,
            and an iterable of slot tuples where the entity is located.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        annoSet = self.annoSet
        annoSetRep = self.annoSetRep

        if not annoSet:
            self.console(f&#34;Entity merging not allowed on {annoSetRep}&#34;, error=True)
            return

        annoDir = self.annoDir

        dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

        with fileOpen(dataFile, mode=&#34;a&#34;) as fh:
            for fVals, slots in newEntities:
                fh.write(&#34;\t&#34;.join(str(x) for x in (*fVals, *slots)) + &#34;\n&#34;)

    def saveEntitiesAs(self, dataFile):
        &#34;&#34;&#34;Export the data of an annotation set to a file.

        This function is used when a set has to be duplicated:
        `tf.browser.ner.sets.Sets.setDup()`.

        Parameters
        ----------
        dataFile: string
            The path of the file to write to.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        setData = self.getSetData()
        entities = setData.entities

        with fileOpen(dataFile, mode=&#34;a&#34;) as fh:
            for fVals, slots in entities.values():
                fh.write(&#34;\t&#34;.join(str(x) for x in (*fVals, *slots)) + &#34;\n&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.browser.ner.data.Data"><code class="flex name class">
<span>class <span class="ident">Data</span></span>
<span>(</span><span>data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manages annotation data.</p>
<p>This class is also responsible for adding entities to a set and deleting
entities from them.</p>
<p>Both addition and deletion is implemented by first figuring out what has to be
done, and then applying it to the entity data on disk; after that we
perform a data load from the update file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>object</code>, optional <code>None</code></dt>
<dd>
<p>Entity data to start with.
If None, a fresh data store will be created.</p>
<p>When the tool runs in browser context, each request will create a
<code><a title="tf.browser.ner.data.Data" href="#tf.browser.ner.data.Data">Data</a></code> object from scratch. If no data is provided to the initializer,
it will need to load the required data from file.
This is wasteful.</p>
<p>We have set up the web server in such a way that it incorporates the
annotation data. The web server will pass it to the
<code><a title="tf.browser.ner.annotate.Annotate" href="annotate.html#tf.browser.ner.annotate.Annotate">Annotate</a></code> object initializer, which passes
it to the initializer here.</p>
<p>In that way, the <code><a title="tf.browser.ner.data.Data" href="#tf.browser.ner.data.Data">Data</a></code> object can start with the data already in memory.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/703d3977ff845baafe67bbbaa3a678e8deb2b911/tf/browser/ner/data.py#L33-L935" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Data(Corpus):
    def __init__(self, data=None):
        &#34;&#34;&#34;Manages annotation data.

        This class is also responsible for adding entities to a set and deleting
        entities from them.

        Both addition and deletion is implemented by first figuring out what has to be
        done, and then applying it to the entity data on disk; after that we
        perform a data load from the update file.

        Parameters
        ----------
        data: object, optional None
            Entity data to start with.
            If None, a fresh data store will be created.

            When the tool runs in browser context, each request will create a
            `Data` object from scratch. If no data is provided to the initializer,
            it will need to load the required data from file.
            This is wasteful.

            We have set up the web server in such a way that it incorporates the
            annotation data. The web server will pass it to the
            `tf.browser.ner.annotate.Annotate` object initializer, which passes
            it to the initializer here.

            In that way, the `Data` object can start with the data already in memory.
        &#34;&#34;&#34;
        super().__init__()
        if not self.properlySetup:
            return

        if data is None:
            data = AttrDict()
            data.sets = AttrDict()

        self.data = data

        annoDir = self.annoDir
        initTree(annoDir, fresh=False)

    def loadData(self):
        &#34;&#34;&#34;Loads data of the current annotation set into memory.

        It has two phases:

        *   loading the source data (see `Data.fromSource()`)
        *   processing the loaded source data (see `Data.process()`)
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        data = self.data
        annoSet = self.annoSet

        if &#34;sets&#34; not in data:
            data.sets = AttrDict()

        sets = data.sets

        if annoSet not in sets:
            sets[annoSet] = AttrDict()

        # load bucket nodes

        changed = self.fromSource()
        self.process(changed)

    def fromSource(self):
        &#34;&#34;&#34;Loads annotation data from source.

        If the current annotation set is `&#34;&#34;`, the annotation data is already in
        the TF data,
        and we compile that data into a dict of entity data keyed by entity node.

        Otherwise, we read the corresponding TSV file from disk and compile that
        data into a dict of entity data keyed by line number.

        After collection of this data it is stored in the set data; in fact we store
        data under the following keys:

        *   `dateLoaded`: datetime when the data was last loaded from disk;
        *   `entities`: the list of entities as loaded from the source;
            it is a dict of entities, keyed by nodes or line numbers;
            each entity specifies a tuple of feature values and a list of slots
            that are part of the entity.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return None

        settings = self.settings
        data = self.data
        annoSet = self.annoSet
        setData = data.sets[annoSet]
        annoDir = self.annoDir

        settings = self.settings
        features = settings.features

        featureDefault = self.featureDefault
        nF = len(features)

        checkFeature = self.checkFeature
        getFVal = self.getFVal
        getSlots = self.getSlots

        dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

        if &#34;buckets&#34; not in setData:
            setData.buckets = self.getBucketNodes()

        changed = False

        if annoSet:
            if (
                &#34;entities&#34; not in setData
                or &#34;dateLoaded&#34; not in setData
                or (len(setData.entities) &gt; 0 and not fileExists(dataFile))
                or (fileExists(dataFile) and setData.dateLoaded &lt; mTime(dataFile))
            ):
                # self.console(f&#34;Loading data for {annoSet} ... &#34;, newline=False)
                changed = True
                entities = {}

                if fileExists(dataFile):
                    with fileOpen(dataFile) as df:
                        for e, line in enumerate(df):
                            fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
                            entities[e] = (
                                tuple(fields[0:nF]),
                                tuple(int(f) for f in fields[nF:]),
                            )

                setData.entities = entities
                setData.dateLoaded = time.time()
                # self.console(&#34;done.&#34;)
            else:
                # self.console(f&#34;Data for {annoSetRep} already loaded&#34;)
                pass
        else:
            if &#34;entities&#34; not in setData:
                entities = {}
                hasFeature = {feat: checkFeature(feat) for feat in features}

                for e in self.getEntityNodes():
                    slots = getSlots(e)
                    entities[e] = (
                        tuple(
                            getFVal(feat, e)
                            if hasFeature[feat]
                            else featureDefault[feat](slots)
                            for feat in features
                        ),
                        tuple(slots),
                    )

                setData.entities = entities

        return changed

    def process(self, changed):
        &#34;&#34;&#34;Generated derived data structures out of the source data.

        After loading we process the data into derived data structures.

        We try to be lazy. We only load data from disk if the data is not
        already in memory, or the data on disk has been updated since the last load.

        The resulting data is stored in current set under the various keys.

        After processing, the time of processing is recorded, so that it can be
        observed if the processed data is no longer up to date w.r.t. the data as
        loaded from source.

        For each such set we produce several data structures, which we store
        under the following keys:

        *   `dateProcessed`: datetime when the data was last processed
        *   `entityText`: dict, text of entity by entity node or line number in
            TSV file;
        *   `entityTextVal`: dict of dict, set of feature values of entity, keyed by
            feature name and then by text of the entity;
        *   `entitySummary`: dict, list of entity nodes / line numbers, keyed by value
            of entity kind;
        *   `entityIdent`: dict, list of entity nodes./line numbers, keyed by tuple of
            entity feature values (these tuples are identifying for an entity);
        *   `entityFreq`: dict of counters, a counter for each feature name; the
            counter gives the number of times each value of that feature occurs in an
            entity;
        *   `entityIndex`: dict of dict, a dict for each feature name; the sub-dict
            gives for each position the values that entities occupying that position
            can have; positions are tuples of slots;
        *   `entityVal`: dict, keyed by value tuples gives the set of positions
            that entities with that value tuple occupy;
        *   `entitySlotVal`: dict, keyed by positions gives the set of values
            that entities occupying that position can have;
        *   `entitySlotAll`: dict, keyed by single first slots gives the set of
            ending slots that entities starting at that first slot have;
        *   `entitySlotIndex`: dict, keyed by single slot gives list of items
            corresponding to entities that occupy that slot;

            *   if an entity starts there, an entry `[True, -n, values]` is made;
            *   if an entity ends there, an entry `[False, n, values]` is made;
            *   if an entity occupies that slot without starting or ending there,
                an entry `None` is made;

            Above, `n` is the length of the entity in tokens and `values` is the
            tuple of feature values of that entity.

            This is precisely the information we need if we want to mark up a set of
            entities in the surrounding context of tokens.

        Parameters
        ----------
        changed: boolean
            Whether the data has changed since last processing.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        settings = self.settings
        features = settings.features
        getText = self.getText
        summaryIndices = settings.summaryIndices

        data = self.data
        annoSet = self.annoSet
        # annoSetRep = self.annoSetRep
        setData = data.sets[annoSet]

        dateLoaded = setData.dateLoaded
        dateProcessed = setData.dateProcessed

        if (
            changed
            or &#34;dateProcessed&#34; not in setData
            or &#34;entityText&#34; not in setData
            or &#34;entityTextVal&#34; not in setData
            or &#34;entitySummary&#34; not in setData
            or &#34;entityIdent&#34; not in setData
            or &#34;entityFreq&#34; not in setData
            or &#34;entityIndex&#34; not in setData
            or &#34;entityVal&#34; not in setData
            or &#34;entitySlotVal&#34; not in setData
            or &#34;entitySlotAll&#34; not in setData
            or &#34;entitySlotIndex&#34; not in setData
            or dateLoaded is not None
            and dateProcessed &lt; dateLoaded
        ):
            # self.console(f&#34;Processing data of {annoSetRep} ... &#34;, newline=False)

            entityItems = setData.entities.items()

            entityText = {}
            entityTextVal = {feat: collections.defaultdict(set) for feat in features}
            entitySummary = {}
            entityIdent = {}
            entityIdentFirst = {}
            entityFreq = {feat: collections.Counter() for feat in features}
            entityIndex = {feat: {} for feat in features}
            entityVal = {}
            entitySlotVal = {}
            entitySlotAll = {}
            entitySlotIndex = {}

            for e, (fVals, slots) in entityItems:
                txt = getText(slots)
                ident = fVals
                summary = tuple(fVals[i] for i in summaryIndices)

                entityText[e] = txt
                entityVal.setdefault(fVals, set()).add(slots)

                for feat, val in zip(features, fVals):
                    entityFreq[feat][val] += 1
                    entityIndex[feat].setdefault(slots, set()).add(val)
                    entityTextVal[feat][txt].add(val)

                entityIdent.setdefault(ident, []).append(e)
                if ident not in entityIdentFirst:
                    entityIdentFirst[ident] = e

                entitySummary.setdefault(summary, []).append(e)
                entitySlotVal.setdefault(slots, set()).add(fVals)

                firstSlot = slots[0]
                lastSlot = slots[-1]

                entitySlotAll.setdefault(firstSlot, set()).add(lastSlot)

                for slot in slots:
                    isFirst = slot == firstSlot
                    isLast = slot == lastSlot
                    if isFirst or isLast:
                        if isFirst:
                            entitySlotIndex.setdefault(slot, []).append(
                                [True, firstSlot - lastSlot - 1, ident]
                            )
                        if isLast:
                            entitySlotIndex.setdefault(slot, []).append(
                                [False, lastSlot - firstSlot + 1, ident]
                            )
                    else:
                        entitySlotIndex.setdefault(slot, []).append(None)

            setData.entityText = entityText
            setData.entityTextVal = entityTextVal
            setData.entitySummary = entitySummary
            setData.entityIdent = entityIdent
            setData.entityIdentFirst = entityIdentFirst
            setData.entityFreq = {
                feat: sorted(entityFreq[feat].items()) for feat in features
            }
            setData.entityIndex = entityIndex
            setData.entityVal = entityVal
            setData.entitySlotVal = entitySlotVal
            setData.entitySlotAll = entitySlotAll
            setData.entitySlotIndex = entitySlotIndex

            setData.dateProcessed = time.time()
            # self.console(&#34;done.&#34;)

        else:
            # self.console(f&#34;Data of {annoSetRep} already processed.&#34;)
            pass

    def delEntity(self, vals, allMatches=None, silent=True):
        &#34;&#34;&#34;Delete entity occurrences from the current set.

        This operation is not allowed if the current set is the read-only set with the
        empty name.

        The entities to delete are selected by their feature values.
        So you can use this function to delete all entities with a certain
        entity id and kind.

        Moreover, you can also specify a set of locations and restrict the entity
        removal to the entities that occupy those locations.

        Parameters
        ----------
        vals: tuple
            For each entity feature it has a value of that feature. This specifies
            which entities have to go.
        allMatches: iterable of tuple of int, optional None
            A number of slot tuples. They are the locations from which the candidate
            entities will be deleted.
            If it is None, the entity candidates will be removed wherever they occur.
        silent: boolean, optional False
            Reports how many entities have been deleted and how many were not present
            in the specified locations.

        Returns
        -------
        (int, int) or void
            If `silent`, it returns the number of non-existing entities that were
            asked to be deleted and the number of actually deleted entities.

            If the operation is not allowed, both integers above are set to -1.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        annoSet = self.annoSet
        annoSetRep = self.annoSetRep

        if not annoSet:
            if silent:
                return (-1, -1)
            self.console(f&#34;Entity deletion not allowed on {annoSetRep}&#34;, error=True)
            return

        setData = self.getSetData()

        oldEntities = setData.entities

        delEntities = set()

        oldEntitiesBySlots = set()

        for e, (fVals, slots) in oldEntities.items():
            if fVals == vals:
                oldEntitiesBySlots.add(slots)

        missing = 0
        deleted = 0

        delSlots = oldEntitiesBySlots if allMatches is None else allMatches

        for slots in delSlots:
            if slots not in oldEntitiesBySlots:
                missing += 1
                continue

            delEntities.add((vals, slots))
            deleted += 1

        if len(delEntities):
            self.weedEntities(delEntities)

        self.loadData()

        if silent:
            return (missing, deleted)

        self.console(f&#34;Not present: {missing:&gt;5} x&#34;)
        self.console(f&#34;Deleted:     {deleted:&gt;5} x&#34;)

    def delEntityRich(self, deletions, buckets, excludedTokens=set()):
        &#34;&#34;&#34;Delete specified entity occurrences from the current set.

        This operation is not allowed if the current set is the read-only set with the
        empty name.

        This function has more detailed instructions as to which entities
        should be deleted than `Data.delEntity()` .

        It is a handy function for the TF browser to call, but not so much when you
        are manipulating entities yourself in a Jupyter notebook.

        Parameters
        ----------
        deletions: tuple of tuple or string
            Each member of the tuple corresponds to an entity feature.
            It is either a single value of such a feature, or an iterable
            of such values.
            The tuple together specifies a set of entities whose entity features
            have values that are either equal to the corresponding member of
            `deletions` or contained in it.
        buckets: iterable of list
            This is typically the result of
            `tf.browser.ner.annotate.Annotate.filterContent()`.
            The only important thing is that member 2 of each bucket is the list
            of entity matches in that bucket.
            Only entities that occupy these places will be removed.
        excludedTokens: set, optional set()
            This is the set of token positions that define the entities that must be
            skipped from deletion. If the last slot of an entity is in this set,
            the entity will not be deleted.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        annoSet = self.annoSet
        annoSetRep = self.annoSetRep
        browse = self.browse

        if not annoSet:
            msg = f&#34;Entity deletion not allowed on {annoSetRep}&#34;
            if browse:
                return [[msg]]
            else:
                self.console(msg, error=True)
                return

        settings = self.settings
        features = settings.features
        setData = self.getSetData()

        oldEntities = setData.entities

        report = []

        delEntities = set()
        delEntitiesByE = set()

        deletions = tuple([x] if type(x) is str else x for x in deletions)

        if any(len(x) &gt; 0 for x in deletions):
            oldEntitiesBySlots = collections.defaultdict(set)

            for e, info in oldEntities.items():
                oldEntitiesBySlots[info[1]].add(e)

            excl = 0

            fValTuples = [()]

            for vals in deletions:
                delTuples = []
                for val in vals:
                    delTuples.extend([ft + (val,) for ft in fValTuples])
                fValTuples = delTuples

            stats = collections.Counter()

            for bucket in buckets:
                allMatches = bucket[2]

                for slots in allMatches:
                    if slots[-1] in excludedTokens:
                        excl += 1
                        continue

                    candidates = oldEntitiesBySlots.get(slots, set())

                    for e in candidates:
                        toBeDeleted = False
                        fVals = oldEntities[e][0]

                        if fVals in fValTuples:
                            toBeDeleted = True

                        if toBeDeleted:
                            if e not in delEntitiesByE:
                                delEntitiesByE.add(e)
                                delEntities.add((fVals, slots))
                                stats[fVals] += 1

            report.append(
                tuple(sorted(stats.items())) if len(stats) else [&#34;Nothing deleted&#34;]
            )
            if excl:
                report.append(f&#34;Deletion: occurrences excluded: {excl}&#34;)

        if len(delEntities):
            self.weedEntities(delEntities)

        if browse:
            return report

        self.loadData()
        (stats, *rest) = report
        if type(stats) is list:
            self.console(&#34;\n&#34;.join(stats))
        else:
            for vals, freq in stats:
                repVals = &#34; &#34;.join(
                    f&#34;{feat}={val}&#34; for (feat, val) in zip(features, vals)
                )
                self.console(f&#34;Deleted {freq:&gt;5} x {repVals}&#34;)
        if len(rest):
            self.console(&#34;\n&#34;.join(rest))

    def addEntity(self, vals, allMatches, silent=True):
        &#34;&#34;&#34;Add entity occurrences to the current set.

        This operation is not allowed if the current set is the read-only set with the
        empty name.

        The entities to add are specified by their feature values.
        So you can use this function to add entities with a certain
        entity id and kind.

        You also have to specify a set of locations where the entities should be added.

        Parameters
        ----------
        vals: tuple
            For each entity feature it has a value of that feature. This specifies
            which entities have will be added.
        allMatches: iterable of tuple of int
            A number of slot tuples. They are the locations where the entities will be
            added.
        silent: boolean, optional False
            Reports how many entities have been added and how many were already present
            in the specified locations.

        Returns
        -------
        (int, int) or void
            If `silent`, it returns the number of already existing entities that were
            asked to be deleted and the number of actually deleted entities.

            If the operation is not allowed, both integers above are set to -1.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        annoSet = self.annoSet
        annoSetRep = self.annoSetRep

        if not annoSet:
            if silent:
                return (-1, -1)
            self.console(f&#34;Entity addition not allowed on {annoSetRep}&#34;, error=True)
            return

        setData = self.getSetData()

        oldEntities = setData.entities

        addEntities = set()

        oldEntitiesBySlots = set()

        for e, (fVals, slots) in oldEntities.items():
            if fVals == vals:
                oldEntitiesBySlots.add(slots)

        present = 0
        added = 0

        for slots in allMatches:
            if slots in oldEntitiesBySlots:
                present += 1
                continue

            info = (vals, slots)
            if info not in addEntities:
                addEntities.add(info)
                added += 1

        if len(addEntities):
            self.mergeEntities(addEntities)

        self.loadData()

        if silent:
            return (present, added)

        self.console(f&#34;Already present: {present:&gt;5} x&#34;)
        self.console(f&#34;Added:           {added:&gt;5} x&#34;)

    def addEntities(self, newEntities, silent=True):
        &#34;&#34;&#34;Add multiple entities efficiently to the current set.

        This operation is not allowed if the current set is the read-only set with the
        empty name.

        If you have multiple entities to add, it is wasteful to do multiple passes over
        the corpus to find them.

        This method does them all in one fell swoop.
        It is used by the method `tf.browser.ner.ner.NER.markEntities()`.

        Parameters
        ----------
        newEntites: iterable of tuples of tuples
            each new entity consists of

            *   a tuple of entity feature values, specifying the entity to add
            *   a list of slot tuples, specifying where to add this entity

        silent: boolean, optional False
            Reports how many entities have been added and how many were already present
            in the specified locations.

        Returns
        -------
        (int, int) or void
            If `silent`, it returns the number of already existing entities that were
            asked to be deleted and the number of actually deleted entities.

            If the operation is not allowed, both integers above are set to -1.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        annoSet = self.annoSet
        annoSetRep = self.annoSetRep

        if not annoSet:
            if silent:
                return (-1, -1)
            self.console(f&#34;Entities addition not allowed on {annoSetRep}&#34;, error=True)
            return

        setData = self.getSetData()

        oldEntities = set(setData.entities.values())

        addEntities = set()

        present = 0
        added = 0

        for fVals, allMatches in newEntities:
            for slots in allMatches:
                if (fVals, slots) in oldEntities:
                    present += 1
                elif (fVals, slots) in addEntities:
                    continue
                else:
                    added += 1
                    addEntities.add((fVals, slots))

        if len(addEntities):
            self.mergeEntities(addEntities)

        self.loadData()
        if silent:
            return (present, added)

        self.console(f&#34;Already present: {present:&gt;5} x&#34;)
        self.console(f&#34;Added:           {added:&gt;5} x&#34;)

    def addEntityRich(self, additions, buckets, excludedTokens=set()):
        &#34;&#34;&#34;Add specified entity occurrences to the current set.

        This operation is not allowed if the current set is the read-only set with the
        empty name.

        This function has more detailed instructions as to which entities
        should be added than `Data.addEntity()` .

        It is a handy function for the TF browser to call, but not so much when you
        are manipulating entities yourself in a Jupyter notebook.

        Parameters
        ----------
        additions: tuple of tuple or string
            Each member of the tuple corresponds to an entity feature.
            It is either a single value of such a feature, or an iterable
            of such values.
            The tuple together specifies a set of entities whose entity features
            have values that are either equal to the corresponding member of
            `additions` or contained in it.
        buckets: iterable of list
            This is typically the result of
            `tf.browser.ner.annotate.Annotate.filterContent()`.
            The only important thing is that member 2 of each bucket is the list
            of entity matches in that bucket.
            Entities will only be added at these places.
        excludedTokens: set, optional set()
            This is the set of token positions that define the locations that must not
            receive new entities. If the last slot of an entity is in this set,
            no entity will be added there.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        annoSet = self.annoSet
        annoSetRep = self.annoSetRep
        browse = self.browse

        if not annoSet:
            msg = f&#34;Entity addition not allowed on {annoSetRep}&#34;
            if browse:
                return [[msg]]
            else:
                self.console(msg, error=True)
                return

        settings = self.settings
        features = settings.features

        setData = self.getSetData()

        oldEntities = setData.entities

        report = []

        addEntities = set()

        additions = tuple([x] if type(x) is str else x for x in additions)

        if all(len(x) &gt; 0 for x in additions):
            oldEntitiesBySlots = collections.defaultdict(set)

            for e, (fVals, slots) in oldEntities.items():
                oldEntitiesBySlots[slots].add(fVals)

            excl = 0

            fValTuples = [()]

            for vals in additions:
                newTuples = []
                for val in vals:
                    newTuples.extend([ft + (val,) for ft in fValTuples])
                fValTuples = newTuples

            stats = collections.Counter()

            for bucket in buckets:
                allMatches = bucket[2]
                for slots in allMatches:
                    if slots[-1] in excludedTokens:
                        excl += 1
                        continue

                    existing = oldEntitiesBySlots.get(slots, set())

                    for fVals in fValTuples:
                        if fVals in existing:
                            continue
                        info = (fVals, slots)
                        if info not in addEntities:
                            addEntities.add(info)
                            stats[fVals] += 1

            report.append(
                tuple(sorted(stats.items())) if len(stats) else [&#34;Nothing added&#34;]
            )
            if excl:
                report.append(f&#34;Addition: occurrences excluded: {excl}&#34;)

        if len(addEntities):
            self.mergeEntities(addEntities)

        if browse:
            return report

        self.loadData()
        (stats, *rest) = report
        if type(stats) is list:
            self.console(&#34;\n&#34;.join(stats))
        else:
            for vals, freq in stats:
                repVals = &#34; &#34;.join(
                    f&#34;{feat}={val}&#34; for (feat, val) in zip(features, vals)
                )
                self.console(f&#34;Added {freq:&gt;5} x {repVals}&#34;)
        if len(rest):
            self.console(&#34;\n&#34;.join(rest))

    def weedEntities(self, delEntities):
        &#34;&#34;&#34;Performs deletions to the current annotation set.

        This operation is not allowed if the current set is the read-only set with the
        empty name.

        Parameters
        ----------
        delEntities: set
            The set consists of entity specs: a tuple of values of entity features,
            and an iterable of slot tuples where the entity is located.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        annoSet = self.annoSet
        annoSetRep = self.annoSetRep

        if not annoSet:
            self.console(f&#34;Entity weeding not allowed on {annoSetRep}&#34;, error=True)
            return

        settings = self.settings
        features = settings.features
        nF = len(features)

        annoDir = self.annoDir

        dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

        newEntities = []

        with fileOpen(dataFile) as fh:
            for line in fh:
                fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
                fVals = tuple(fields[0:nF])
                slots = tuple(int(f) for f in fields[nF:])
                info = (fVals, slots)
                if info in delEntities:
                    continue
                newEntities.append(line)

        with fileOpen(dataFile, mode=&#34;w&#34;) as fh:
            fh.write(&#34;&#34;.join(newEntities))

    def mergeEntities(self, newEntities):
        &#34;&#34;&#34;Performs additions to the current annotation set.

        This operation is not allowed if the current set is the read-only set with the
        empty name.

        Parameters
        ----------
        newEntities: set
            The set consists of entity specs: a tuple of values of entity features,
            and an iterable of slot tuples where the entity is located.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        annoSet = self.annoSet
        annoSetRep = self.annoSetRep

        if not annoSet:
            self.console(f&#34;Entity merging not allowed on {annoSetRep}&#34;, error=True)
            return

        annoDir = self.annoDir

        dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

        with fileOpen(dataFile, mode=&#34;a&#34;) as fh:
            for fVals, slots in newEntities:
                fh.write(&#34;\t&#34;.join(str(x) for x in (*fVals, *slots)) + &#34;\n&#34;)

    def saveEntitiesAs(self, dataFile):
        &#34;&#34;&#34;Export the data of an annotation set to a file.

        This function is used when a set has to be duplicated:
        `tf.browser.ner.sets.Sets.setDup()`.

        Parameters
        ----------
        dataFile: string
            The path of the file to write to.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        setData = self.getSetData()
        entities = setData.entities

        with fileOpen(dataFile, mode=&#34;a&#34;) as fh:
            for fVals, slots in entities.values():
                fh.write(&#34;\t&#34;.join(str(x) for x in (*fVals, *slots)) + &#34;\n&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tf.browser.ner.corpus.Corpus" href="corpus.html#tf.browser.ner.corpus.Corpus">Corpus</a></li>
<li><a title="tf.browser.ner.settings.Settings" href="settings.html#tf.browser.ner.settings.Settings">Settings</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tf.browser.ner.sets.Sets" href="sets.html#tf.browser.ner.sets.Sets">Sets</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tf.browser.ner.data.Data.addEntities"><code class="name flex">
<span>def <span class="ident">addEntities</span></span>(<span>self, newEntities, silent=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Add multiple entities efficiently to the current set.</p>
<p>This operation is not allowed if the current set is the read-only set with the
empty name.</p>
<p>If you have multiple entities to add, it is wasteful to do multiple passes over
the corpus to find them.</p>
<p>This method does them all in one fell swoop.
It is used by the method <code><a title="tf.browser.ner.ner.NER.markEntities" href="ner.html#tf.browser.ner.ner.NER.markEntities">NER.markEntities()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>newEntites</code></strong> :&ensp;<code>iterable</code> of <code>tuples</code> of <code>tuples</code></dt>
<dd>
<p>each new entity consists of</p>
<ul>
<li>a tuple of entity feature values, specifying the entity to add</li>
<li>a list of slot tuples, specifying where to add this entity</li>
</ul>
</dd>
<dt><strong><code>silent</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Reports how many entities have been added and how many were already present
in the specified locations.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(int, int) or void
If <code>silent</code>, it returns the number of already existing entities that were
asked to be deleted and the number of actually deleted entities.</p>
<pre><code>If the operation is not allowed, both integers above are set to -1.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/703d3977ff845baafe67bbbaa3a678e8deb2b911/tf/browser/ner/data.py#L648-L719" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addEntities(self, newEntities, silent=True):
    &#34;&#34;&#34;Add multiple entities efficiently to the current set.

    This operation is not allowed if the current set is the read-only set with the
    empty name.

    If you have multiple entities to add, it is wasteful to do multiple passes over
    the corpus to find them.

    This method does them all in one fell swoop.
    It is used by the method `tf.browser.ner.ner.NER.markEntities()`.

    Parameters
    ----------
    newEntites: iterable of tuples of tuples
        each new entity consists of

        *   a tuple of entity feature values, specifying the entity to add
        *   a list of slot tuples, specifying where to add this entity

    silent: boolean, optional False
        Reports how many entities have been added and how many were already present
        in the specified locations.

    Returns
    -------
    (int, int) or void
        If `silent`, it returns the number of already existing entities that were
        asked to be deleted and the number of actually deleted entities.

        If the operation is not allowed, both integers above are set to -1.
    &#34;&#34;&#34;
    if not self.properlySetup:
        return

    annoSet = self.annoSet
    annoSetRep = self.annoSetRep

    if not annoSet:
        if silent:
            return (-1, -1)
        self.console(f&#34;Entities addition not allowed on {annoSetRep}&#34;, error=True)
        return

    setData = self.getSetData()

    oldEntities = set(setData.entities.values())

    addEntities = set()

    present = 0
    added = 0

    for fVals, allMatches in newEntities:
        for slots in allMatches:
            if (fVals, slots) in oldEntities:
                present += 1
            elif (fVals, slots) in addEntities:
                continue
            else:
                added += 1
                addEntities.add((fVals, slots))

    if len(addEntities):
        self.mergeEntities(addEntities)

    self.loadData()
    if silent:
        return (present, added)

    self.console(f&#34;Already present: {present:&gt;5} x&#34;)
    self.console(f&#34;Added:           {added:&gt;5} x&#34;)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.addEntity"><code class="name flex">
<span>def <span class="ident">addEntity</span></span>(<span>self, vals, allMatches, silent=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Add entity occurrences to the current set.</p>
<p>This operation is not allowed if the current set is the read-only set with the
empty name.</p>
<p>The entities to add are specified by their feature values.
So you can use this function to add entities with a certain
entity id and kind.</p>
<p>You also have to specify a set of locations where the entities should be added.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vals</code></strong> :&ensp;<code>tuple</code></dt>
<dd>For each entity feature it has a value of that feature. This specifies
which entities have will be added.</dd>
<dt><strong><code>allMatches</code></strong> :&ensp;<code>iterable</code> of <code>tuple</code> of <code>int</code></dt>
<dd>A number of slot tuples. They are the locations where the entities will be
added.</dd>
<dt><strong><code>silent</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Reports how many entities have been added and how many were already present
in the specified locations.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(int, int) or void
If <code>silent</code>, it returns the number of already existing entities that were
asked to be deleted and the number of actually deleted entities.</p>
<pre><code>If the operation is not allowed, both integers above are set to -1.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/703d3977ff845baafe67bbbaa3a678e8deb2b911/tf/browser/ner/data.py#L568-L646" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addEntity(self, vals, allMatches, silent=True):
    &#34;&#34;&#34;Add entity occurrences to the current set.

    This operation is not allowed if the current set is the read-only set with the
    empty name.

    The entities to add are specified by their feature values.
    So you can use this function to add entities with a certain
    entity id and kind.

    You also have to specify a set of locations where the entities should be added.

    Parameters
    ----------
    vals: tuple
        For each entity feature it has a value of that feature. This specifies
        which entities have will be added.
    allMatches: iterable of tuple of int
        A number of slot tuples. They are the locations where the entities will be
        added.
    silent: boolean, optional False
        Reports how many entities have been added and how many were already present
        in the specified locations.

    Returns
    -------
    (int, int) or void
        If `silent`, it returns the number of already existing entities that were
        asked to be deleted and the number of actually deleted entities.

        If the operation is not allowed, both integers above are set to -1.
    &#34;&#34;&#34;
    if not self.properlySetup:
        return

    annoSet = self.annoSet
    annoSetRep = self.annoSetRep

    if not annoSet:
        if silent:
            return (-1, -1)
        self.console(f&#34;Entity addition not allowed on {annoSetRep}&#34;, error=True)
        return

    setData = self.getSetData()

    oldEntities = setData.entities

    addEntities = set()

    oldEntitiesBySlots = set()

    for e, (fVals, slots) in oldEntities.items():
        if fVals == vals:
            oldEntitiesBySlots.add(slots)

    present = 0
    added = 0

    for slots in allMatches:
        if slots in oldEntitiesBySlots:
            present += 1
            continue

        info = (vals, slots)
        if info not in addEntities:
            addEntities.add(info)
            added += 1

    if len(addEntities):
        self.mergeEntities(addEntities)

    self.loadData()

    if silent:
        return (present, added)

    self.console(f&#34;Already present: {present:&gt;5} x&#34;)
    self.console(f&#34;Added:           {added:&gt;5} x&#34;)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.addEntityRich"><code class="name flex">
<span>def <span class="ident">addEntityRich</span></span>(<span>self, additions, buckets, excludedTokens=set())</span>
</code></dt>
<dd>
<div class="desc"><p>Add specified entity occurrences to the current set.</p>
<p>This operation is not allowed if the current set is the read-only set with the
empty name.</p>
<p>This function has more detailed instructions as to which entities
should be added than <code><a title="tf.browser.ner.data.Data.addEntity" href="#tf.browser.ner.data.Data.addEntity">Data.addEntity()</a></code> .</p>
<p>It is a handy function for the TF browser to call, but not so much when you
are manipulating entities yourself in a Jupyter notebook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>additions</code></strong> :&ensp;<code>tuple</code> of <code>tuple</code> or <code>string</code></dt>
<dd>Each member of the tuple corresponds to an entity feature.
It is either a single value of such a feature, or an iterable
of such values.
The tuple together specifies a set of entities whose entity features
have values that are either equal to the corresponding member of
<code>additions</code> or contained in it.</dd>
<dt><strong><code>buckets</code></strong> :&ensp;<code>iterable</code> of <code>list</code></dt>
<dd>This is typically the result of
<code><a title="tf.browser.ner.annotate.Annotate.filterContent" href="annotate.html#tf.browser.ner.annotate.Annotate.filterContent">Annotate.filterContent()</a></code>.
The only important thing is that member 2 of each bucket is the list
of entity matches in that bucket.
Entities will only be added at these places.</dd>
<dt><strong><code>excludedTokens</code></strong> :&ensp;<code>set</code>, optional <code>set()</code></dt>
<dd>This is the set of token positions that define the locations that must not
receive new entities. If the last slot of an entity is in this set,
no entity will be added there.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/703d3977ff845baafe67bbbaa3a678e8deb2b911/tf/browser/ner/data.py#L721-L839" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addEntityRich(self, additions, buckets, excludedTokens=set()):
    &#34;&#34;&#34;Add specified entity occurrences to the current set.

    This operation is not allowed if the current set is the read-only set with the
    empty name.

    This function has more detailed instructions as to which entities
    should be added than `Data.addEntity()` .

    It is a handy function for the TF browser to call, but not so much when you
    are manipulating entities yourself in a Jupyter notebook.

    Parameters
    ----------
    additions: tuple of tuple or string
        Each member of the tuple corresponds to an entity feature.
        It is either a single value of such a feature, or an iterable
        of such values.
        The tuple together specifies a set of entities whose entity features
        have values that are either equal to the corresponding member of
        `additions` or contained in it.
    buckets: iterable of list
        This is typically the result of
        `tf.browser.ner.annotate.Annotate.filterContent()`.
        The only important thing is that member 2 of each bucket is the list
        of entity matches in that bucket.
        Entities will only be added at these places.
    excludedTokens: set, optional set()
        This is the set of token positions that define the locations that must not
        receive new entities. If the last slot of an entity is in this set,
        no entity will be added there.
    &#34;&#34;&#34;
    if not self.properlySetup:
        return

    annoSet = self.annoSet
    annoSetRep = self.annoSetRep
    browse = self.browse

    if not annoSet:
        msg = f&#34;Entity addition not allowed on {annoSetRep}&#34;
        if browse:
            return [[msg]]
        else:
            self.console(msg, error=True)
            return

    settings = self.settings
    features = settings.features

    setData = self.getSetData()

    oldEntities = setData.entities

    report = []

    addEntities = set()

    additions = tuple([x] if type(x) is str else x for x in additions)

    if all(len(x) &gt; 0 for x in additions):
        oldEntitiesBySlots = collections.defaultdict(set)

        for e, (fVals, slots) in oldEntities.items():
            oldEntitiesBySlots[slots].add(fVals)

        excl = 0

        fValTuples = [()]

        for vals in additions:
            newTuples = []
            for val in vals:
                newTuples.extend([ft + (val,) for ft in fValTuples])
            fValTuples = newTuples

        stats = collections.Counter()

        for bucket in buckets:
            allMatches = bucket[2]
            for slots in allMatches:
                if slots[-1] in excludedTokens:
                    excl += 1
                    continue

                existing = oldEntitiesBySlots.get(slots, set())

                for fVals in fValTuples:
                    if fVals in existing:
                        continue
                    info = (fVals, slots)
                    if info not in addEntities:
                        addEntities.add(info)
                        stats[fVals] += 1

        report.append(
            tuple(sorted(stats.items())) if len(stats) else [&#34;Nothing added&#34;]
        )
        if excl:
            report.append(f&#34;Addition: occurrences excluded: {excl}&#34;)

    if len(addEntities):
        self.mergeEntities(addEntities)

    if browse:
        return report

    self.loadData()
    (stats, *rest) = report
    if type(stats) is list:
        self.console(&#34;\n&#34;.join(stats))
    else:
        for vals, freq in stats:
            repVals = &#34; &#34;.join(
                f&#34;{feat}={val}&#34; for (feat, val) in zip(features, vals)
            )
            self.console(f&#34;Added {freq:&gt;5} x {repVals}&#34;)
    if len(rest):
        self.console(&#34;\n&#34;.join(rest))</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.delEntity"><code class="name flex">
<span>def <span class="ident">delEntity</span></span>(<span>self, vals, allMatches=None, silent=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete entity occurrences from the current set.</p>
<p>This operation is not allowed if the current set is the read-only set with the
empty name.</p>
<p>The entities to delete are selected by their feature values.
So you can use this function to delete all entities with a certain
entity id and kind.</p>
<p>Moreover, you can also specify a set of locations and restrict the entity
removal to the entities that occupy those locations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vals</code></strong> :&ensp;<code>tuple</code></dt>
<dd>For each entity feature it has a value of that feature. This specifies
which entities have to go.</dd>
<dt><strong><code>allMatches</code></strong> :&ensp;<code>iterable</code> of <code>tuple</code> of <code>int</code>, optional <code>None</code></dt>
<dd>A number of slot tuples. They are the locations from which the candidate
entities will be deleted.
If it is None, the entity candidates will be removed wherever they occur.</dd>
<dt><strong><code>silent</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Reports how many entities have been deleted and how many were not present
in the specified locations.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(int, int) or void
If <code>silent</code>, it returns the number of non-existing entities that were
asked to be deleted and the number of actually deleted entities.</p>
<pre><code>If the operation is not allowed, both integers above are set to -1.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/703d3977ff845baafe67bbbaa3a678e8deb2b911/tf/browser/ner/data.py#L360-L440" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delEntity(self, vals, allMatches=None, silent=True):
    &#34;&#34;&#34;Delete entity occurrences from the current set.

    This operation is not allowed if the current set is the read-only set with the
    empty name.

    The entities to delete are selected by their feature values.
    So you can use this function to delete all entities with a certain
    entity id and kind.

    Moreover, you can also specify a set of locations and restrict the entity
    removal to the entities that occupy those locations.

    Parameters
    ----------
    vals: tuple
        For each entity feature it has a value of that feature. This specifies
        which entities have to go.
    allMatches: iterable of tuple of int, optional None
        A number of slot tuples. They are the locations from which the candidate
        entities will be deleted.
        If it is None, the entity candidates will be removed wherever they occur.
    silent: boolean, optional False
        Reports how many entities have been deleted and how many were not present
        in the specified locations.

    Returns
    -------
    (int, int) or void
        If `silent`, it returns the number of non-existing entities that were
        asked to be deleted and the number of actually deleted entities.

        If the operation is not allowed, both integers above are set to -1.
    &#34;&#34;&#34;
    if not self.properlySetup:
        return

    annoSet = self.annoSet
    annoSetRep = self.annoSetRep

    if not annoSet:
        if silent:
            return (-1, -1)
        self.console(f&#34;Entity deletion not allowed on {annoSetRep}&#34;, error=True)
        return

    setData = self.getSetData()

    oldEntities = setData.entities

    delEntities = set()

    oldEntitiesBySlots = set()

    for e, (fVals, slots) in oldEntities.items():
        if fVals == vals:
            oldEntitiesBySlots.add(slots)

    missing = 0
    deleted = 0

    delSlots = oldEntitiesBySlots if allMatches is None else allMatches

    for slots in delSlots:
        if slots not in oldEntitiesBySlots:
            missing += 1
            continue

        delEntities.add((vals, slots))
        deleted += 1

    if len(delEntities):
        self.weedEntities(delEntities)

    self.loadData()

    if silent:
        return (missing, deleted)

    self.console(f&#34;Not present: {missing:&gt;5} x&#34;)
    self.console(f&#34;Deleted:     {deleted:&gt;5} x&#34;)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.delEntityRich"><code class="name flex">
<span>def <span class="ident">delEntityRich</span></span>(<span>self, deletions, buckets, excludedTokens=set())</span>
</code></dt>
<dd>
<div class="desc"><p>Delete specified entity occurrences from the current set.</p>
<p>This operation is not allowed if the current set is the read-only set with the
empty name.</p>
<p>This function has more detailed instructions as to which entities
should be deleted than <code><a title="tf.browser.ner.data.Data.delEntity" href="#tf.browser.ner.data.Data.delEntity">Data.delEntity()</a></code> .</p>
<p>It is a handy function for the TF browser to call, but not so much when you
are manipulating entities yourself in a Jupyter notebook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>deletions</code></strong> :&ensp;<code>tuple</code> of <code>tuple</code> or <code>string</code></dt>
<dd>Each member of the tuple corresponds to an entity feature.
It is either a single value of such a feature, or an iterable
of such values.
The tuple together specifies a set of entities whose entity features
have values that are either equal to the corresponding member of
<code>deletions</code> or contained in it.</dd>
<dt><strong><code>buckets</code></strong> :&ensp;<code>iterable</code> of <code>list</code></dt>
<dd>This is typically the result of
<code><a title="tf.browser.ner.annotate.Annotate.filterContent" href="annotate.html#tf.browser.ner.annotate.Annotate.filterContent">Annotate.filterContent()</a></code>.
The only important thing is that member 2 of each bucket is the list
of entity matches in that bucket.
Only entities that occupy these places will be removed.</dd>
<dt><strong><code>excludedTokens</code></strong> :&ensp;<code>set</code>, optional <code>set()</code></dt>
<dd>This is the set of token positions that define the entities that must be
skipped from deletion. If the last slot of an entity is in this set,
the entity will not be deleted.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/703d3977ff845baafe67bbbaa3a678e8deb2b911/tf/browser/ner/data.py#L442-L566" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delEntityRich(self, deletions, buckets, excludedTokens=set()):
    &#34;&#34;&#34;Delete specified entity occurrences from the current set.

    This operation is not allowed if the current set is the read-only set with the
    empty name.

    This function has more detailed instructions as to which entities
    should be deleted than `Data.delEntity()` .

    It is a handy function for the TF browser to call, but not so much when you
    are manipulating entities yourself in a Jupyter notebook.

    Parameters
    ----------
    deletions: tuple of tuple or string
        Each member of the tuple corresponds to an entity feature.
        It is either a single value of such a feature, or an iterable
        of such values.
        The tuple together specifies a set of entities whose entity features
        have values that are either equal to the corresponding member of
        `deletions` or contained in it.
    buckets: iterable of list
        This is typically the result of
        `tf.browser.ner.annotate.Annotate.filterContent()`.
        The only important thing is that member 2 of each bucket is the list
        of entity matches in that bucket.
        Only entities that occupy these places will be removed.
    excludedTokens: set, optional set()
        This is the set of token positions that define the entities that must be
        skipped from deletion. If the last slot of an entity is in this set,
        the entity will not be deleted.
    &#34;&#34;&#34;
    if not self.properlySetup:
        return

    annoSet = self.annoSet
    annoSetRep = self.annoSetRep
    browse = self.browse

    if not annoSet:
        msg = f&#34;Entity deletion not allowed on {annoSetRep}&#34;
        if browse:
            return [[msg]]
        else:
            self.console(msg, error=True)
            return

    settings = self.settings
    features = settings.features
    setData = self.getSetData()

    oldEntities = setData.entities

    report = []

    delEntities = set()
    delEntitiesByE = set()

    deletions = tuple([x] if type(x) is str else x for x in deletions)

    if any(len(x) &gt; 0 for x in deletions):
        oldEntitiesBySlots = collections.defaultdict(set)

        for e, info in oldEntities.items():
            oldEntitiesBySlots[info[1]].add(e)

        excl = 0

        fValTuples = [()]

        for vals in deletions:
            delTuples = []
            for val in vals:
                delTuples.extend([ft + (val,) for ft in fValTuples])
            fValTuples = delTuples

        stats = collections.Counter()

        for bucket in buckets:
            allMatches = bucket[2]

            for slots in allMatches:
                if slots[-1] in excludedTokens:
                    excl += 1
                    continue

                candidates = oldEntitiesBySlots.get(slots, set())

                for e in candidates:
                    toBeDeleted = False
                    fVals = oldEntities[e][0]

                    if fVals in fValTuples:
                        toBeDeleted = True

                    if toBeDeleted:
                        if e not in delEntitiesByE:
                            delEntitiesByE.add(e)
                            delEntities.add((fVals, slots))
                            stats[fVals] += 1

        report.append(
            tuple(sorted(stats.items())) if len(stats) else [&#34;Nothing deleted&#34;]
        )
        if excl:
            report.append(f&#34;Deletion: occurrences excluded: {excl}&#34;)

    if len(delEntities):
        self.weedEntities(delEntities)

    if browse:
        return report

    self.loadData()
    (stats, *rest) = report
    if type(stats) is list:
        self.console(&#34;\n&#34;.join(stats))
    else:
        for vals, freq in stats:
            repVals = &#34; &#34;.join(
                f&#34;{feat}={val}&#34; for (feat, val) in zip(features, vals)
            )
            self.console(f&#34;Deleted {freq:&gt;5} x {repVals}&#34;)
    if len(rest):
        self.console(&#34;\n&#34;.join(rest))</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.fromSource"><code class="name flex">
<span>def <span class="ident">fromSource</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads annotation data from source.</p>
<p>If the current annotation set is <code>""</code>, the annotation data is already in
the TF data,
and we compile that data into a dict of entity data keyed by entity node.</p>
<p>Otherwise, we read the corresponding TSV file from disk and compile that
data into a dict of entity data keyed by line number.</p>
<p>After collection of this data it is stored in the set data; in fact we store
data under the following keys:</p>
<ul>
<li><code>dateLoaded</code>: datetime when the data was last loaded from disk;</li>
<li><code>entities</code>: the list of entities as loaded from the source;
it is a dict of entities, keyed by nodes or line numbers;
each entity specifies a tuple of feature values and a list of slots
that are part of the entity.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/703d3977ff845baafe67bbbaa3a678e8deb2b911/tf/browser/ner/data.py#L102-L192" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fromSource(self):
    &#34;&#34;&#34;Loads annotation data from source.

    If the current annotation set is `&#34;&#34;`, the annotation data is already in
    the TF data,
    and we compile that data into a dict of entity data keyed by entity node.

    Otherwise, we read the corresponding TSV file from disk and compile that
    data into a dict of entity data keyed by line number.

    After collection of this data it is stored in the set data; in fact we store
    data under the following keys:

    *   `dateLoaded`: datetime when the data was last loaded from disk;
    *   `entities`: the list of entities as loaded from the source;
        it is a dict of entities, keyed by nodes or line numbers;
        each entity specifies a tuple of feature values and a list of slots
        that are part of the entity.
    &#34;&#34;&#34;
    if not self.properlySetup:
        return None

    settings = self.settings
    data = self.data
    annoSet = self.annoSet
    setData = data.sets[annoSet]
    annoDir = self.annoDir

    settings = self.settings
    features = settings.features

    featureDefault = self.featureDefault
    nF = len(features)

    checkFeature = self.checkFeature
    getFVal = self.getFVal
    getSlots = self.getSlots

    dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

    if &#34;buckets&#34; not in setData:
        setData.buckets = self.getBucketNodes()

    changed = False

    if annoSet:
        if (
            &#34;entities&#34; not in setData
            or &#34;dateLoaded&#34; not in setData
            or (len(setData.entities) &gt; 0 and not fileExists(dataFile))
            or (fileExists(dataFile) and setData.dateLoaded &lt; mTime(dataFile))
        ):
            # self.console(f&#34;Loading data for {annoSet} ... &#34;, newline=False)
            changed = True
            entities = {}

            if fileExists(dataFile):
                with fileOpen(dataFile) as df:
                    for e, line in enumerate(df):
                        fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
                        entities[e] = (
                            tuple(fields[0:nF]),
                            tuple(int(f) for f in fields[nF:]),
                        )

            setData.entities = entities
            setData.dateLoaded = time.time()
            # self.console(&#34;done.&#34;)
        else:
            # self.console(f&#34;Data for {annoSetRep} already loaded&#34;)
            pass
    else:
        if &#34;entities&#34; not in setData:
            entities = {}
            hasFeature = {feat: checkFeature(feat) for feat in features}

            for e in self.getEntityNodes():
                slots = getSlots(e)
                entities[e] = (
                    tuple(
                        getFVal(feat, e)
                        if hasFeature[feat]
                        else featureDefault[feat](slots)
                        for feat in features
                    ),
                    tuple(slots),
                )

            setData.entities = entities

    return changed</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.loadData"><code class="name flex">
<span>def <span class="ident">loadData</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads data of the current annotation set into memory.</p>
<p>It has two phases:</p>
<ul>
<li>loading the source data (see <code><a title="tf.browser.ner.data.Data.fromSource" href="#tf.browser.ner.data.Data.fromSource">Data.fromSource()</a></code>)</li>
<li>processing the loaded source data (see <code><a title="tf.browser.ner.data.Data.process" href="#tf.browser.ner.data.Data.process">Data.process()</a></code>)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/703d3977ff845baafe67bbbaa3a678e8deb2b911/tf/browser/ner/data.py#L75-L100" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loadData(self):
    &#34;&#34;&#34;Loads data of the current annotation set into memory.

    It has two phases:

    *   loading the source data (see `Data.fromSource()`)
    *   processing the loaded source data (see `Data.process()`)
    &#34;&#34;&#34;
    if not self.properlySetup:
        return

    data = self.data
    annoSet = self.annoSet

    if &#34;sets&#34; not in data:
        data.sets = AttrDict()

    sets = data.sets

    if annoSet not in sets:
        sets[annoSet] = AttrDict()

    # load bucket nodes

    changed = self.fromSource()
    self.process(changed)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.mergeEntities"><code class="name flex">
<span>def <span class="ident">mergeEntities</span></span>(<span>self, newEntities)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs additions to the current annotation set.</p>
<p>This operation is not allowed if the current set is the read-only set with the
empty name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>newEntities</code></strong> :&ensp;<code>set</code></dt>
<dd>The set consists of entity specs: a tuple of values of entity features,
and an iterable of slot tuples where the entity is located.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/703d3977ff845baafe67bbbaa3a678e8deb2b911/tf/browser/ner/data.py#L886-L914" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mergeEntities(self, newEntities):
    &#34;&#34;&#34;Performs additions to the current annotation set.

    This operation is not allowed if the current set is the read-only set with the
    empty name.

    Parameters
    ----------
    newEntities: set
        The set consists of entity specs: a tuple of values of entity features,
        and an iterable of slot tuples where the entity is located.
    &#34;&#34;&#34;
    if not self.properlySetup:
        return

    annoSet = self.annoSet
    annoSetRep = self.annoSetRep

    if not annoSet:
        self.console(f&#34;Entity merging not allowed on {annoSetRep}&#34;, error=True)
        return

    annoDir = self.annoDir

    dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

    with fileOpen(dataFile, mode=&#34;a&#34;) as fh:
        for fVals, slots in newEntities:
            fh.write(&#34;\t&#34;.join(str(x) for x in (*fVals, *slots)) + &#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self, changed)</span>
</code></dt>
<dd>
<div class="desc"><p>Generated derived data structures out of the source data.</p>
<p>After loading we process the data into derived data structures.</p>
<p>We try to be lazy. We only load data from disk if the data is not
already in memory, or the data on disk has been updated since the last load.</p>
<p>The resulting data is stored in current set under the various keys.</p>
<p>After processing, the time of processing is recorded, so that it can be
observed if the processed data is no longer up to date w.r.t. the data as
loaded from source.</p>
<p>For each such set we produce several data structures, which we store
under the following keys:</p>
<ul>
<li><code>dateProcessed</code>: datetime when the data was last processed</li>
<li><code>entityText</code>: dict, text of entity by entity node or line number in
TSV file;</li>
<li><code>entityTextVal</code>: dict of dict, set of feature values of entity, keyed by
feature name and then by text of the entity;</li>
<li><code>entitySummary</code>: dict, list of entity nodes / line numbers, keyed by value
of entity kind;</li>
<li><code>entityIdent</code>: dict, list of entity nodes./line numbers, keyed by tuple of
entity feature values (these tuples are identifying for an entity);</li>
<li><code>entityFreq</code>: dict of counters, a counter for each feature name; the
counter gives the number of times each value of that feature occurs in an
entity;</li>
<li><code>entityIndex</code>: dict of dict, a dict for each feature name; the sub-dict
gives for each position the values that entities occupying that position
can have; positions are tuples of slots;</li>
<li><code>entityVal</code>: dict, keyed by value tuples gives the set of positions
that entities with that value tuple occupy;</li>
<li><code>entitySlotVal</code>: dict, keyed by positions gives the set of values
that entities occupying that position can have;</li>
<li><code>entitySlotAll</code>: dict, keyed by single first slots gives the set of
ending slots that entities starting at that first slot have;</li>
<li>
<p><code>entitySlotIndex</code>: dict, keyed by single slot gives list of items
corresponding to entities that occupy that slot;</p>
<ul>
<li>if an entity starts there, an entry <code>[True, -n, values]</code> is made;</li>
<li>if an entity ends there, an entry <code>[False, n, values]</code> is made;</li>
<li>if an entity occupies that slot without starting or ending there,
an entry <code>None</code> is made;</li>
</ul>
<p>Above, <code>n</code> is the length of the entity in tokens and <code>values</code> is the
tuple of feature values of that entity.</p>
<p>This is precisely the information we need if we want to mark up a set of
entities in the surrounding context of tokens.</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>changed</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether the data has changed since last processing.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/703d3977ff845baafe67bbbaa3a678e8deb2b911/tf/browser/ner/data.py#L194-L358" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def process(self, changed):
    &#34;&#34;&#34;Generated derived data structures out of the source data.

    After loading we process the data into derived data structures.

    We try to be lazy. We only load data from disk if the data is not
    already in memory, or the data on disk has been updated since the last load.

    The resulting data is stored in current set under the various keys.

    After processing, the time of processing is recorded, so that it can be
    observed if the processed data is no longer up to date w.r.t. the data as
    loaded from source.

    For each such set we produce several data structures, which we store
    under the following keys:

    *   `dateProcessed`: datetime when the data was last processed
    *   `entityText`: dict, text of entity by entity node or line number in
        TSV file;
    *   `entityTextVal`: dict of dict, set of feature values of entity, keyed by
        feature name and then by text of the entity;
    *   `entitySummary`: dict, list of entity nodes / line numbers, keyed by value
        of entity kind;
    *   `entityIdent`: dict, list of entity nodes./line numbers, keyed by tuple of
        entity feature values (these tuples are identifying for an entity);
    *   `entityFreq`: dict of counters, a counter for each feature name; the
        counter gives the number of times each value of that feature occurs in an
        entity;
    *   `entityIndex`: dict of dict, a dict for each feature name; the sub-dict
        gives for each position the values that entities occupying that position
        can have; positions are tuples of slots;
    *   `entityVal`: dict, keyed by value tuples gives the set of positions
        that entities with that value tuple occupy;
    *   `entitySlotVal`: dict, keyed by positions gives the set of values
        that entities occupying that position can have;
    *   `entitySlotAll`: dict, keyed by single first slots gives the set of
        ending slots that entities starting at that first slot have;
    *   `entitySlotIndex`: dict, keyed by single slot gives list of items
        corresponding to entities that occupy that slot;

        *   if an entity starts there, an entry `[True, -n, values]` is made;
        *   if an entity ends there, an entry `[False, n, values]` is made;
        *   if an entity occupies that slot without starting or ending there,
            an entry `None` is made;

        Above, `n` is the length of the entity in tokens and `values` is the
        tuple of feature values of that entity.

        This is precisely the information we need if we want to mark up a set of
        entities in the surrounding context of tokens.

    Parameters
    ----------
    changed: boolean
        Whether the data has changed since last processing.
    &#34;&#34;&#34;
    if not self.properlySetup:
        return

    settings = self.settings
    features = settings.features
    getText = self.getText
    summaryIndices = settings.summaryIndices

    data = self.data
    annoSet = self.annoSet
    # annoSetRep = self.annoSetRep
    setData = data.sets[annoSet]

    dateLoaded = setData.dateLoaded
    dateProcessed = setData.dateProcessed

    if (
        changed
        or &#34;dateProcessed&#34; not in setData
        or &#34;entityText&#34; not in setData
        or &#34;entityTextVal&#34; not in setData
        or &#34;entitySummary&#34; not in setData
        or &#34;entityIdent&#34; not in setData
        or &#34;entityFreq&#34; not in setData
        or &#34;entityIndex&#34; not in setData
        or &#34;entityVal&#34; not in setData
        or &#34;entitySlotVal&#34; not in setData
        or &#34;entitySlotAll&#34; not in setData
        or &#34;entitySlotIndex&#34; not in setData
        or dateLoaded is not None
        and dateProcessed &lt; dateLoaded
    ):
        # self.console(f&#34;Processing data of {annoSetRep} ... &#34;, newline=False)

        entityItems = setData.entities.items()

        entityText = {}
        entityTextVal = {feat: collections.defaultdict(set) for feat in features}
        entitySummary = {}
        entityIdent = {}
        entityIdentFirst = {}
        entityFreq = {feat: collections.Counter() for feat in features}
        entityIndex = {feat: {} for feat in features}
        entityVal = {}
        entitySlotVal = {}
        entitySlotAll = {}
        entitySlotIndex = {}

        for e, (fVals, slots) in entityItems:
            txt = getText(slots)
            ident = fVals
            summary = tuple(fVals[i] for i in summaryIndices)

            entityText[e] = txt
            entityVal.setdefault(fVals, set()).add(slots)

            for feat, val in zip(features, fVals):
                entityFreq[feat][val] += 1
                entityIndex[feat].setdefault(slots, set()).add(val)
                entityTextVal[feat][txt].add(val)

            entityIdent.setdefault(ident, []).append(e)
            if ident not in entityIdentFirst:
                entityIdentFirst[ident] = e

            entitySummary.setdefault(summary, []).append(e)
            entitySlotVal.setdefault(slots, set()).add(fVals)

            firstSlot = slots[0]
            lastSlot = slots[-1]

            entitySlotAll.setdefault(firstSlot, set()).add(lastSlot)

            for slot in slots:
                isFirst = slot == firstSlot
                isLast = slot == lastSlot
                if isFirst or isLast:
                    if isFirst:
                        entitySlotIndex.setdefault(slot, []).append(
                            [True, firstSlot - lastSlot - 1, ident]
                        )
                    if isLast:
                        entitySlotIndex.setdefault(slot, []).append(
                            [False, lastSlot - firstSlot + 1, ident]
                        )
                else:
                    entitySlotIndex.setdefault(slot, []).append(None)

        setData.entityText = entityText
        setData.entityTextVal = entityTextVal
        setData.entitySummary = entitySummary
        setData.entityIdent = entityIdent
        setData.entityIdentFirst = entityIdentFirst
        setData.entityFreq = {
            feat: sorted(entityFreq[feat].items()) for feat in features
        }
        setData.entityIndex = entityIndex
        setData.entityVal = entityVal
        setData.entitySlotVal = entitySlotVal
        setData.entitySlotAll = entitySlotAll
        setData.entitySlotIndex = entitySlotIndex

        setData.dateProcessed = time.time()
        # self.console(&#34;done.&#34;)

    else:
        # self.console(f&#34;Data of {annoSetRep} already processed.&#34;)
        pass</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.saveEntitiesAs"><code class="name flex">
<span>def <span class="ident">saveEntitiesAs</span></span>(<span>self, dataFile)</span>
</code></dt>
<dd>
<div class="desc"><p>Export the data of an annotation set to a file.</p>
<p>This function is used when a set has to be duplicated:
<code><a title="tf.browser.ner.sets.Sets.setDup" href="sets.html#tf.browser.ner.sets.Sets.setDup">Sets.setDup()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dataFile</code></strong> :&ensp;<code>string</code></dt>
<dd>The path of the file to write to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/703d3977ff845baafe67bbbaa3a678e8deb2b911/tf/browser/ner/data.py#L916-L935" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def saveEntitiesAs(self, dataFile):
    &#34;&#34;&#34;Export the data of an annotation set to a file.

    This function is used when a set has to be duplicated:
    `tf.browser.ner.sets.Sets.setDup()`.

    Parameters
    ----------
    dataFile: string
        The path of the file to write to.
    &#34;&#34;&#34;
    if not self.properlySetup:
        return

    setData = self.getSetData()
    entities = setData.entities

    with fileOpen(dataFile, mode=&#34;a&#34;) as fh:
        for fVals, slots in entities.values():
            fh.write(&#34;\t&#34;.join(str(x) for x in (*fVals, *slots)) + &#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.data.Data.weedEntities"><code class="name flex">
<span>def <span class="ident">weedEntities</span></span>(<span>self, delEntities)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs deletions to the current annotation set.</p>
<p>This operation is not allowed if the current set is the read-only set with the
empty name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>delEntities</code></strong> :&ensp;<code>set</code></dt>
<dd>The set consists of entity specs: a tuple of values of entity features,
and an iterable of slot tuples where the entity is located.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/703d3977ff845baafe67bbbaa3a678e8deb2b911/tf/browser/ner/data.py#L841-L884" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def weedEntities(self, delEntities):
    &#34;&#34;&#34;Performs deletions to the current annotation set.

    This operation is not allowed if the current set is the read-only set with the
    empty name.

    Parameters
    ----------
    delEntities: set
        The set consists of entity specs: a tuple of values of entity features,
        and an iterable of slot tuples where the entity is located.
    &#34;&#34;&#34;
    if not self.properlySetup:
        return

    annoSet = self.annoSet
    annoSetRep = self.annoSetRep

    if not annoSet:
        self.console(f&#34;Entity weeding not allowed on {annoSetRep}&#34;, error=True)
        return

    settings = self.settings
    features = settings.features
    nF = len(features)

    annoDir = self.annoDir

    dataFile = f&#34;{annoDir}/{annoSet}/entities.tsv&#34;

    newEntities = []

    with fileOpen(dataFile) as fh:
        for line in fh:
            fields = tuple(line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;))
            fVals = tuple(fields[0:nF])
            slots = tuple(int(f) for f in fields[nF:])
            info = (fVals, slots)
            if info in delEntities:
                continue
            newEntities.append(line)

    with fileOpen(dataFile, mode=&#34;w&#34;) as fh:
        fh.write(&#34;&#34;.join(newEntities))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tf.browser.ner.corpus.Corpus" href="corpus.html#tf.browser.ner.corpus.Corpus">Corpus</a></b></code>:
<ul class="hlist">
<li><code><a title="tf.browser.ner.corpus.Corpus.checkBuckets" href="corpus.html#tf.browser.ner.corpus.Corpus.checkBuckets">checkBuckets</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.checkFeature" href="corpus.html#tf.browser.ner.corpus.Corpus.checkFeature">checkFeature</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.console" href="settings.html#tf.browser.ner.settings.Settings.console">console</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.featureDefault" href="corpus.html#tf.browser.ner.corpus.Corpus.featureDefault">featureDefault</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.get0" href="corpus.html#tf.browser.ner.corpus.Corpus.get0">get0</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.get1" href="corpus.html#tf.browser.ner.corpus.Corpus.get1">get1</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getAfter" href="corpus.html#tf.browser.ner.corpus.Corpus.getAfter">getAfter</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getBucketNodes" href="corpus.html#tf.browser.ner.corpus.Corpus.getBucketNodes">getBucketNodes</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getContext" href="corpus.html#tf.browser.ner.corpus.Corpus.getContext">getContext</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getEntityNodes" href="corpus.html#tf.browser.ner.corpus.Corpus.getEntityNodes">getEntityNodes</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getFVal" href="corpus.html#tf.browser.ner.corpus.Corpus.getFVal">getFVal</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getSlots" href="corpus.html#tf.browser.ner.corpus.Corpus.getSlots">getSlots</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getStr" href="corpus.html#tf.browser.ner.corpus.Corpus.getStr">getStr</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getStrings" href="corpus.html#tf.browser.ner.corpus.Corpus.getStrings">getStrings</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getText" href="corpus.html#tf.browser.ner.corpus.Corpus.getText">getText</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getTextR" href="corpus.html#tf.browser.ner.corpus.Corpus.getTextR">getTextR</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getTokens" href="corpus.html#tf.browser.ner.corpus.Corpus.getTokens">getTokens</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.properlySetup" href="corpus.html#tf.browser.ner.corpus.Corpus.properlySetup">properlySetup</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.sectionHead" href="corpus.html#tf.browser.ner.corpus.Corpus.sectionHead">sectionHead</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.slotType" href="corpus.html#tf.browser.ner.corpus.Corpus.slotType">slotType</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.browser.ner" href="index.html">tf.browser.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.browser.ner.data.Data" href="#tf.browser.ner.data.Data">Data</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.browser.ner.data.Data.addEntities" href="#tf.browser.ner.data.Data.addEntities">addEntities</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.addEntity" href="#tf.browser.ner.data.Data.addEntity">addEntity</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.addEntityRich" href="#tf.browser.ner.data.Data.addEntityRich">addEntityRich</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.delEntity" href="#tf.browser.ner.data.Data.delEntity">delEntity</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.delEntityRich" href="#tf.browser.ner.data.Data.delEntityRich">delEntityRich</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.fromSource" href="#tf.browser.ner.data.Data.fromSource">fromSource</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.loadData" href="#tf.browser.ner.data.Data.loadData">loadData</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.mergeEntities" href="#tf.browser.ner.data.Data.mergeEntities">mergeEntities</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.process" href="#tf.browser.ner.data.Data.process">process</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.saveEntitiesAs" href="#tf.browser.ner.data.Data.saveEntitiesAs">saveEntitiesAs</a></code></li>
<li><code><a title="tf.browser.ner.data.Data.weedEntities" href="#tf.browser.ner.data.Data.weedEntities">weedEntities</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>