<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.browser.ner.corpus API documentation</title>
<meta name="description" content="Access to the corpus â€¦" />
<!-- integrity SRI from https://cdnjs.com/libraries/10up-sanitize.css/11.0.1 -->
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha512-kcbluZFacWN57NgWZ4aH6eUMBEaTyErFhIFD3y5qYZbKuuyImH0K/AKsBbfXlivh2z5C+3IDTIhI11YmKomzmA=="
crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha512-uVeAgzAmieLUTGba0qr9vXQgVD7fko2kcbYIKIraXUIDg9iJLxveTFUrg3DJhqn3cAf3HFDbgmhq0eGko5wEAA=="
crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.browser.ner.corpus</code></h1>
</header>
<section id="section-intro">
<p>Access to the corpus.</p>
<p>Contains a bunch of instant methods to access corpus material.</p>
<p>To see how this fits among all the modules of this package, see
<code><a title="tf.browser.ner.annotate" href="annotate.html">tf.browser.ner.annotate</a></code> .</p>
<p>All access to the TF API should happen through methods in this class.</p>
<p>At this point we have the information from the settings and from the corpus.
By collecting all corpus access methods in one class, we have good conceptual
control over how to customize the annotator for different corpora.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/1cf5e9c0fadcf56c0022132ef658bc0189d73054/tf/browser/ner/corpus.py#L1-L364" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Access to the corpus.

Contains a bunch of instant methods to access corpus material.

To see how this fits among all the modules of this package, see
`tf.browser.ner.annotate` .

All access to the TF API should happen through methods in this class.

At this point we have the information from the settings and from the corpus.
By collecting all corpus access methods in one class, we have good conceptual
control over how to customize the annotator for different corpora.
&#34;&#34;&#34;


import re

from .settings import Settings, TOOLKEY
from .helpers import makeCss
from ...core.files import annotateDir


WHITE_RE = re.compile(r&#34;&#34;&#34;\s{2,}&#34;&#34;&#34;, re.S)
NON_ALPHA_RE = re.compile(r&#34;&#34;&#34;[^\w ]&#34;&#34;&#34;, re.S)


class Corpus(Settings):
    def __init__(self):
        &#34;&#34;&#34;Corpus dependent methods for the annotator.

        Everything that depends on the specifics of a corpus, such as getting its text,
        is collected here.

        If a corpus does not have a configuration file that tells TF which
        features to use for text representation, then we flag to the object
        instance that it is not properly set up.

        All methods that might fail because of this, are guarded by a check on this
        flag.
        &#34;&#34;&#34;
        app = self.app
        context = app.context
        appName = context.appName
        version = context.version

        self.appName = appName
        self.version = version
        (specDir, annoDir) = annotateDir(app, TOOLKEY)
        self.specDir = specDir
        self.annoDir = f&#34;{annoDir}/{version}&#34;
        self.sheetDir = f&#34;{specDir}/specs&#34;

        super().__init__()

        api = app.api
        F = api.F
        Fs = api.Fs
        L = api.L
        T = api.T
        slotType = F.otype.slotType

        self.slotType = slotType
        &#34;&#34;&#34;The node type of the slots in the corpus.&#34;&#34;&#34;

        settings = self.settings
        features = settings.features
        keywordFeatures = settings.keywordFeatures
        bucketType = settings.bucketType
        entityType = settings.entityType
        strFeature = settings.strFeature
        afterFeature = settings.afterFeature

        def getSlots(node):
            return L.d(node, otype=slotType)

        def checkFeature(feat):
            return api.isLoaded(feat, pretty=False)[feat] is not None

        def getFVal(feat, node):
            return Fs(feat).v(node)

        def getAfter():
            return Fs(afterFeature).v

        def getStr():
            return Fs(strFeature).v

        if not checkFeature(strFeature) or not checkFeature(afterFeature):
            self.properlySetup = False
            return

        self.properlySetup = True
        &#34;&#34;&#34;Whether the tool has been properly set up.

        This means that the configuration in `ner/config.yaml` or the
        default configuration work correctly with this corpus.
        If not, this attribute will prevent most of the methods
        from working: they fail silently.

        So users of corpora without any need for this tool will not be bothered
        by it.
        &#34;&#34;&#34;

        context = app.context
        self.style = context.defaultClsOrig
        self.ltr = context.direction

        self.css = app.loadToolCss(TOOLKEY, makeCss(features, keywordFeatures))

        strv = getStr()
        afterv = getAfter()

        def getText(slots):
            text = &#34;&#34;.join(f&#34;&#34;&#34;{strv(s)}{afterv(s) or &#34;&#34;}&#34;&#34;&#34; for s in slots).strip()
            # text = WHITE_RE.sub(&#34; &#34;, text)
            return text

        def getTextR(node):
            slots = L.d(node, otype=slotType)
            text = &#34;&#34;.join(f&#34;&#34;&#34;{strv(s)}{afterv(s) or &#34;&#34;}&#34;&#34;&#34; for s in slots).strip()
            # text = WHITE_RE.sub(&#34; &#34;, text)
            return text

        def getTokens(node):
            return [(t, strv(t)) or &#34;&#34; for t in L.d(node, otype=slotType)]

        def getStrings(tokenStart, tokenEnd):
            return tuple(
                token
                for t in range(tokenStart, tokenEnd + 1)
                if (token := (strv(t) or &#34;&#34;).strip())
            )

        def getContext(node):
            return L.d(T.sectionTuple(node)[1], otype=bucketType)

        def get0(slots):
            text = getText(slots)
            text = NON_ALPHA_RE.sub(&#34;&#34;, text)
            text = text.replace(&#34; &#34;, &#34;.&#34;).strip(&#34;.&#34;).lower()
            return text

        def get1(slots):
            return settings.defaultValues[features[1]]

        def getBucketNodes():
            return F.otype.s(bucketType)

        def getEntityNodes():
            return F.otype.s(entityType)

        def sectionHead(node):
            return app.sectionStrFromNode(node)

        def checkBuckets(nodes):
            return {node for node in nodes if F.otype.v(node) == bucketType}

        self.checkFeature = checkFeature
        &#34;&#34;&#34;Checks whether a feature is loaded in the corpus.

        Parameters
        ----------
        feat: string
            The name of the feature

        Returns
        -------
        boolean
            Whether the feature is loaded in this corpus.
        &#34;&#34;&#34;

        self.getFVal = getFVal
        &#34;&#34;&#34;Retrieves the value of a feature for a node.

        Parameters
        ----------
        feat: string
            The name of the feature
        node: int
            The node whose feature value we need

        Returns
        -------
        string or integer or void
            The value of the feature for that node, if there is a value.
        &#34;&#34;&#34;

        self.getStr = getStr
        &#34;&#34;&#34;Delivers a function that retrieves the material of a slot.

        Returns
        -------
        function
            It accepts integers, presumably slots, and delivers the value
            of the *str* feature, which is configured in `ner/config.yaml`
            under key `strFeature` .
        &#34;&#34;&#34;

        self.getAfter = getAfter
        &#34;&#34;&#34;Delivers a function that retrieves the material after a slot.

        Returns
        -------
        function
            It accepts integers, presumably slots, and delivers the value
            of the *after* feature, which is configured in `ner/config.yaml`
            under key `afterFeature` .
        &#34;&#34;&#34;

        self.getSlots = getSlots
        &#34;&#34;&#34;Gets the slot nodes contained in a node.

        Parameters
        ----------
        node: integer
            The container node.

        Returns
        -------
        list of integer
            The slots in the container.
        &#34;&#34;&#34;

        self.getText = getText
        &#34;&#34;&#34;Gets the text of a number of slots.

        Parameters
        ----------
        slots: iterable of integer

        Returns
        -------
        string
            The concatenation of the representation of the individual slots.
            These representations are white-space trimmed at both sides,
            and the concatenation adds a single space between each adjacent pair
            of them.

            !!! caution &#34;Space between slots&#34;
                Leading and trailing white-space is stripped, and inner white-space is
                normalized to a single space.
                The text of the individual slots is joined by means of a single
                white-space, also in corpora that may have zero space between words.
        &#34;&#34;&#34;

        self.getTextR = getTextR
        &#34;&#34;&#34;Gets the text for a non-slot node.

        It first determines the slots contained in a node, and then uses
        `Settings.getText()` to return the text of those slots.

        Parameters
        ----------
        node: integer
            The nodes for whose slots we want the text.

        Returns
        -------
        string
        &#34;&#34;&#34;

        self.getTokens = getTokens
        &#34;&#34;&#34;Gets the tokens contained in node.

        Parameters
        ----------
        node: integer
            The nodes whose slots we want.

        Returns
        -------
        list of tuple
            Each tuple is a pair of the slot number of the token and its
            string value. If there is no string value, the empty string is taken.
        &#34;&#34;&#34;

        self.getStrings = getStrings
        &#34;&#34;&#34;Gets the text of the tokens occupying a sequence of slots.

        Parameters
        ----------
        tokenStart: integer
            The position of the starting token.
        tokenEnd: integer
            The position of the ending token.

        Returns
        -------
        tuple
            The members consist of the string values of the tokens in question,
            as far as these values are not purely white-space.
            Also, the string values are stripped from leading and trailing white-space.
        &#34;&#34;&#34;

        self.getContext = getContext
        &#34;&#34;&#34;Gets the context buckets around a node.

        We start from a node and find the section node of intermediate level
        that contains that node. Then we return all buckets contained in that
        section.

        Parameters
        ----------
        node: int

        Returns
        -------
        tuple of int
        &#34;&#34;&#34;

        self.get0 = get0
        &#34;&#34;&#34;Makes an identifier value out of a number of slots.

        This acts as the default value for the `eid` feature of new
        entities.

        Starting with the white-space-normalized text of a number of slots,
        the string is lowercased, non-alphanumeric characters are stripped,
        and spaces are replaced by dots.
        &#34;&#34;&#34;

        self.get1 = get1
        &#34;&#34;&#34;Return a fixed value specified in the corpus-dependent settings.

        This acts as the default value ofr the `kind` feature of new
        entities.
        &#34;&#34;&#34;

        self.getBucketNodes = getBucketNodes
        &#34;&#34;&#34;Return all bucket nodes.&#34;&#34;&#34;

        self.getEntityNodes = getEntityNodes
        &#34;&#34;&#34;Return all entity nodes.&#34;&#34;&#34;

        self.sectionHead = sectionHead
        &#34;&#34;&#34;Provide a section heading.

        Parameters
        ----------
        node: integer
            The node whose section head we need.

        Returns
        -------
        string
        &#34;&#34;&#34;

        self.checkBuckets = checkBuckets
        &#34;&#34;&#34;Given a set of nodes, return the set of only its bucket nodes.

        Parameters
        ----------
        nodes: set of int

        Returns
        -------
        set of int
        &#34;&#34;&#34;

        self.featureDefault = {
            features[0]: get0,
            features[1]: get1,
        }
        &#34;&#34;&#34;Functions that deliver default values for the entity features.&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.browser.ner.corpus.Corpus"><code class="flex name class">
<span>class <span class="ident">Corpus</span></span>
</code></dt>
<dd>
<div class="desc"><p>Corpus dependent methods for the annotator.</p>
<p>Everything that depends on the specifics of a corpus, such as getting its text,
is collected here.</p>
<p>If a corpus does not have a configuration file that tells TF which
features to use for text representation, then we flag to the object
instance that it is not properly set up.</p>
<p>All methods that might fail because of this, are guarded by a check on this
flag.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/1cf5e9c0fadcf56c0022132ef658bc0189d73054/tf/browser/ner/corpus.py#L27-L364" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Corpus(Settings):
    def __init__(self):
        &#34;&#34;&#34;Corpus dependent methods for the annotator.

        Everything that depends on the specifics of a corpus, such as getting its text,
        is collected here.

        If a corpus does not have a configuration file that tells TF which
        features to use for text representation, then we flag to the object
        instance that it is not properly set up.

        All methods that might fail because of this, are guarded by a check on this
        flag.
        &#34;&#34;&#34;
        app = self.app
        context = app.context
        appName = context.appName
        version = context.version

        self.appName = appName
        self.version = version
        (specDir, annoDir) = annotateDir(app, TOOLKEY)
        self.specDir = specDir
        self.annoDir = f&#34;{annoDir}/{version}&#34;
        self.sheetDir = f&#34;{specDir}/specs&#34;

        super().__init__()

        api = app.api
        F = api.F
        Fs = api.Fs
        L = api.L
        T = api.T
        slotType = F.otype.slotType

        self.slotType = slotType
        &#34;&#34;&#34;The node type of the slots in the corpus.&#34;&#34;&#34;

        settings = self.settings
        features = settings.features
        keywordFeatures = settings.keywordFeatures
        bucketType = settings.bucketType
        entityType = settings.entityType
        strFeature = settings.strFeature
        afterFeature = settings.afterFeature

        def getSlots(node):
            return L.d(node, otype=slotType)

        def checkFeature(feat):
            return api.isLoaded(feat, pretty=False)[feat] is not None

        def getFVal(feat, node):
            return Fs(feat).v(node)

        def getAfter():
            return Fs(afterFeature).v

        def getStr():
            return Fs(strFeature).v

        if not checkFeature(strFeature) or not checkFeature(afterFeature):
            self.properlySetup = False
            return

        self.properlySetup = True
        &#34;&#34;&#34;Whether the tool has been properly set up.

        This means that the configuration in `ner/config.yaml` or the
        default configuration work correctly with this corpus.
        If not, this attribute will prevent most of the methods
        from working: they fail silently.

        So users of corpora without any need for this tool will not be bothered
        by it.
        &#34;&#34;&#34;

        context = app.context
        self.style = context.defaultClsOrig
        self.ltr = context.direction

        self.css = app.loadToolCss(TOOLKEY, makeCss(features, keywordFeatures))

        strv = getStr()
        afterv = getAfter()

        def getText(slots):
            text = &#34;&#34;.join(f&#34;&#34;&#34;{strv(s)}{afterv(s) or &#34;&#34;}&#34;&#34;&#34; for s in slots).strip()
            # text = WHITE_RE.sub(&#34; &#34;, text)
            return text

        def getTextR(node):
            slots = L.d(node, otype=slotType)
            text = &#34;&#34;.join(f&#34;&#34;&#34;{strv(s)}{afterv(s) or &#34;&#34;}&#34;&#34;&#34; for s in slots).strip()
            # text = WHITE_RE.sub(&#34; &#34;, text)
            return text

        def getTokens(node):
            return [(t, strv(t)) or &#34;&#34; for t in L.d(node, otype=slotType)]

        def getStrings(tokenStart, tokenEnd):
            return tuple(
                token
                for t in range(tokenStart, tokenEnd + 1)
                if (token := (strv(t) or &#34;&#34;).strip())
            )

        def getContext(node):
            return L.d(T.sectionTuple(node)[1], otype=bucketType)

        def get0(slots):
            text = getText(slots)
            text = NON_ALPHA_RE.sub(&#34;&#34;, text)
            text = text.replace(&#34; &#34;, &#34;.&#34;).strip(&#34;.&#34;).lower()
            return text

        def get1(slots):
            return settings.defaultValues[features[1]]

        def getBucketNodes():
            return F.otype.s(bucketType)

        def getEntityNodes():
            return F.otype.s(entityType)

        def sectionHead(node):
            return app.sectionStrFromNode(node)

        def checkBuckets(nodes):
            return {node for node in nodes if F.otype.v(node) == bucketType}

        self.checkFeature = checkFeature
        &#34;&#34;&#34;Checks whether a feature is loaded in the corpus.

        Parameters
        ----------
        feat: string
            The name of the feature

        Returns
        -------
        boolean
            Whether the feature is loaded in this corpus.
        &#34;&#34;&#34;

        self.getFVal = getFVal
        &#34;&#34;&#34;Retrieves the value of a feature for a node.

        Parameters
        ----------
        feat: string
            The name of the feature
        node: int
            The node whose feature value we need

        Returns
        -------
        string or integer or void
            The value of the feature for that node, if there is a value.
        &#34;&#34;&#34;

        self.getStr = getStr
        &#34;&#34;&#34;Delivers a function that retrieves the material of a slot.

        Returns
        -------
        function
            It accepts integers, presumably slots, and delivers the value
            of the *str* feature, which is configured in `ner/config.yaml`
            under key `strFeature` .
        &#34;&#34;&#34;

        self.getAfter = getAfter
        &#34;&#34;&#34;Delivers a function that retrieves the material after a slot.

        Returns
        -------
        function
            It accepts integers, presumably slots, and delivers the value
            of the *after* feature, which is configured in `ner/config.yaml`
            under key `afterFeature` .
        &#34;&#34;&#34;

        self.getSlots = getSlots
        &#34;&#34;&#34;Gets the slot nodes contained in a node.

        Parameters
        ----------
        node: integer
            The container node.

        Returns
        -------
        list of integer
            The slots in the container.
        &#34;&#34;&#34;

        self.getText = getText
        &#34;&#34;&#34;Gets the text of a number of slots.

        Parameters
        ----------
        slots: iterable of integer

        Returns
        -------
        string
            The concatenation of the representation of the individual slots.
            These representations are white-space trimmed at both sides,
            and the concatenation adds a single space between each adjacent pair
            of them.

            !!! caution &#34;Space between slots&#34;
                Leading and trailing white-space is stripped, and inner white-space is
                normalized to a single space.
                The text of the individual slots is joined by means of a single
                white-space, also in corpora that may have zero space between words.
        &#34;&#34;&#34;

        self.getTextR = getTextR
        &#34;&#34;&#34;Gets the text for a non-slot node.

        It first determines the slots contained in a node, and then uses
        `Settings.getText()` to return the text of those slots.

        Parameters
        ----------
        node: integer
            The nodes for whose slots we want the text.

        Returns
        -------
        string
        &#34;&#34;&#34;

        self.getTokens = getTokens
        &#34;&#34;&#34;Gets the tokens contained in node.

        Parameters
        ----------
        node: integer
            The nodes whose slots we want.

        Returns
        -------
        list of tuple
            Each tuple is a pair of the slot number of the token and its
            string value. If there is no string value, the empty string is taken.
        &#34;&#34;&#34;

        self.getStrings = getStrings
        &#34;&#34;&#34;Gets the text of the tokens occupying a sequence of slots.

        Parameters
        ----------
        tokenStart: integer
            The position of the starting token.
        tokenEnd: integer
            The position of the ending token.

        Returns
        -------
        tuple
            The members consist of the string values of the tokens in question,
            as far as these values are not purely white-space.
            Also, the string values are stripped from leading and trailing white-space.
        &#34;&#34;&#34;

        self.getContext = getContext
        &#34;&#34;&#34;Gets the context buckets around a node.

        We start from a node and find the section node of intermediate level
        that contains that node. Then we return all buckets contained in that
        section.

        Parameters
        ----------
        node: int

        Returns
        -------
        tuple of int
        &#34;&#34;&#34;

        self.get0 = get0
        &#34;&#34;&#34;Makes an identifier value out of a number of slots.

        This acts as the default value for the `eid` feature of new
        entities.

        Starting with the white-space-normalized text of a number of slots,
        the string is lowercased, non-alphanumeric characters are stripped,
        and spaces are replaced by dots.
        &#34;&#34;&#34;

        self.get1 = get1
        &#34;&#34;&#34;Return a fixed value specified in the corpus-dependent settings.

        This acts as the default value ofr the `kind` feature of new
        entities.
        &#34;&#34;&#34;

        self.getBucketNodes = getBucketNodes
        &#34;&#34;&#34;Return all bucket nodes.&#34;&#34;&#34;

        self.getEntityNodes = getEntityNodes
        &#34;&#34;&#34;Return all entity nodes.&#34;&#34;&#34;

        self.sectionHead = sectionHead
        &#34;&#34;&#34;Provide a section heading.

        Parameters
        ----------
        node: integer
            The node whose section head we need.

        Returns
        -------
        string
        &#34;&#34;&#34;

        self.checkBuckets = checkBuckets
        &#34;&#34;&#34;Given a set of nodes, return the set of only its bucket nodes.

        Parameters
        ----------
        nodes: set of int

        Returns
        -------
        set of int
        &#34;&#34;&#34;

        self.featureDefault = {
            features[0]: get0,
            features[1]: get1,
        }
        &#34;&#34;&#34;Functions that deliver default values for the entity features.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tf.browser.ner.settings.Settings" href="settings.html#tf.browser.ner.settings.Settings">Settings</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tf.browser.ner.data.Data" href="data.html#tf.browser.ner.data.Data">Data</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tf.browser.ner.corpus.Corpus.checkBuckets"><code class="name">var <span class="ident">checkBuckets</span></code></dt>
<dd>
<div class="desc"><p>Given a set of nodes, return the set of only its bucket nodes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nodes</code></strong> :&ensp;<code>set</code> of <code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set</code> of <code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.checkFeature"><code class="name">var <span class="ident">checkFeature</span></code></dt>
<dd>
<div class="desc"><p>Checks whether a feature is loaded in the corpus.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feat</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the feature</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether the feature is loaded in this corpus.</dd>
</dl></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.featureDefault"><code class="name">var <span class="ident">featureDefault</span></code></dt>
<dd>
<div class="desc"><p>Functions that deliver default values for the entity features.</p></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.get0"><code class="name">var <span class="ident">get0</span></code></dt>
<dd>
<div class="desc"><p>Makes an identifier value out of a number of slots.</p>
<p>This acts as the default value for the <code>eid</code> feature of new
entities.</p>
<p>Starting with the white-space-normalized text of a number of slots,
the string is lowercased, non-alphanumeric characters are stripped,
and spaces are replaced by dots.</p></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.get1"><code class="name">var <span class="ident">get1</span></code></dt>
<dd>
<div class="desc"><p>Return a fixed value specified in the corpus-dependent settings.</p>
<p>This acts as the default value ofr the <code>kind</code> feature of new
entities.</p></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.getAfter"><code class="name">var <span class="ident">getAfter</span></code></dt>
<dd>
<div class="desc"><p>Delivers a function that retrieves the material after a slot.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>function</code></dt>
<dd>It accepts integers, presumably slots, and delivers the value
of the <em>after</em> feature, which is configured in <code>ner/config.yaml</code>
under key <code>afterFeature</code> .</dd>
</dl></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.getBucketNodes"><code class="name">var <span class="ident">getBucketNodes</span></code></dt>
<dd>
<div class="desc"><p>Return all bucket nodes.</p></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.getContext"><code class="name">var <span class="ident">getContext</span></code></dt>
<dd>
<div class="desc"><p>Gets the context buckets around a node.</p>
<p>We start from a node and find the section node of intermediate level
that contains that node. Then we return all buckets contained in that
section.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.getEntityNodes"><code class="name">var <span class="ident">getEntityNodes</span></code></dt>
<dd>
<div class="desc"><p>Return all entity nodes.</p></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.getFVal"><code class="name">var <span class="ident">getFVal</span></code></dt>
<dd>
<div class="desc"><p>Retrieves the value of a feature for a node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feat</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the feature</dd>
<dt><strong><code>node</code></strong> :&ensp;<code>int</code></dt>
<dd>The node whose feature value we need</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code> or <code>integer</code> or <code>void</code></dt>
<dd>The value of the feature for that node, if there is a value.</dd>
</dl></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.getSlots"><code class="name">var <span class="ident">getSlots</span></code></dt>
<dd>
<div class="desc"><p>Gets the slot nodes contained in a node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>integer</code></dt>
<dd>The container node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>integer</code></dt>
<dd>The slots in the container.</dd>
</dl></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.getStr"><code class="name">var <span class="ident">getStr</span></code></dt>
<dd>
<div class="desc"><p>Delivers a function that retrieves the material of a slot.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>function</code></dt>
<dd>It accepts integers, presumably slots, and delivers the value
of the <em>str</em> feature, which is configured in <code>ner/config.yaml</code>
under key <code>strFeature</code> .</dd>
</dl></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.getStrings"><code class="name">var <span class="ident">getStrings</span></code></dt>
<dd>
<div class="desc"><p>Gets the text of the tokens occupying a sequence of slots.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tokenStart</code></strong> :&ensp;<code>integer</code></dt>
<dd>The position of the starting token.</dd>
<dt><strong><code>tokenEnd</code></strong> :&ensp;<code>integer</code></dt>
<dd>The position of the ending token.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>The members consist of the string values of the tokens in question,
as far as these values are not purely white-space.
Also, the string values are stripped from leading and trailing white-space.</dd>
</dl></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.getText"><code class="name">var <span class="ident">getText</span></code></dt>
<dd>
<div class="desc"><p>Gets the text of a number of slots.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>slots</code></strong> :&ensp;<code>iterable</code> of <code>integer</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>
<p>The concatenation of the representation of the individual slots.
These representations are white-space trimmed at both sides,
and the concatenation adds a single space between each adjacent pair
of them.</p>
<div class="admonition caution">
<p class="admonition-title">Space between slots</p>
<p>Leading and trailing white-space is stripped, and inner white-space is
normalized to a single space.
The text of the individual slots is joined by means of a single
white-space, also in corpora that may have zero space between words.</p>
</div>
</dd>
</dl></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.getTextR"><code class="name">var <span class="ident">getTextR</span></code></dt>
<dd>
<div class="desc"><p>Gets the text for a non-slot node.</p>
<p>It first determines the slots contained in a node, and then uses
<code>Settings.getText()</code> to return the text of those slots.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>integer</code></dt>
<dd>The nodes for whose slots we want the text.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.getTokens"><code class="name">var <span class="ident">getTokens</span></code></dt>
<dd>
<div class="desc"><p>Gets the tokens contained in node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>integer</code></dt>
<dd>The nodes whose slots we want.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>tuple</code></dt>
<dd>Each tuple is a pair of the slot number of the token and its
string value. If there is no string value, the empty string is taken.</dd>
</dl></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.properlySetup"><code class="name">var <span class="ident">properlySetup</span></code></dt>
<dd>
<div class="desc"><p>Whether the tool has been properly set up.</p>
<p>This means that the configuration in <code>ner/config.yaml</code> or the
default configuration work correctly with this corpus.
If not, this attribute will prevent most of the methods
from working: they fail silently.</p>
<p>So users of corpora without any need for this tool will not be bothered
by it.</p></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.sectionHead"><code class="name">var <span class="ident">sectionHead</span></code></dt>
<dd>
<div class="desc"><p>Provide a section heading.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>integer</code></dt>
<dd>The node whose section head we need.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="tf.browser.ner.corpus.Corpus.slotType"><code class="name">var <span class="ident">slotType</span></code></dt>
<dd>
<div class="desc"><p>The node type of the slots in the corpus.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tf.browser.ner.settings.Settings" href="settings.html#tf.browser.ner.settings.Settings">Settings</a></b></code>:
<ul class="hlist">
<li><code><a title="tf.browser.ner.settings.Settings.console" href="settings.html#tf.browser.ner.settings.Settings.console">console</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.browser.ner" href="index.html">tf.browser.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.browser.ner.corpus.Corpus" href="#tf.browser.ner.corpus.Corpus">Corpus</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.browser.ner.corpus.Corpus.checkBuckets" href="#tf.browser.ner.corpus.Corpus.checkBuckets">checkBuckets</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.checkFeature" href="#tf.browser.ner.corpus.Corpus.checkFeature">checkFeature</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.featureDefault" href="#tf.browser.ner.corpus.Corpus.featureDefault">featureDefault</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.get0" href="#tf.browser.ner.corpus.Corpus.get0">get0</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.get1" href="#tf.browser.ner.corpus.Corpus.get1">get1</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getAfter" href="#tf.browser.ner.corpus.Corpus.getAfter">getAfter</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getBucketNodes" href="#tf.browser.ner.corpus.Corpus.getBucketNodes">getBucketNodes</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getContext" href="#tf.browser.ner.corpus.Corpus.getContext">getContext</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getEntityNodes" href="#tf.browser.ner.corpus.Corpus.getEntityNodes">getEntityNodes</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getFVal" href="#tf.browser.ner.corpus.Corpus.getFVal">getFVal</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getSlots" href="#tf.browser.ner.corpus.Corpus.getSlots">getSlots</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getStr" href="#tf.browser.ner.corpus.Corpus.getStr">getStr</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getStrings" href="#tf.browser.ner.corpus.Corpus.getStrings">getStrings</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getText" href="#tf.browser.ner.corpus.Corpus.getText">getText</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getTextR" href="#tf.browser.ner.corpus.Corpus.getTextR">getTextR</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.getTokens" href="#tf.browser.ner.corpus.Corpus.getTokens">getTokens</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.properlySetup" href="#tf.browser.ner.corpus.Corpus.properlySetup">properlySetup</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.sectionHead" href="#tf.browser.ner.corpus.Corpus.sectionHead">sectionHead</a></code></li>
<li><code><a title="tf.browser.ner.corpus.Corpus.slotType" href="#tf.browser.ner.corpus.Corpus.slotType">slotType</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>