<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.browser.ner.tables API documentation</title>
<meta name="description" content="Module to compose tables of result data." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.browser.ner.tables</code></h1>
</header>
<section id="section-intro">
<p>Module to compose tables of result data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/tables.py#L1-L810" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Module to compose tables of result data.
&#34;&#34;&#34;

import collections
from itertools import chain
from textwrap import dedent

from .kernel import FEATURES, KEYWORD_FEATURES, mergeEntities, weedEntities, WHITE_RE


def repIdent(vals):
    return &#34; &#34;.join(
        f&#34;&#34;&#34;&lt;span class=&#34;{feat}&#34;&gt;{val}&lt;/span&gt;&#34;&#34;&#34;
        for (feat, val) in zip(FEATURES[1:], vals)
    )


def composeE(web, activeEntity, activeKind, sortKey, sortDir):
    &#34;&#34;&#34;Compose a table of entities with selection and sort controls.

    Parameters
    ----------
    web: object
        The web app object
    sortKey: string
        Indicates how to sort the table:

        *   `freqsort`: by the frequency of the entities
        *   `textsort`: by the text of the entities
        *   `idsort`: by the kind of the entities
        *   `kindsort`: by the kind of the entities

    sortDir: string
        Indicates the direction of the sort:

        *   `u`: up, i.e. ascending
        *   `d`: down, i.e. descending

    Returns
    -------
    html string
        The finished HTML of the table, ready to put into the Flask template.
    &#34;&#34;&#34;

    setData = web.toolData.ner.sets[web.annoSet]

    html = []

    entities = setData.entities
    entries = setData.entityBy.items()

    if sortKey == &#34;sort&#34;:
        entries = sorted(entries, key=lambda x: (len(x[1]), x[0]))
    else:
        index = int(sortKey[4:])
        entries = sorted(entries, key=lambda x: (x[0][index], -len(x[1])))

    if sortDir == &#34;d&#34;:
        entries = reversed(entries)

    for (i, (vals, es)) in enumerate(entries):
        x = len(es)
        e1 = es[0]
        ent1 = entities[e1]
        (eFirst, eLast) = (ent1[2], ent1[-1])

        active = &#34; queried &#34; if activeEntity is not None and i == activeEntity else &#34;&#34;

        item = dedent(
            f&#34;&#34;&#34;
            &lt;p
                class=&#34;e {active}&#34;
                enm=&#34;{i}&#34;
                tstart=&#34;{eFirst}&#34; tend=&#34;{eLast}&#34;
            &gt;
                &lt;code class=&#34;w&#34;&gt;{x:&gt;5}&lt;/code&gt;
                x
                {repIdent(vals)}&gt;
            &lt;/p&gt;&#34;&#34;&#34;
        )
        html.append(item)

    return &#34;\n&#34;.join(html)


def composeQ(
    web,
    templateData,
    sFind,
    sFindRe,
    sFindError,
    valSelect,
    nFind,
    nEnt,
    nVisible,
    scope,
    report,
):
    &#34;&#34;&#34;HTML for the query line.

    Parameters
    ----------
    web: object
        The web app object

    Returns
    -------
    html string
        The finished HTML of the query parameters
    &#34;&#34;&#34;

    kernelApi = web.kernelApi
    app = kernelApi.app
    api = app.api
    F = api.F
    T = api.T

    annoSet = web.annoSet
    setData = web.toolData.ner.sets[annoSet]
    nSent = len(setData.sentences)

    tokenStart = templateData[&#34;tokenstart&#34;]
    tokenEnd = templateData[&#34;tokenend&#34;]

    hasFind = sFindRe is not None
    hasEntity = tokenStart and tokenEnd

    html = []

    # FILTER SECTION

    findStat = composeFindStat(nSent, nFind, hasFind)

    html.append(
        dedent(
            f&#34;&#34;&#34;
            &lt;p&gt;
                &lt;b&gt;Filter:&lt;/b&gt;
                &lt;input type=&#34;text&#34; name=&#34;sfind&#34; id=&#34;sfind&#34; value=&#34;{sFind}&#34;&gt;
                {findStat}
                &lt;button type=&#34;submit&#34; id=&#34;findclear&#34;&gt;‚úñÔ∏è&lt;/button&gt;
                &lt;span id=&#34;sfinderror&#34; class=&#34;error&#34;&gt;{sFindError}&lt;/span&gt;
                &lt;button type=&#34;submit&#34; id=&#34;lookupf&#34;&gt;üîé&lt;/button&gt;
            &lt;/p&gt;
            &#34;&#34;&#34;
        )
    )

    # ENTITY SECTION
    # The entity text

    words = (
        [
            f&#34;&#34;&#34;{F.str.v(t) or &#34;&#34;}{F.after.v(t) or &#34;&#34;}&#34;&#34;&#34;.strip()
            for t in range(tokenStart, tokenEnd + 1)
        ]
        if hasEntity
        else []
    )

    wordHtml = &#34; &#34;.join(f&#34;&#34;&#34;&lt;span&gt;{w}&lt;/span&gt;&#34;&#34;&#34; for w in words if w)

    html.append(
        dedent(
            f&#34;&#34;&#34;
            &lt;p&gt;
                &lt;b&gt;Entity:&lt;/b&gt;
                &lt;input type=&#34;hidden&#34;
                    name=&#34;tokenstart&#34;
                    id=&#34;tokenstart&#34;
                    value=&#34;{tokenStart or &#34;&#34;}&#34;
                &gt;
                &lt;input type=&#34;hidden&#34;
                    name=&#34;tokenend&#34;
                    id=&#34;tokenend&#34;
                    value=&#34;{tokenEnd or &#34;&#34;}&#34;
                &gt;
                &lt;span id=&#34;qwordshow&#34;&gt;{wordHtml}&lt;/span&gt;
                &lt;button type=&#34;submit&#34; id=&#34;queryclear&#34;&gt;‚úñÔ∏è&lt;/button&gt;
                &lt;button type=&#34;submit&#34; id=&#34;lookupq&#34;&gt;üîé&lt;/button&gt;
            &#34;&#34;&#34;
        )
    )

    # ENTITY SECTION
    # The entity features

    txt = (
        WHITE_RE.sub(&#34; &#34;, T.text(range(tokenStart, tokenEnd + 1)).strip())
        if hasEntity
        else &#34;&#34;
    )
    features = setData.entityTextVal[txt]

    for feat in FEATURES[1:]:
        theseVals = features.get(feat, set())
        thisValSelect = valSelect[feat]

        html.append(
            dedent(
                f&#34;&#34;&#34;
                &lt;input type=&#34;hidden&#34;
                    name=&#34;{feat}select&#34;
                    id=&#34;{feat}select&#34;
                    value=&#34;{&#34;,&#34;.join(thisValSelect)}&#34;
                &gt;
                &#34;&#34;&#34;
            )
        )
        for val in [&#34;‚åÄ&#34;] + sorted(theseVals):
            status = &#34;v&#34; if val in thisValSelect else &#34;x&#34;
            entityStat = composeEntityStat(
                val, nVisible[feat], nEnt[feat], hasFind, hasEntity
            )
            title = f&#34;{feat} not marked&#34; if val == &#34;‚åÄ&#34; else f&#34;{feat} marked as {val}&#34;

            html.append(
                dedent(
                    f&#34;&#34;&#34;
                    &lt;button type=&#34;button&#34;
                        name=&#34;{val}&#34;
                        class=&#34;{feat}sel&#34;
                        st=&#34;{status}&#34;
                        title=&#34;{title}&#34;
                    &gt;
                        {val}
                        {entityStat}
                    &lt;/button&gt;
                    &#34;&#34;&#34;
                )
            )

        html.append(
            dedent(
                &#34;&#34;&#34;
                &lt;/p&gt;
                &#34;&#34;&#34;
            )
        )

    # MODIFY SECTION

    html.append(
        dedent(
            f&#34;&#34;&#34;
            &lt;input type=&#34;hidden&#34;
                id=&#34;scope&#34;
                name=&#34;scope&#34;
                value=&#34;{scope}&#34;
            &gt;
            &#34;&#34;&#34;
        )
    )

    if annoSet and hasEntity:
        html.append(
            dedent(
                &#34;&#34;&#34;
                &lt;p&gt;&lt;b&gt;Target:&lt;/b&gt;
                &#34;&#34;&#34;
            )
        )
        # Scope of modification

        if hasFind:
            html.append(
                dedent(
                    &#34;&#34;&#34;
                    &lt;button type=&#34;button&#34;
                        id=&#34;scopefiltered&#34;
                        title=&#34;act on filtered sentences only&#34;
                    &gt;filtered
                    &lt;/button&gt;
                    &lt;button type=&#34;button&#34;
                        id=&#34;scopeall&#34;
                        title=&#34;act on all sentences&#34;
                    &gt;all
                    &lt;/button&gt;
                    &#34;&#34;&#34;
                )
            )
        html.append(
            dedent(
                &#34;&#34;&#34;
                &lt;button type=&#34;button&#34;
                    id=&#34;selectall&#34;
                    title=&#34;select all occurences in filtered sentences&#34;
                &gt;üÜó&lt;/button&gt;
                &lt;button type=&#34;button&#34;
                    id=&#34;selectnone&#34;
                    title=&#34;deselect all occurences in filtered sentences&#34;
                &gt;‚≠ïÔ∏è&lt;/button&gt;
                &#34;&#34;&#34;
            )
        )
        html.append(
            dedent(
                &#34;&#34;&#34;
                &lt;/p&gt;
                &#34;&#34;&#34;
            )
        )
        html.append(
            dedent(
                &#34;&#34;&#34;
                &lt;p&gt;&lt;b&gt;Assignment:&lt;/b&gt;
                &#34;&#34;&#34;
            )
        )

        for feat in FEATURES[1:]:
            theseVals = sorted(setData.entityTextVal[feat].get(txt, set()))
            allVals = (
                sorted(x[0] for x in setData.entityFreq[feat])
                if feat in KEYWORD_FEATURES
                else theseVals
            )
            for kind in allVals:
                occurs = kind in theseVals
                occurCls = &#34; occurs &#34; if occurs else &#34;&#34;

                html.append(
                    dedent(
                        f&#34;&#34;&#34;
                        &lt;span class=&#34;{feat}_w&#34;&gt;
                        &#34;&#34;&#34;
                    )
                )
                if occurs:
                    html.append(
                        dedent(
                            f&#34;&#34;&#34;
                            &lt;button type=&#34;submit&#34;
                                name=&#34;{feat}_xbutton&#34;
                                value=&#34;{val}&#34;
                                class=&#34;{feat}_min&#34;
                            &gt;
                                -
                            &lt;/button&gt;
                            &#34;&#34;&#34;
                        )
                    )
                html.append(
                    dedent(
                        f&#34;&#34;&#34;
                        &lt;span
                            class=&#34;{feat}_sel {occurCls}&#34;
                        &gt;
                            {val}
                        &lt;/span&gt;
                        &#34;&#34;&#34;
                    )
                )
                html.append(
                    dedent(
                        f&#34;&#34;&#34;
                        &lt;button type=&#34;submit&#34;
                            name=&#34;{feat}_pbutton&#34;
                            value=&#34;{val}&#34;
                            class=&#34;{feat}_plus&#34;
                        &gt;
                            +
                        &lt;/button&gt;
                        &#34;&#34;&#34;
                    )
                )

                html.append(
                    dedent(
                        &#34;&#34;&#34;
                        &lt;/span&gt;
                        &#34;&#34;&#34;
                    )
                )

            html.append(
                dedent(
                    &#34;&#34;&#34;
                    &lt;input type=&#34;text&#34; id=&#34;{feat}_v&#34; name=&#34;{feat}_v&#34; value=&#34;&#34;&gt;
                    &lt;button type=&#34;submit&#34;
                        id=&#34;{feat}_save&#34;
                        name=&#34;{feat}_save&#34;
                        value=&#34;v&#34;
                        class=&#34;{feat}_plus&#34;
                    &gt;
                        +
                    &lt;/button&gt;
                    &#34;&#34;&#34;
                )
            )

        html.append(
            dedent(
                &#34;&#34;&#34;
                &lt;/p&gt;
                &#34;&#34;&#34;
            )
        )

    # REPORT SECTION

    if report is not None:
        for line in report:
            html.append(
                dedent(
                    f&#34;&#34;&#34;
                    &lt;p&gt;&lt;span class=&#34;report&#34;&gt;{line}&lt;/span&gt;&lt;/p&gt;
                    &#34;&#34;&#34;
                )
            )

    templateData[&#34;q&#34;] = &#34;\n&#34;.join(html)


def entityMatch(entityIndex, L, F, T, s, sFindPatternRe, words, valSelect):
    &#34;&#34;&#34;Checks whether a sentence matches a sequence of words.

    When we do the checking, we ignore empty words in the sentence.

    Parameters
    ----------
    entityIndex: dict
        Dictionary from tuples of slots to sets of kinds, being the kinds that
        entities occupying those slot tuples have
    L, F, T: object
        The TF APIs `F` and `L` for feature lookup and level-switching, and text
        extraction
    s: integer
        The node of the sentence in question
    words: list of string
        The sequence of words that must be matched. They are all non-empty and stripped
        from white space.
    valSelect: string
        The entity kind that the matched words should have
    &#34;&#34;&#34;
    nWords = len(words)

    positions = set()

    fits = None

    if sFindPatternRe:
        fits = False
        sText = T.text(s)

        for match in sFindPatternRe.finditer(sText):
            positions |= set(range(match.start(), match.end()))
            fits = True

    sTokensAll = [(t, F.str.v(t)) or &#34;&#34; for t in L.d(s, otype=&#34;t&#34;)]
    sTokens = [x for x in sTokensAll if x[1].strip()]

    matches = []

    if nWords:
        sWords = {w for (t, w) in sTokens}

        if any(w not in sWords for w in words):
            return (fits, {}, None)

        nSTokens = len(sTokens)
        fValStats = {feat: collections.Counter() for feat in FEATURES[1:]}

        for (i, (t, w)) in enumerate(sTokens):
            if w != words[0]:
                continue
            if i + nWords - 1 &gt;= nSTokens:
                return (
                    (fits, fValStats, None)
                    if len(matches) == 0
                    else (fits, fValStats, (sTokensAll, matches, positions))
                )

            match = True

            for (j, w) in enumerate(words[1:]):
                if sTokens[i + j + 1][1] != w:
                    match = False
                    break

            if match:
                lastT = sTokens[i + nWords - 1][0]
                slots = tuple(range(t, lastT + 1))

                valOK = True

                for feat in FEATURES[1:]:
                    theseVals = entityIndex[feat].get(slots, set())
                    theseStats = fValStats[feat]
                    theseValSelect = valSelect[feat]

                    for val in theseVals:
                        theseStats[val] += 1

                    if len(theseVals) == 0:
                        theseStats[&#34;‚åÄ&#34;] += 1
                    if (
                        &#34;‚åÄ&#34; in theseValSelect
                        and len(theseVals) == 0
                        or len(theseValSelect &amp; theseVals) != 0
                    ):
                        continue

                    valOK = False

                if valOK:
                    matches.append(slots)

        if len(matches) == 0:
            return (fits, fValStats, None)
    else:
        eKinds = {}

    return (fits, eKinds, (sTokensAll, matches, positions))


def filterS(web, sFindPatternRe, tokenStart, tokenEnd, valSelect):
    &#34;&#34;&#34;Filter the sentences.

    Will filter the sentences by tokens if the `tokenStart` and `tokenEnd` parameters
    are both filled in.
    In that case, we look up the text between those tokens and including.
    All sentences that contain that text of those slots will show up,
    all other sentences will be left out.
    However, if `valSelect` is non-empty, then there is a further filter: only if the
    text corresponds to an entity with that kind, the sentence is passed through.
    The matching slots will be highlighted.

    Parameters
    ----------
    web: object
        The web app object

    sFindPattern: string
        A search string that filters the sentences, before applying the search
        for a word sequence.

    tokenStart, tokenEnd: int or None
        Specify the start slot number and the end slot number of a sequence of tokens.
        Only sentences that contain this token sentence will be passed through,
        all other sentences will be filtered out.

    valSelect: set
        The entity kinds to filter on.

    Returns
    -------
    list of tuples
        For each sentence that passes the filter, a tuple with the following
        members is added to the list:

        *   tokens: the tokens of the sentence
        *   matches: the match positions of the found text
        *   positions: the token positions where a targeted token sequence starts
    &#34;&#34;&#34;

    setData = web.toolData.ner.sets[web.annoSet]

    kernelApi = web.kernelApi
    app = kernelApi.app
    api = app.api
    L = api.L
    F = api.F
    T = api.T

    results = []
    words = []

    hasEntity = tokenStart and tokenEnd

    if hasEntity:
        for t in range(tokenStart, tokenEnd + 1):
            word = (F.str.v(t) or &#34;&#34;).strip()
            if word:
                words.append(word)

    nFind = 0
    nEnt = {feat: collections.Counter() for feat in FEATURES[1:]}
    nVisible = {feat: collections.Counter() for feat in FEATURES[1:]}

    entityIndex = setData.entityIndex

    for s in setData.sentences:
        (fits, fValStats, result) = entityMatch(
            entityIndex, L, F, T, s, sFindPatternRe, words, valSelect
        )
        blocked = fits is not None and not fits

        if not blocked:
            nFind += 1

        for feat in FEATURES[1:]:
            theseStats = fValStats[feat]
            if len(theseStats):
                theseNEnt = nEnt[feat]
                theseNVisible = nVisible[feat]

                for (ek, n) in theseStats.items():
                    theseNEnt[ek] += n
                    if not blocked:
                        theseNVisible[ek] += n

        if result is None:
            continue

        if fits is not None and not fits:
            continue

        results.append((s, *result))

    return (results, nFind, nVisible, nEnt)


def saveEntity(web, fVals, sentences, excludedTokens):
    setData = web.toolData.ner.sets[web.annoSet]

    oldEntities = setData.entities
    oldEntitySet = oldEntities.values()
    newEntities = []
    excl = 0

    for (s, sTokens, allMatches, positions) in sentences:
        for matches in allMatches:
            data = (fVals, matches)
            if data not in oldEntitySet:
                if matches[-1] in excludedTokens:
                    excl += 1
                    continue
                newEntities.append(data)

    if len(newEntities):
        mergeEntities(web, newEntities)

    nEntities = len(newEntities)
    pl = &#34;y&#34; if nEntities == 1 else &#34;ies&#34;
    valRep = &#34;, &#34;.join(f&#34;{feat}={val}&#34; for (feat, val) in zip(FEATURES[1:], fVals))

    return f&#34;Added {nEntities} entit{pl} with {valRep}; &#34; f&#34;{excl} excluded&#34;


def delEntity(web, fVals, sentences, excludedTokens):
    setData = web.toolData.ner.sets[web.annoSet]

    oldEntities = setData.entities
    oldEntitySet = [x for x in oldEntities.values() if x[0] == fVals]
    delEntities = set()
    excl = 0

    for (s, sTokens, allMatches, positions) in sentences:
        for matches in allMatches:
            data = (fVals, matches)
            if data in oldEntitySet:
                if matches[-1] in excludedTokens:
                    excl += 1
                    continue
                delEntities.add(data)

    if len(delEntities):
        weedEntities(web, delEntities)

    nEntities = len(delEntities)
    pl = &#34;y&#34; if nEntities == 1 else &#34;ies&#34;
    valRep = &#34;, &#34;.join(f&#34;{feat}={val}&#34; for (feat, val) in zip(FEATURES[1:], fVals))

    return f&#34;Deleted {nEntities} entit{pl} with {valRep}; {excl} excluded&#39;&#34;


def composeFindStat(nSent, nFind, hasFind):
    n = f&#34;{nFind} of {nSent}&#34; if hasFind else nSent
    return f&#34;&#34;&#34;&lt;span class=&#34;stat&#34;&gt;{n}&lt;/span&gt;&#34;&#34;&#34;


def composeEntityStat(val, thisNVisible, thisNEnt, hasPattern, hasQuery):
    if hasQuery:
        na = thisNEnt[val]
        n = f&#34;{thisNVisible[val]} of {na}&#34; if hasPattern else f&#34;{na}&#34;
        entityStat = f&#34;&#34;&#34;&lt;span class=&#34;stat&#34;&gt;{n}&lt;/span&gt;&#34;&#34;&#34;
    else:
        entityStat = &#34;&#34;

    return entityStat


def composeS(web, sentences, limited, excludedTokens):
    &#34;&#34;&#34;Compose a table of sentences.

    In that case, we look up the text between those tokens and including.
    All sentences that contain that text of those slots will show up,
    all other sentences will be left out.
    The matching slots will be highlighted.

    Parameters
    ----------
    web: object
        The web app object

    Returns
    -------
    html string
        The finished HTML of the table, ready to put into the Flask template.
    &#34;&#34;&#34;

    annoSet = web.annoSet
    setData = web.toolData.ner.sets[annoSet]

    kernelApi = web.kernelApi
    app = kernelApi.app
    api = app.api
    F = api.F

    entityBy = setData.entityBy
    entitySlotIndex = setData.entitySlotIndex

    html = []
    html.append(
        dedent(
            f&#34;&#34;&#34;
            &lt;input type=&#34;hidden&#34;
                name=&#34;excludedtokens&#34;
                id=&#34;excludedtokens&#34;
                value=&#34;{&#34;,&#34;.join(str(t) for t in excludedTokens)}&#34;
            &gt;
            &#34;&#34;&#34;
        )
    )

    i = 0

    for (s, sTokens, matches, positions) in sentences:
        ht = []
        ht.append(f&#34;&#34;&#34;&lt;span class=&#34;sh&#34;&gt;{app.sectionStrFromNode(s)}&lt;/span&gt; &#34;&#34;&#34;)

        charPos = 0
        if annoSet:
            allMatches = set()
            endMatches = set()
            for match in matches:
                allMatches |= set(match)
                endMatches.add(match[-1])

        else:
            allMatches = set(chain.from_iterable(matches))

        for (t, w) in sTokens:
            after = F.after.v(t) or &#34;&#34;
            lenW = len(w)
            lenWa = len(w) + len(after)
            found = any(charPos + i in positions for i in range(lenW))
            queried = t in allMatches
            endQueried = annoSet and t in endMatches
            hlClasses = (&#34; found &#34; if found else &#34;&#34;) + (&#34; queried &#34; if queried else &#34;&#34;)
            excl = &#34;x&#34; if t in excludedTokens else &#34;v&#34;
            checkbox = f&#34;&#34;&#34;&lt;span te=&#34;{t}&#34; st=&#34;{excl}&#34;&gt;&lt;/span&gt;&#34;&#34;&#34; if endQueried else &#34;&#34;
            info = entitySlotIndex.get(t, None)
            inEntity = False

            if info is not None:
                inEntity = True
                for item in sorted(
                    (x for x in info if x is not None), key=lambda z: z[1]
                ):
                    (status, lg, ident) = item
                    freq = len(entityBy[ident])
                    eInfo = repIdent(ident)

                    if status:
                        lgRep = f&#34;&#34;&#34;&lt;span class=&#34;lgb&#34;&gt;{abs(lg)}&lt;/span&gt;&#34;&#34;&#34;
                        ht.append(
                            dedent(
                                f&#34;&#34;&#34;
                                &lt;span class=&#34;es&#34;
                                &gt;{lgRep}{eInfo} &lt;span class=&#34;n&#34;&gt;{freq}&lt;/span
                                &gt;&lt;/span&gt;&#34;&#34;&#34;
                            )
                        )

            hlClasses += &#34; ei &#34; if inEntity else &#34;&#34;
            hlClass = f&#34;&#34;&#34; class=&#34;{hlClasses}&#34; &#34;&#34;&#34; if hlClasses else &#34;&#34;
            ht.append(f&#34;&#34;&#34;&lt;span {hlClass} t=&#34;{t}&#34;&gt;{w}&lt;/span&gt;{checkbox}{after}&#34;&#34;&#34;)

            if info is not None:
                for item in sorted(
                    (x for x in info if x is not None), key=lambda z: z[1]
                ):
                    (status, lg, ident) = item
                    if not status:
                        lgRep = f&#34;&#34;&#34;&lt;span class=&#34;lge&#34;&gt;{abs(lg)}&lt;/span&gt;&#34;&#34;&#34;
                        ht.append(dedent(f&#34;&#34;&#34;&lt;span class=&#34;ee&#34;&gt;{lgRep}&lt;/span&gt;&#34;&#34;&#34;))

            charPos += lenWa

        ht = &#34;&#34;.join(ht)
        html.append(f&#34;&#34;&#34;&lt;div class=&#34;s&#34;&gt;{ht}&lt;/div&gt;&#34;&#34;&#34;)

        i += 1

        if limited and i &gt; 100:
            html.append(
                dedent(
                    f&#34;&#34;&#34;
                    &lt;div class=&#34;report&#34;&gt;
                        Showing only the first 100 sentences
                        of all {len(sentences)} ones.
                    &lt;/div&gt;
                    &#34;&#34;&#34;
                )
            )
            break

    return &#34;&#34;.join(html)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.browser.ner.tables.composeE"><code class="name flex">
<span>def <span class="ident">composeE</span></span>(<span>web, activeEntity, activeKind, sortKey, sortDir)</span>
</code></dt>
<dd>
<div class="desc"><p>Compose a table of entities with selection and sort controls.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>web</code></strong> :&ensp;<code>object</code></dt>
<dd>The web app object</dd>
<dt><strong><code>sortKey</code></strong> :&ensp;<code>string</code></dt>
<dd>
<p>Indicates how to sort the table:</p>
<ul>
<li><code>freqsort</code>: by the frequency of the entities</li>
<li><code>textsort</code>: by the text of the entities</li>
<li><code>idsort</code>: by the kind of the entities</li>
<li><code>kindsort</code>: by the kind of the entities</li>
</ul>
</dd>
<dt><strong><code>sortDir</code></strong> :&ensp;<code>string</code></dt>
<dd>
<p>Indicates the direction of the sort:</p>
<ul>
<li><code>u</code>: up, i.e. ascending</li>
<li><code>d</code>: down, i.e. descending</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>html string</code></dt>
<dd>The finished HTML of the table, ready to put into the Flask template.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/tables.py#L18-L83" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def composeE(web, activeEntity, activeKind, sortKey, sortDir):
    &#34;&#34;&#34;Compose a table of entities with selection and sort controls.

    Parameters
    ----------
    web: object
        The web app object
    sortKey: string
        Indicates how to sort the table:

        *   `freqsort`: by the frequency of the entities
        *   `textsort`: by the text of the entities
        *   `idsort`: by the kind of the entities
        *   `kindsort`: by the kind of the entities

    sortDir: string
        Indicates the direction of the sort:

        *   `u`: up, i.e. ascending
        *   `d`: down, i.e. descending

    Returns
    -------
    html string
        The finished HTML of the table, ready to put into the Flask template.
    &#34;&#34;&#34;

    setData = web.toolData.ner.sets[web.annoSet]

    html = []

    entities = setData.entities
    entries = setData.entityBy.items()

    if sortKey == &#34;sort&#34;:
        entries = sorted(entries, key=lambda x: (len(x[1]), x[0]))
    else:
        index = int(sortKey[4:])
        entries = sorted(entries, key=lambda x: (x[0][index], -len(x[1])))

    if sortDir == &#34;d&#34;:
        entries = reversed(entries)

    for (i, (vals, es)) in enumerate(entries):
        x = len(es)
        e1 = es[0]
        ent1 = entities[e1]
        (eFirst, eLast) = (ent1[2], ent1[-1])

        active = &#34; queried &#34; if activeEntity is not None and i == activeEntity else &#34;&#34;

        item = dedent(
            f&#34;&#34;&#34;
            &lt;p
                class=&#34;e {active}&#34;
                enm=&#34;{i}&#34;
                tstart=&#34;{eFirst}&#34; tend=&#34;{eLast}&#34;
            &gt;
                &lt;code class=&#34;w&#34;&gt;{x:&gt;5}&lt;/code&gt;
                x
                {repIdent(vals)}&gt;
            &lt;/p&gt;&#34;&#34;&#34;
        )
        html.append(item)

    return &#34;\n&#34;.join(html)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.tables.composeEntityStat"><code class="name flex">
<span>def <span class="ident">composeEntityStat</span></span>(<span>val, thisNVisible, thisNEnt, hasPattern, hasQuery)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/tables.py#L673-L681" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def composeEntityStat(val, thisNVisible, thisNEnt, hasPattern, hasQuery):
    if hasQuery:
        na = thisNEnt[val]
        n = f&#34;{thisNVisible[val]} of {na}&#34; if hasPattern else f&#34;{na}&#34;
        entityStat = f&#34;&#34;&#34;&lt;span class=&#34;stat&#34;&gt;{n}&lt;/span&gt;&#34;&#34;&#34;
    else:
        entityStat = &#34;&#34;

    return entityStat</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.tables.composeFindStat"><code class="name flex">
<span>def <span class="ident">composeFindStat</span></span>(<span>nSent, nFind, hasFind)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/tables.py#L668-L670" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def composeFindStat(nSent, nFind, hasFind):
    n = f&#34;{nFind} of {nSent}&#34; if hasFind else nSent
    return f&#34;&#34;&#34;&lt;span class=&#34;stat&#34;&gt;{n}&lt;/span&gt;&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.tables.composeQ"><code class="name flex">
<span>def <span class="ident">composeQ</span></span>(<span>web, templateData, sFind, sFindRe, sFindError, valSelect, nFind, nEnt, nVisible, scope, report)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for the query line.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>web</code></strong> :&ensp;<code>object</code></dt>
<dd>The web app object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>html string</code></dt>
<dd>The finished HTML of the query parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/tables.py#L86-L412" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def composeQ(
    web,
    templateData,
    sFind,
    sFindRe,
    sFindError,
    valSelect,
    nFind,
    nEnt,
    nVisible,
    scope,
    report,
):
    &#34;&#34;&#34;HTML for the query line.

    Parameters
    ----------
    web: object
        The web app object

    Returns
    -------
    html string
        The finished HTML of the query parameters
    &#34;&#34;&#34;

    kernelApi = web.kernelApi
    app = kernelApi.app
    api = app.api
    F = api.F
    T = api.T

    annoSet = web.annoSet
    setData = web.toolData.ner.sets[annoSet]
    nSent = len(setData.sentences)

    tokenStart = templateData[&#34;tokenstart&#34;]
    tokenEnd = templateData[&#34;tokenend&#34;]

    hasFind = sFindRe is not None
    hasEntity = tokenStart and tokenEnd

    html = []

    # FILTER SECTION

    findStat = composeFindStat(nSent, nFind, hasFind)

    html.append(
        dedent(
            f&#34;&#34;&#34;
            &lt;p&gt;
                &lt;b&gt;Filter:&lt;/b&gt;
                &lt;input type=&#34;text&#34; name=&#34;sfind&#34; id=&#34;sfind&#34; value=&#34;{sFind}&#34;&gt;
                {findStat}
                &lt;button type=&#34;submit&#34; id=&#34;findclear&#34;&gt;‚úñÔ∏è&lt;/button&gt;
                &lt;span id=&#34;sfinderror&#34; class=&#34;error&#34;&gt;{sFindError}&lt;/span&gt;
                &lt;button type=&#34;submit&#34; id=&#34;lookupf&#34;&gt;üîé&lt;/button&gt;
            &lt;/p&gt;
            &#34;&#34;&#34;
        )
    )

    # ENTITY SECTION
    # The entity text

    words = (
        [
            f&#34;&#34;&#34;{F.str.v(t) or &#34;&#34;}{F.after.v(t) or &#34;&#34;}&#34;&#34;&#34;.strip()
            for t in range(tokenStart, tokenEnd + 1)
        ]
        if hasEntity
        else []
    )

    wordHtml = &#34; &#34;.join(f&#34;&#34;&#34;&lt;span&gt;{w}&lt;/span&gt;&#34;&#34;&#34; for w in words if w)

    html.append(
        dedent(
            f&#34;&#34;&#34;
            &lt;p&gt;
                &lt;b&gt;Entity:&lt;/b&gt;
                &lt;input type=&#34;hidden&#34;
                    name=&#34;tokenstart&#34;
                    id=&#34;tokenstart&#34;
                    value=&#34;{tokenStart or &#34;&#34;}&#34;
                &gt;
                &lt;input type=&#34;hidden&#34;
                    name=&#34;tokenend&#34;
                    id=&#34;tokenend&#34;
                    value=&#34;{tokenEnd or &#34;&#34;}&#34;
                &gt;
                &lt;span id=&#34;qwordshow&#34;&gt;{wordHtml}&lt;/span&gt;
                &lt;button type=&#34;submit&#34; id=&#34;queryclear&#34;&gt;‚úñÔ∏è&lt;/button&gt;
                &lt;button type=&#34;submit&#34; id=&#34;lookupq&#34;&gt;üîé&lt;/button&gt;
            &#34;&#34;&#34;
        )
    )

    # ENTITY SECTION
    # The entity features

    txt = (
        WHITE_RE.sub(&#34; &#34;, T.text(range(tokenStart, tokenEnd + 1)).strip())
        if hasEntity
        else &#34;&#34;
    )
    features = setData.entityTextVal[txt]

    for feat in FEATURES[1:]:
        theseVals = features.get(feat, set())
        thisValSelect = valSelect[feat]

        html.append(
            dedent(
                f&#34;&#34;&#34;
                &lt;input type=&#34;hidden&#34;
                    name=&#34;{feat}select&#34;
                    id=&#34;{feat}select&#34;
                    value=&#34;{&#34;,&#34;.join(thisValSelect)}&#34;
                &gt;
                &#34;&#34;&#34;
            )
        )
        for val in [&#34;‚åÄ&#34;] + sorted(theseVals):
            status = &#34;v&#34; if val in thisValSelect else &#34;x&#34;
            entityStat = composeEntityStat(
                val, nVisible[feat], nEnt[feat], hasFind, hasEntity
            )
            title = f&#34;{feat} not marked&#34; if val == &#34;‚åÄ&#34; else f&#34;{feat} marked as {val}&#34;

            html.append(
                dedent(
                    f&#34;&#34;&#34;
                    &lt;button type=&#34;button&#34;
                        name=&#34;{val}&#34;
                        class=&#34;{feat}sel&#34;
                        st=&#34;{status}&#34;
                        title=&#34;{title}&#34;
                    &gt;
                        {val}
                        {entityStat}
                    &lt;/button&gt;
                    &#34;&#34;&#34;
                )
            )

        html.append(
            dedent(
                &#34;&#34;&#34;
                &lt;/p&gt;
                &#34;&#34;&#34;
            )
        )

    # MODIFY SECTION

    html.append(
        dedent(
            f&#34;&#34;&#34;
            &lt;input type=&#34;hidden&#34;
                id=&#34;scope&#34;
                name=&#34;scope&#34;
                value=&#34;{scope}&#34;
            &gt;
            &#34;&#34;&#34;
        )
    )

    if annoSet and hasEntity:
        html.append(
            dedent(
                &#34;&#34;&#34;
                &lt;p&gt;&lt;b&gt;Target:&lt;/b&gt;
                &#34;&#34;&#34;
            )
        )
        # Scope of modification

        if hasFind:
            html.append(
                dedent(
                    &#34;&#34;&#34;
                    &lt;button type=&#34;button&#34;
                        id=&#34;scopefiltered&#34;
                        title=&#34;act on filtered sentences only&#34;
                    &gt;filtered
                    &lt;/button&gt;
                    &lt;button type=&#34;button&#34;
                        id=&#34;scopeall&#34;
                        title=&#34;act on all sentences&#34;
                    &gt;all
                    &lt;/button&gt;
                    &#34;&#34;&#34;
                )
            )
        html.append(
            dedent(
                &#34;&#34;&#34;
                &lt;button type=&#34;button&#34;
                    id=&#34;selectall&#34;
                    title=&#34;select all occurences in filtered sentences&#34;
                &gt;üÜó&lt;/button&gt;
                &lt;button type=&#34;button&#34;
                    id=&#34;selectnone&#34;
                    title=&#34;deselect all occurences in filtered sentences&#34;
                &gt;‚≠ïÔ∏è&lt;/button&gt;
                &#34;&#34;&#34;
            )
        )
        html.append(
            dedent(
                &#34;&#34;&#34;
                &lt;/p&gt;
                &#34;&#34;&#34;
            )
        )
        html.append(
            dedent(
                &#34;&#34;&#34;
                &lt;p&gt;&lt;b&gt;Assignment:&lt;/b&gt;
                &#34;&#34;&#34;
            )
        )

        for feat in FEATURES[1:]:
            theseVals = sorted(setData.entityTextVal[feat].get(txt, set()))
            allVals = (
                sorted(x[0] for x in setData.entityFreq[feat])
                if feat in KEYWORD_FEATURES
                else theseVals
            )
            for kind in allVals:
                occurs = kind in theseVals
                occurCls = &#34; occurs &#34; if occurs else &#34;&#34;

                html.append(
                    dedent(
                        f&#34;&#34;&#34;
                        &lt;span class=&#34;{feat}_w&#34;&gt;
                        &#34;&#34;&#34;
                    )
                )
                if occurs:
                    html.append(
                        dedent(
                            f&#34;&#34;&#34;
                            &lt;button type=&#34;submit&#34;
                                name=&#34;{feat}_xbutton&#34;
                                value=&#34;{val}&#34;
                                class=&#34;{feat}_min&#34;
                            &gt;
                                -
                            &lt;/button&gt;
                            &#34;&#34;&#34;
                        )
                    )
                html.append(
                    dedent(
                        f&#34;&#34;&#34;
                        &lt;span
                            class=&#34;{feat}_sel {occurCls}&#34;
                        &gt;
                            {val}
                        &lt;/span&gt;
                        &#34;&#34;&#34;
                    )
                )
                html.append(
                    dedent(
                        f&#34;&#34;&#34;
                        &lt;button type=&#34;submit&#34;
                            name=&#34;{feat}_pbutton&#34;
                            value=&#34;{val}&#34;
                            class=&#34;{feat}_plus&#34;
                        &gt;
                            +
                        &lt;/button&gt;
                        &#34;&#34;&#34;
                    )
                )

                html.append(
                    dedent(
                        &#34;&#34;&#34;
                        &lt;/span&gt;
                        &#34;&#34;&#34;
                    )
                )

            html.append(
                dedent(
                    &#34;&#34;&#34;
                    &lt;input type=&#34;text&#34; id=&#34;{feat}_v&#34; name=&#34;{feat}_v&#34; value=&#34;&#34;&gt;
                    &lt;button type=&#34;submit&#34;
                        id=&#34;{feat}_save&#34;
                        name=&#34;{feat}_save&#34;
                        value=&#34;v&#34;
                        class=&#34;{feat}_plus&#34;
                    &gt;
                        +
                    &lt;/button&gt;
                    &#34;&#34;&#34;
                )
            )

        html.append(
            dedent(
                &#34;&#34;&#34;
                &lt;/p&gt;
                &#34;&#34;&#34;
            )
        )

    # REPORT SECTION

    if report is not None:
        for line in report:
            html.append(
                dedent(
                    f&#34;&#34;&#34;
                    &lt;p&gt;&lt;span class=&#34;report&#34;&gt;{line}&lt;/span&gt;&lt;/p&gt;
                    &#34;&#34;&#34;
                )
            )

    templateData[&#34;q&#34;] = &#34;\n&#34;.join(html)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.tables.composeS"><code class="name flex">
<span>def <span class="ident">composeS</span></span>(<span>web, sentences, limited, excludedTokens)</span>
</code></dt>
<dd>
<div class="desc"><p>Compose a table of sentences.</p>
<p>In that case, we look up the text between those tokens and including.
All sentences that contain that text of those slots will show up,
all other sentences will be left out.
The matching slots will be highlighted.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>web</code></strong> :&ensp;<code>object</code></dt>
<dd>The web app object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>html string</code></dt>
<dd>The finished HTML of the table, ready to put into the Flask template.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/tables.py#L684-L810" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def composeS(web, sentences, limited, excludedTokens):
    &#34;&#34;&#34;Compose a table of sentences.

    In that case, we look up the text between those tokens and including.
    All sentences that contain that text of those slots will show up,
    all other sentences will be left out.
    The matching slots will be highlighted.

    Parameters
    ----------
    web: object
        The web app object

    Returns
    -------
    html string
        The finished HTML of the table, ready to put into the Flask template.
    &#34;&#34;&#34;

    annoSet = web.annoSet
    setData = web.toolData.ner.sets[annoSet]

    kernelApi = web.kernelApi
    app = kernelApi.app
    api = app.api
    F = api.F

    entityBy = setData.entityBy
    entitySlotIndex = setData.entitySlotIndex

    html = []
    html.append(
        dedent(
            f&#34;&#34;&#34;
            &lt;input type=&#34;hidden&#34;
                name=&#34;excludedtokens&#34;
                id=&#34;excludedtokens&#34;
                value=&#34;{&#34;,&#34;.join(str(t) for t in excludedTokens)}&#34;
            &gt;
            &#34;&#34;&#34;
        )
    )

    i = 0

    for (s, sTokens, matches, positions) in sentences:
        ht = []
        ht.append(f&#34;&#34;&#34;&lt;span class=&#34;sh&#34;&gt;{app.sectionStrFromNode(s)}&lt;/span&gt; &#34;&#34;&#34;)

        charPos = 0
        if annoSet:
            allMatches = set()
            endMatches = set()
            for match in matches:
                allMatches |= set(match)
                endMatches.add(match[-1])

        else:
            allMatches = set(chain.from_iterable(matches))

        for (t, w) in sTokens:
            after = F.after.v(t) or &#34;&#34;
            lenW = len(w)
            lenWa = len(w) + len(after)
            found = any(charPos + i in positions for i in range(lenW))
            queried = t in allMatches
            endQueried = annoSet and t in endMatches
            hlClasses = (&#34; found &#34; if found else &#34;&#34;) + (&#34; queried &#34; if queried else &#34;&#34;)
            excl = &#34;x&#34; if t in excludedTokens else &#34;v&#34;
            checkbox = f&#34;&#34;&#34;&lt;span te=&#34;{t}&#34; st=&#34;{excl}&#34;&gt;&lt;/span&gt;&#34;&#34;&#34; if endQueried else &#34;&#34;
            info = entitySlotIndex.get(t, None)
            inEntity = False

            if info is not None:
                inEntity = True
                for item in sorted(
                    (x for x in info if x is not None), key=lambda z: z[1]
                ):
                    (status, lg, ident) = item
                    freq = len(entityBy[ident])
                    eInfo = repIdent(ident)

                    if status:
                        lgRep = f&#34;&#34;&#34;&lt;span class=&#34;lgb&#34;&gt;{abs(lg)}&lt;/span&gt;&#34;&#34;&#34;
                        ht.append(
                            dedent(
                                f&#34;&#34;&#34;
                                &lt;span class=&#34;es&#34;
                                &gt;{lgRep}{eInfo} &lt;span class=&#34;n&#34;&gt;{freq}&lt;/span
                                &gt;&lt;/span&gt;&#34;&#34;&#34;
                            )
                        )

            hlClasses += &#34; ei &#34; if inEntity else &#34;&#34;
            hlClass = f&#34;&#34;&#34; class=&#34;{hlClasses}&#34; &#34;&#34;&#34; if hlClasses else &#34;&#34;
            ht.append(f&#34;&#34;&#34;&lt;span {hlClass} t=&#34;{t}&#34;&gt;{w}&lt;/span&gt;{checkbox}{after}&#34;&#34;&#34;)

            if info is not None:
                for item in sorted(
                    (x for x in info if x is not None), key=lambda z: z[1]
                ):
                    (status, lg, ident) = item
                    if not status:
                        lgRep = f&#34;&#34;&#34;&lt;span class=&#34;lge&#34;&gt;{abs(lg)}&lt;/span&gt;&#34;&#34;&#34;
                        ht.append(dedent(f&#34;&#34;&#34;&lt;span class=&#34;ee&#34;&gt;{lgRep}&lt;/span&gt;&#34;&#34;&#34;))

            charPos += lenWa

        ht = &#34;&#34;.join(ht)
        html.append(f&#34;&#34;&#34;&lt;div class=&#34;s&#34;&gt;{ht}&lt;/div&gt;&#34;&#34;&#34;)

        i += 1

        if limited and i &gt; 100:
            html.append(
                dedent(
                    f&#34;&#34;&#34;
                    &lt;div class=&#34;report&#34;&gt;
                        Showing only the first 100 sentences
                        of all {len(sentences)} ones.
                    &lt;/div&gt;
                    &#34;&#34;&#34;
                )
            )
            break

    return &#34;&#34;.join(html)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.tables.delEntity"><code class="name flex">
<span>def <span class="ident">delEntity</span></span>(<span>web, fVals, sentences, excludedTokens)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/tables.py#L641-L665" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delEntity(web, fVals, sentences, excludedTokens):
    setData = web.toolData.ner.sets[web.annoSet]

    oldEntities = setData.entities
    oldEntitySet = [x for x in oldEntities.values() if x[0] == fVals]
    delEntities = set()
    excl = 0

    for (s, sTokens, allMatches, positions) in sentences:
        for matches in allMatches:
            data = (fVals, matches)
            if data in oldEntitySet:
                if matches[-1] in excludedTokens:
                    excl += 1
                    continue
                delEntities.add(data)

    if len(delEntities):
        weedEntities(web, delEntities)

    nEntities = len(delEntities)
    pl = &#34;y&#34; if nEntities == 1 else &#34;ies&#34;
    valRep = &#34;, &#34;.join(f&#34;{feat}={val}&#34; for (feat, val) in zip(FEATURES[1:], fVals))

    return f&#34;Deleted {nEntities} entit{pl} with {valRep}; {excl} excluded&#39;&#34;</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.tables.entityMatch"><code class="name flex">
<span>def <span class="ident">entityMatch</span></span>(<span>entityIndex, L, F, T, s, sFindPatternRe, words, valSelect)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether a sentence matches a sequence of words.</p>
<p>When we do the checking, we ignore empty words in the sentence.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>entityIndex</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary from tuples of slots to sets of kinds, being the kinds that
entities occupying those slot tuples have</dd>
<dt><strong><code>L</code></strong>, <strong><code>F</code></strong>, <strong><code>T</code></strong> :&ensp;<code>object</code></dt>
<dd>The TF APIs <code>F</code> and <code>L</code> for feature lookup and level-switching, and text
extraction</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>integer</code></dt>
<dd>The node of the sentence in question</dd>
<dt><strong><code>words</code></strong> :&ensp;<code>list</code> of <code>string</code></dt>
<dd>The sequence of words that must be matched. They are all non-empty and stripped
from white space.</dd>
<dt><strong><code>valSelect</code></strong> :&ensp;<code>string</code></dt>
<dd>The entity kind that the matched words should have</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/tables.py#L415-L514" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def entityMatch(entityIndex, L, F, T, s, sFindPatternRe, words, valSelect):
    &#34;&#34;&#34;Checks whether a sentence matches a sequence of words.

    When we do the checking, we ignore empty words in the sentence.

    Parameters
    ----------
    entityIndex: dict
        Dictionary from tuples of slots to sets of kinds, being the kinds that
        entities occupying those slot tuples have
    L, F, T: object
        The TF APIs `F` and `L` for feature lookup and level-switching, and text
        extraction
    s: integer
        The node of the sentence in question
    words: list of string
        The sequence of words that must be matched. They are all non-empty and stripped
        from white space.
    valSelect: string
        The entity kind that the matched words should have
    &#34;&#34;&#34;
    nWords = len(words)

    positions = set()

    fits = None

    if sFindPatternRe:
        fits = False
        sText = T.text(s)

        for match in sFindPatternRe.finditer(sText):
            positions |= set(range(match.start(), match.end()))
            fits = True

    sTokensAll = [(t, F.str.v(t)) or &#34;&#34; for t in L.d(s, otype=&#34;t&#34;)]
    sTokens = [x for x in sTokensAll if x[1].strip()]

    matches = []

    if nWords:
        sWords = {w for (t, w) in sTokens}

        if any(w not in sWords for w in words):
            return (fits, {}, None)

        nSTokens = len(sTokens)
        fValStats = {feat: collections.Counter() for feat in FEATURES[1:]}

        for (i, (t, w)) in enumerate(sTokens):
            if w != words[0]:
                continue
            if i + nWords - 1 &gt;= nSTokens:
                return (
                    (fits, fValStats, None)
                    if len(matches) == 0
                    else (fits, fValStats, (sTokensAll, matches, positions))
                )

            match = True

            for (j, w) in enumerate(words[1:]):
                if sTokens[i + j + 1][1] != w:
                    match = False
                    break

            if match:
                lastT = sTokens[i + nWords - 1][0]
                slots = tuple(range(t, lastT + 1))

                valOK = True

                for feat in FEATURES[1:]:
                    theseVals = entityIndex[feat].get(slots, set())
                    theseStats = fValStats[feat]
                    theseValSelect = valSelect[feat]

                    for val in theseVals:
                        theseStats[val] += 1

                    if len(theseVals) == 0:
                        theseStats[&#34;‚åÄ&#34;] += 1
                    if (
                        &#34;‚åÄ&#34; in theseValSelect
                        and len(theseVals) == 0
                        or len(theseValSelect &amp; theseVals) != 0
                    ):
                        continue

                    valOK = False

                if valOK:
                    matches.append(slots)

        if len(matches) == 0:
            return (fits, fValStats, None)
    else:
        eKinds = {}

    return (fits, eKinds, (sTokensAll, matches, positions))</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.tables.filterS"><code class="name flex">
<span>def <span class="ident">filterS</span></span>(<span>web, sFindPatternRe, tokenStart, tokenEnd, valSelect)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter the sentences.</p>
<p>Will filter the sentences by tokens if the <code>tokenStart</code> and <code>tokenEnd</code> parameters
are both filled in.
In that case, we look up the text between those tokens and including.
All sentences that contain that text of those slots will show up,
all other sentences will be left out.
However, if <code>valSelect</code> is non-empty, then there is a further filter: only if the
text corresponds to an entity with that kind, the sentence is passed through.
The matching slots will be highlighted.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>web</code></strong> :&ensp;<code>object</code></dt>
<dd>The web app object</dd>
<dt><strong><code>sFindPattern</code></strong> :&ensp;<code>string</code></dt>
<dd>A search string that filters the sentences, before applying the search
for a word sequence.</dd>
<dt><strong><code>tokenStart</code></strong>, <strong><code>tokenEnd</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Specify the start slot number and the end slot number of a sequence of tokens.
Only sentences that contain this token sentence will be passed through,
all other sentences will be filtered out.</dd>
<dt><strong><code>valSelect</code></strong> :&ensp;<code>set</code></dt>
<dd>The entity kinds to filter on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>tuples</code></dt>
<dd>
<p>For each sentence that passes the filter, a tuple with the following
members is added to the list:</p>
<ul>
<li>tokens: the tokens of the sentence</li>
<li>matches: the match positions of the found text</li>
<li>positions: the token positions where a targeted token sequence starts</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/tables.py#L517-L611" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def filterS(web, sFindPatternRe, tokenStart, tokenEnd, valSelect):
    &#34;&#34;&#34;Filter the sentences.

    Will filter the sentences by tokens if the `tokenStart` and `tokenEnd` parameters
    are both filled in.
    In that case, we look up the text between those tokens and including.
    All sentences that contain that text of those slots will show up,
    all other sentences will be left out.
    However, if `valSelect` is non-empty, then there is a further filter: only if the
    text corresponds to an entity with that kind, the sentence is passed through.
    The matching slots will be highlighted.

    Parameters
    ----------
    web: object
        The web app object

    sFindPattern: string
        A search string that filters the sentences, before applying the search
        for a word sequence.

    tokenStart, tokenEnd: int or None
        Specify the start slot number and the end slot number of a sequence of tokens.
        Only sentences that contain this token sentence will be passed through,
        all other sentences will be filtered out.

    valSelect: set
        The entity kinds to filter on.

    Returns
    -------
    list of tuples
        For each sentence that passes the filter, a tuple with the following
        members is added to the list:

        *   tokens: the tokens of the sentence
        *   matches: the match positions of the found text
        *   positions: the token positions where a targeted token sequence starts
    &#34;&#34;&#34;

    setData = web.toolData.ner.sets[web.annoSet]

    kernelApi = web.kernelApi
    app = kernelApi.app
    api = app.api
    L = api.L
    F = api.F
    T = api.T

    results = []
    words = []

    hasEntity = tokenStart and tokenEnd

    if hasEntity:
        for t in range(tokenStart, tokenEnd + 1):
            word = (F.str.v(t) or &#34;&#34;).strip()
            if word:
                words.append(word)

    nFind = 0
    nEnt = {feat: collections.Counter() for feat in FEATURES[1:]}
    nVisible = {feat: collections.Counter() for feat in FEATURES[1:]}

    entityIndex = setData.entityIndex

    for s in setData.sentences:
        (fits, fValStats, result) = entityMatch(
            entityIndex, L, F, T, s, sFindPatternRe, words, valSelect
        )
        blocked = fits is not None and not fits

        if not blocked:
            nFind += 1

        for feat in FEATURES[1:]:
            theseStats = fValStats[feat]
            if len(theseStats):
                theseNEnt = nEnt[feat]
                theseNVisible = nVisible[feat]

                for (ek, n) in theseStats.items():
                    theseNEnt[ek] += n
                    if not blocked:
                        theseNVisible[ek] += n

        if result is None:
            continue

        if fits is not None and not fits:
            continue

        results.append((s, *result))

    return (results, nFind, nVisible, nEnt)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.tables.repIdent"><code class="name flex">
<span>def <span class="ident">repIdent</span></span>(<span>vals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/tables.py#L11-L15" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def repIdent(vals):
    return &#34; &#34;.join(
        f&#34;&#34;&#34;&lt;span class=&#34;{feat}&#34;&gt;{val}&lt;/span&gt;&#34;&#34;&#34;
        for (feat, val) in zip(FEATURES[1:], vals)
    )</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.tables.saveEntity"><code class="name flex">
<span>def <span class="ident">saveEntity</span></span>(<span>web, fVals, sentences, excludedTokens)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/b53beafcf8ce617a4d706304498dae56bbe4123d/tf/browser/ner/tables.py#L614-L638" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def saveEntity(web, fVals, sentences, excludedTokens):
    setData = web.toolData.ner.sets[web.annoSet]

    oldEntities = setData.entities
    oldEntitySet = oldEntities.values()
    newEntities = []
    excl = 0

    for (s, sTokens, allMatches, positions) in sentences:
        for matches in allMatches:
            data = (fVals, matches)
            if data not in oldEntitySet:
                if matches[-1] in excludedTokens:
                    excl += 1
                    continue
                newEntities.append(data)

    if len(newEntities):
        mergeEntities(web, newEntities)

    nEntities = len(newEntities)
    pl = &#34;y&#34; if nEntities == 1 else &#34;ies&#34;
    valRep = &#34;, &#34;.join(f&#34;{feat}={val}&#34; for (feat, val) in zip(FEATURES[1:], fVals))

    return f&#34;Added {nEntities} entit{pl} with {valRep}; &#34; f&#34;{excl} excluded&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="üîé Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.browser.ner" href="index.html">tf.browser.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tf.browser.ner.tables.composeE" href="#tf.browser.ner.tables.composeE">composeE</a></code></li>
<li><code><a title="tf.browser.ner.tables.composeEntityStat" href="#tf.browser.ner.tables.composeEntityStat">composeEntityStat</a></code></li>
<li><code><a title="tf.browser.ner.tables.composeFindStat" href="#tf.browser.ner.tables.composeFindStat">composeFindStat</a></code></li>
<li><code><a title="tf.browser.ner.tables.composeQ" href="#tf.browser.ner.tables.composeQ">composeQ</a></code></li>
<li><code><a title="tf.browser.ner.tables.composeS" href="#tf.browser.ner.tables.composeS">composeS</a></code></li>
<li><code><a title="tf.browser.ner.tables.delEntity" href="#tf.browser.ner.tables.delEntity">delEntity</a></code></li>
<li><code><a title="tf.browser.ner.tables.entityMatch" href="#tf.browser.ner.tables.entityMatch">entityMatch</a></code></li>
<li><code><a title="tf.browser.ner.tables.filterS" href="#tf.browser.ner.tables.filterS">filterS</a></code></li>
<li><code><a title="tf.browser.ner.tables.repIdent" href="#tf.browser.ner.tables.repIdent">repIdent</a></code></li>
<li><code><a title="tf.browser.ner.tables.saveEntity" href="#tf.browser.ner.tables.saveEntity">saveEntity</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>