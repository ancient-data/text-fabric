<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.browser.ner.serve API documentation</title>
<meta name="description" content="Main controller for Flask â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-GjqubOlYA6/wOZV7F31o2t4ogk4JGDGFa6XmL+BfAG0=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-qDPJ4nH38AgHyK3U6cvI6DBifA+7hPBo8mVoH6pyN9c=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.browser.ner.serve</code></h1>
</header>
<section id="section-intro">
<p>Main controller for Flask</p>
<p>This module contains the controllers that Flask invokes when serving
the annotation tool in the TF browser.</p>
<p>To see how this fits among all the modules of this package, see
<code><a title="tf.browser.ner.annotate" href="annotate.html">tf.browser.ner.annotate</a></code> .</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/serve.py#L1-L417" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Main controller for Flask

This module contains the controllers that Flask invokes when serving
the annotation tool in the TF browser.

To see how this fits among all the modules of this package, see
`tf.browser.ner.annotate` .
&#34;&#34;&#34;

from flask import render_template

from ...core.generic import AttrDict

from .settings import TOOLKEY, SC_ALL
from .helpers import makeCss
from .annotate import Annotate
from .servelib import initTemplate, findSetup, adaptValSelect
from .fragments import (
    wrapEntityHeaders,
    wrapQuery,
    wrapActive,
    wrapReport,
    wrapMessages,
    wrapAnnoSets,
)


class Serve:
    def __init__(self, web):
        &#34;&#34;&#34;Object that implements the controller functions for the annotatation tool.

        Parameters
        ----------
        web: object
            This represents the Flask website that is the TF browser.
            It has access to the TF-app that represents a loaded TF corpus.
            See `tf.browser.ner.web.factory` and `tf.browser.web.factory`.

            It picks up a handle to the loaded TF corpus, stores it in the `Serve`
            object, and uses it to fetch the CSS code for this tool, which is
            also stored in the `Serve` object.

            Finally, it creates a pointer to the annotation data in memory, as stored
            in the `web` object, if there is already such data from a previous request.
            If not, it initializes an empty dict in the `web` object, with the purpose
            of storing incoming annotation data there.

            This way, the annotation data is preserved between requests.
        &#34;&#34;&#34;
        self.web = web
        kernelApi = web.kernelApi
        self.app = kernelApi.app
        self.css = kernelApi.css()

        if not hasattr(web, &#34;toolData&#34;):
            setattr(web, &#34;toolData&#34;, AttrDict())
        toolData = web.toolData

        if TOOLKEY not in toolData:
            toolData[TOOLKEY] = AttrDict()

        self.data = toolData[TOOLKEY]

    def setupAnnotate(self):
        &#34;&#34;&#34;Initialize the Annotate object.

        Before doing anything else, we create a
        `tf.browser.ner.annotate.Annotate` object and store it for use
        by the actual controllers.

        Based on the information in the request, we switch to a particular annotation
        set and load its data.

        This method will be invoked via two routes:

        *   `Serve.setupFull()`: for the main page, after a normal request;
        *   `Serve.setupLean()`: in response to an Ajax call when context to a
            specific line in the corpus is needed.

        !!! note &#34;`templateData`&#34;
            We use the dict `templateData` as the collector of

            *   the request information;
            *   selections of corpus material;
            *   HTML fragments under construction;
            *   template variables.
        &#34;&#34;&#34;
        data = self.data
        app = self.app

        annotate = Annotate(app, data=data, browse=True)

        initTemplate(annotate, app)
        templateData = annotate.templateData

        annoSet = templateData.annoset

        annotate.setSet(annoSet)
        self.annotate = annotate
        annotate.loadData()

    def setupFull(self):
        &#34;&#34;&#34;Prepares to serve a complete page.

        *   Creates an `tf.browser.ner.annotate.Annotate` object;
        *   Sets up the find widget;
        *   Encodes the active entity in hidden `input` elements;
        *   Collects and generates the specific CSS styles needed for this corpus.
        &#34;&#34;&#34;
        css = self.css

        self.setupAnnotate()
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features
        keywordFeatures = settings.keywordFeatures

        templateData = self.templateData

        findSetup(templateData)
        wrapActive(templateData)
        templateData.css = makeCss(features, keywordFeatures, generic=css)

    def setupLean(self):
        &#34;&#34;&#34;Prepares to update a portion of the page.

        *   Creates an `tf.browser.ner.annotate.Annotate` object;
        *   Encodes the active entity in hidden `input` elements.
        &#34;&#34;&#34;
        self.setupAnnotate()
        templateData = self.templateData

        wrapActive(templateData)

    def actionsFull(self):
        &#34;&#34;&#34;Carries out requested actions before building the full page.

        *   annotation set management actions;
        *   fetch selected buckets from the whole corpus;
        *   modification actions in the selected set.
        &#34;&#34;&#34;
        templateData = self.templateData

        self.setHandling(templateData)

        self.getBuckets()
        self.updateHandling()

    def actionsLean(self, node):
        &#34;&#34;&#34;Carries out requested actions before building a portion of the page.

        *   fetch all buckets from a section of the corpus.
        &#34;&#34;&#34;
        self.getBuckets(node=node)

    def wrapFull(self):
        &#34;&#34;&#34;Builds the full page.

        This includes the controls by which the user makes selections and triggers
        axctions.
        &#34;&#34;&#34;
        annotate = self.annotate
        templateData = self.templateData
        sortKey = templateData.sortkey
        sortDir = templateData.sortdir
        activeEntity = templateData.activeentity
        tokenStart = templateData.tokenstart
        tokenEnd = templateData.tokenend
        excludedTokens = templateData.excludedtokens

        buckets = self.buckets

        wrapQuery(annotate, templateData)
        templateData.entitytable = annotate.showEntities(
            activeEntity=activeEntity, sortKey=sortKey, sortDir=sortDir
        )
        templateData.entityoverview = annotate.showEntityOverview()
        templateData.entityheaders = wrapEntityHeaders(annotate, sortKey, sortDir)
        templateData.buckets = annotate.showContent(
            buckets,
            activeEntity=activeEntity,
            excludedTokens=excludedTokens,
            mayLimit=not (tokenStart and tokenEnd),
        )

        return render_template(f&#34;{TOOLKEY}/index.html&#34;, **templateData)

    def wrapLean(self):
        &#34;&#34;&#34;Builds a portion of the page.

        No need to build user controls, because they are already on the page.

        Returns
        -------
        The generated HTML for the portion of the page.
        &#34;&#34;&#34;
        annotate = self.annotate
        templateData = self.templateData
        activeEntity = templateData.activeentity
        excludedTokens = templateData.excludedtokens
        buckets = self.buckets

        return annotate.showContent(
            buckets,
            activeEntity=activeEntity,
            excludedTokens=excludedTokens,
            mayLimit=False,
        )

    def getBuckets(self, noFind=False, node=None):
        &#34;&#34;&#34;Fetch a selection of buckets from the corpus.

        The selection is defined in the `templateData`.

        We further modify the selection by two additional parameters.

        The resulting list of buckets is obtained by
        `tf.browser.ner.annotate.Annotate.filterContent`, and each member in the bucket
        list is a tuple as indicated in the `filterContent` function.
        The list is stored in the `Serve` object.
        Additionally, statistics about these buckets and how many entity values
        occur in het, are delivered in the `templateData`.

        Parameters
        ----------
        noFind: boolean, optional False
            If `noFind` we override the filtering by the filter widget on the interface.

            We use this when the user has indicated that he wants to apply an action
            on all buckets instead of the filtered ones.

        node: integer, optional None
            If passed, it is a TF node, probably for a top-level section.
            The effect is that it restricts the result to those buttons that fall
            under that TF node.

            We use this when we retrieve the context for a given bucket.
        &#34;&#34;&#34;
        annotate = self.annotate
        templateData = self.templateData

        bFindRe = None if noFind else templateData.bfindre
        anyEnt = templateData.anyent
        activeEntity = templateData.activeentity
        tokenStart = templateData.tokenstart
        tokenEnd = templateData.tokenend
        valSelect = templateData.valselect
        freeState = templateData.freestate

        setData = annotate.getSetData()
        entityIdent = setData.entityIdent

        if activeEntity not in entityIdent:
            activeEntity = None
            templateData.activeentity = None

        qTokens = (
            self.getStrings(tokenStart, tokenEnd) if tokenStart and tokenEnd else None
        )

        (
            self.buckets,
            templateData.nfind,
            templateData.nvisible,
            templateData.nent,
        ) = annotate.filterContent(
            node=node,
            bFindRe=bFindRe,
            anyEnt=anyEnt,
            eVals=activeEntity,
            qTokens=qTokens,
            valSelect=valSelect,
            freeState=freeState,
        )

    def setHandling(self):
        &#34;&#34;&#34;Carries out the set-related actions before composing the page.

        These actions are:

        *   switch to an other set than the current set
            and create it if it does not yet exist;
        *   duplicate the current set;
        *   rename the current set;
        *   delete a set.

        The results of the actions are wrapped in messages and stored in the
        `templateData`.
        &#34;&#34;&#34;
        annotate = self.annotate
        annoDir = annotate.annoDir
        settings = annotate.settings
        entitySet = settings.entitySet

        templateData = self.templateData
        chosenAnnoSet = templateData.annoset
        dupAnnoSet = templateData.duannoset
        renamedAnnoSet = templateData.rannoset
        deleteAnnoSet = templateData.dannoset

        messages = []

        if deleteAnnoSet:
            messages.extend(annotate.setDel(deleteAnnoSet))
            templateData.dannoset = &#34;&#34;
            templateData.annoset = &#34;&#34;

        if dupAnnoSet:
            messages.extend(annotate.setDup(dupAnnoSet))
            templateData.annoset = dupAnnoSet
            templateData.duannoset = &#34;&#34;

        if renamedAnnoSet and chosenAnnoSet:
            messages.extend(annotate.setMove(renamedAnnoSet))
            templateData.annoset = renamedAnnoSet
            templateData.rannoset = &#34;&#34;

        chosenAnnoSet = templateData.annoset
        annotate.setSet(chosenAnnoSet)
        setNames = annotate.setNames

        templateData.annosets = wrapAnnoSets(
            annoDir, chosenAnnoSet, setNames, entitySet
        )
        templateData.messages = wrapMessages(messages)

    def updateHandling(self):
        &#34;&#34;&#34;Carries out modification actions in the current annotation set.

        Modification actions are:

        *   deletion of an entity;
        *   addition of an entity.

        The results of the actions are wrapped in a report and stored in the
        `templateData`.
        &#34;&#34;&#34;
        annotate = self.annotate
        templateData = self.templateData

        delData = templateData.deldata
        addData = templateData.adddata
        activeEntity = templateData.activeentity
        tokenStart = templateData.tokenstart
        tokenEnd = templateData.tokenend
        submitter = templateData.submitter
        excludedTokens = templateData.excludedtokens
        bFindRe = templateData.bfindre
        scope = templateData.scope

        hasEnt = activeEntity is not None
        hasOcc = tokenStart is not None and tokenEnd is not None

        if (
            submitter in {&#34;delgo&#34;, &#34;addgo&#34;}
            and (delData or addData)
            and (hasEnt or hasOcc)
        ):
            if bFindRe and scope == SC_ALL:
                self.getBuckets(noFind=True)

            if submitter == &#34;delgo&#34; and delData:
                report = annotate.delEntityRich(
                    delData.deletions, self.buckets, excludedTokens=excludedTokens
                )
                annotate.loadData()
                wrapReport(annotate, templateData, report, &#34;del&#34;)
                if hasEnt:
                    setData = annotate.getSetData()
                    entityIdent = setData.entityIdent

                    stillExists = activeEntity in entityIdent
                    if not stillExists:
                        templateData.activeentity = None

            if submitter == &#34;addgo&#34; and addData:
                report = annotate.addEntityRich(
                    addData.additions, self.buckets, excludedTokens=excludedTokens
                )
                annotate.loadData()
                wrapReport(annotate, templateData, report, &#34;add&#34;)

            adaptValSelect(annotate, templateData)

            self.getBuckets()


def serveNer(web):
    &#34;&#34;&#34;Main controller to render a full page.

    Parameters
    ----------
    web: object
        The TF browser object, a Flask web app.
    &#34;&#34;&#34;
    serve = Serve(web)
    serve.setupFull()
    serve.actionsFull()
    return serve.wrapFull()


def serveNerContext(web, node):
    &#34;&#34;&#34;Controller to render a portion of a page.

    More specifically: the context around a single bucket.

    Parameters
    ----------
    web: object
        The TF browser object, a Flask web app.
    node: integer
        The TF node that contain the bucket nodes that form the context.
    &#34;&#34;&#34;
    serve = Serve(web)
    serve.setupLean()
    serve.actionsLean(node)
    return serve.wrapLean()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.browser.ner.serve.serveNer"><code class="name flex">
<span>def <span class="ident">serveNer</span></span>(<span>web)</span>
</code></dt>
<dd>
<div class="desc"><p>Main controller to render a full page.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>web</code></strong> :&ensp;<code>object</code></dt>
<dd>The TF browser object, a Flask web app.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/serve.py#L388-L399" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def serveNer(web):
    &#34;&#34;&#34;Main controller to render a full page.

    Parameters
    ----------
    web: object
        The TF browser object, a Flask web app.
    &#34;&#34;&#34;
    serve = Serve(web)
    serve.setupFull()
    serve.actionsFull()
    return serve.wrapFull()</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.serve.serveNerContext"><code class="name flex">
<span>def <span class="ident">serveNerContext</span></span>(<span>web, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Controller to render a portion of a page.</p>
<p>More specifically: the context around a single bucket.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>web</code></strong> :&ensp;<code>object</code></dt>
<dd>The TF browser object, a Flask web app.</dd>
<dt><strong><code>node</code></strong> :&ensp;<code>integer</code></dt>
<dd>The TF node that contain the bucket nodes that form the context.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/serve.py#L402-L417" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def serveNerContext(web, node):
    &#34;&#34;&#34;Controller to render a portion of a page.

    More specifically: the context around a single bucket.

    Parameters
    ----------
    web: object
        The TF browser object, a Flask web app.
    node: integer
        The TF node that contain the bucket nodes that form the context.
    &#34;&#34;&#34;
    serve = Serve(web)
    serve.setupLean()
    serve.actionsLean(node)
    return serve.wrapLean()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.browser.ner.serve.Serve"><code class="flex name class">
<span>class <span class="ident">Serve</span></span>
<span>(</span><span>web)</span>
</code></dt>
<dd>
<div class="desc"><p>Object that implements the controller functions for the annotatation tool.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>web</code></strong> :&ensp;<code>object</code></dt>
<dd>
<p>This represents the Flask website that is the TF browser.
It has access to the TF-app that represents a loaded TF corpus.
See <code><a title="tf.browser.ner.web.factory" href="web.html#tf.browser.ner.web.factory">factory()</a></code> and <code><a title="tf.browser.web.factory" href="../web.html#tf.browser.web.factory">factory()</a></code>.</p>
<p>It picks up a handle to the loaded TF corpus, stores it in the <code><a title="tf.browser.ner.serve.Serve" href="#tf.browser.ner.serve.Serve">Serve</a></code>
object, and uses it to fetch the CSS code for this tool, which is
also stored in the <code><a title="tf.browser.ner.serve.Serve" href="#tf.browser.ner.serve.Serve">Serve</a></code> object.</p>
<p>Finally, it creates a pointer to the annotation data in memory, as stored
in the <code>web</code> object, if there is already such data from a previous request.
If not, it initializes an empty dict in the <code>web</code> object, with the purpose
of storing incoming annotation data there.</p>
<p>This way, the annotation data is preserved between requests.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/serve.py#L28-L385" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Serve:
    def __init__(self, web):
        &#34;&#34;&#34;Object that implements the controller functions for the annotatation tool.

        Parameters
        ----------
        web: object
            This represents the Flask website that is the TF browser.
            It has access to the TF-app that represents a loaded TF corpus.
            See `tf.browser.ner.web.factory` and `tf.browser.web.factory`.

            It picks up a handle to the loaded TF corpus, stores it in the `Serve`
            object, and uses it to fetch the CSS code for this tool, which is
            also stored in the `Serve` object.

            Finally, it creates a pointer to the annotation data in memory, as stored
            in the `web` object, if there is already such data from a previous request.
            If not, it initializes an empty dict in the `web` object, with the purpose
            of storing incoming annotation data there.

            This way, the annotation data is preserved between requests.
        &#34;&#34;&#34;
        self.web = web
        kernelApi = web.kernelApi
        self.app = kernelApi.app
        self.css = kernelApi.css()

        if not hasattr(web, &#34;toolData&#34;):
            setattr(web, &#34;toolData&#34;, AttrDict())
        toolData = web.toolData

        if TOOLKEY not in toolData:
            toolData[TOOLKEY] = AttrDict()

        self.data = toolData[TOOLKEY]

    def setupAnnotate(self):
        &#34;&#34;&#34;Initialize the Annotate object.

        Before doing anything else, we create a
        `tf.browser.ner.annotate.Annotate` object and store it for use
        by the actual controllers.

        Based on the information in the request, we switch to a particular annotation
        set and load its data.

        This method will be invoked via two routes:

        *   `Serve.setupFull()`: for the main page, after a normal request;
        *   `Serve.setupLean()`: in response to an Ajax call when context to a
            specific line in the corpus is needed.

        !!! note &#34;`templateData`&#34;
            We use the dict `templateData` as the collector of

            *   the request information;
            *   selections of corpus material;
            *   HTML fragments under construction;
            *   template variables.
        &#34;&#34;&#34;
        data = self.data
        app = self.app

        annotate = Annotate(app, data=data, browse=True)

        initTemplate(annotate, app)
        templateData = annotate.templateData

        annoSet = templateData.annoset

        annotate.setSet(annoSet)
        self.annotate = annotate
        annotate.loadData()

    def setupFull(self):
        &#34;&#34;&#34;Prepares to serve a complete page.

        *   Creates an `tf.browser.ner.annotate.Annotate` object;
        *   Sets up the find widget;
        *   Encodes the active entity in hidden `input` elements;
        *   Collects and generates the specific CSS styles needed for this corpus.
        &#34;&#34;&#34;
        css = self.css

        self.setupAnnotate()
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features
        keywordFeatures = settings.keywordFeatures

        templateData = self.templateData

        findSetup(templateData)
        wrapActive(templateData)
        templateData.css = makeCss(features, keywordFeatures, generic=css)

    def setupLean(self):
        &#34;&#34;&#34;Prepares to update a portion of the page.

        *   Creates an `tf.browser.ner.annotate.Annotate` object;
        *   Encodes the active entity in hidden `input` elements.
        &#34;&#34;&#34;
        self.setupAnnotate()
        templateData = self.templateData

        wrapActive(templateData)

    def actionsFull(self):
        &#34;&#34;&#34;Carries out requested actions before building the full page.

        *   annotation set management actions;
        *   fetch selected buckets from the whole corpus;
        *   modification actions in the selected set.
        &#34;&#34;&#34;
        templateData = self.templateData

        self.setHandling(templateData)

        self.getBuckets()
        self.updateHandling()

    def actionsLean(self, node):
        &#34;&#34;&#34;Carries out requested actions before building a portion of the page.

        *   fetch all buckets from a section of the corpus.
        &#34;&#34;&#34;
        self.getBuckets(node=node)

    def wrapFull(self):
        &#34;&#34;&#34;Builds the full page.

        This includes the controls by which the user makes selections and triggers
        axctions.
        &#34;&#34;&#34;
        annotate = self.annotate
        templateData = self.templateData
        sortKey = templateData.sortkey
        sortDir = templateData.sortdir
        activeEntity = templateData.activeentity
        tokenStart = templateData.tokenstart
        tokenEnd = templateData.tokenend
        excludedTokens = templateData.excludedtokens

        buckets = self.buckets

        wrapQuery(annotate, templateData)
        templateData.entitytable = annotate.showEntities(
            activeEntity=activeEntity, sortKey=sortKey, sortDir=sortDir
        )
        templateData.entityoverview = annotate.showEntityOverview()
        templateData.entityheaders = wrapEntityHeaders(annotate, sortKey, sortDir)
        templateData.buckets = annotate.showContent(
            buckets,
            activeEntity=activeEntity,
            excludedTokens=excludedTokens,
            mayLimit=not (tokenStart and tokenEnd),
        )

        return render_template(f&#34;{TOOLKEY}/index.html&#34;, **templateData)

    def wrapLean(self):
        &#34;&#34;&#34;Builds a portion of the page.

        No need to build user controls, because they are already on the page.

        Returns
        -------
        The generated HTML for the portion of the page.
        &#34;&#34;&#34;
        annotate = self.annotate
        templateData = self.templateData
        activeEntity = templateData.activeentity
        excludedTokens = templateData.excludedtokens
        buckets = self.buckets

        return annotate.showContent(
            buckets,
            activeEntity=activeEntity,
            excludedTokens=excludedTokens,
            mayLimit=False,
        )

    def getBuckets(self, noFind=False, node=None):
        &#34;&#34;&#34;Fetch a selection of buckets from the corpus.

        The selection is defined in the `templateData`.

        We further modify the selection by two additional parameters.

        The resulting list of buckets is obtained by
        `tf.browser.ner.annotate.Annotate.filterContent`, and each member in the bucket
        list is a tuple as indicated in the `filterContent` function.
        The list is stored in the `Serve` object.
        Additionally, statistics about these buckets and how many entity values
        occur in het, are delivered in the `templateData`.

        Parameters
        ----------
        noFind: boolean, optional False
            If `noFind` we override the filtering by the filter widget on the interface.

            We use this when the user has indicated that he wants to apply an action
            on all buckets instead of the filtered ones.

        node: integer, optional None
            If passed, it is a TF node, probably for a top-level section.
            The effect is that it restricts the result to those buttons that fall
            under that TF node.

            We use this when we retrieve the context for a given bucket.
        &#34;&#34;&#34;
        annotate = self.annotate
        templateData = self.templateData

        bFindRe = None if noFind else templateData.bfindre
        anyEnt = templateData.anyent
        activeEntity = templateData.activeentity
        tokenStart = templateData.tokenstart
        tokenEnd = templateData.tokenend
        valSelect = templateData.valselect
        freeState = templateData.freestate

        setData = annotate.getSetData()
        entityIdent = setData.entityIdent

        if activeEntity not in entityIdent:
            activeEntity = None
            templateData.activeentity = None

        qTokens = (
            self.getStrings(tokenStart, tokenEnd) if tokenStart and tokenEnd else None
        )

        (
            self.buckets,
            templateData.nfind,
            templateData.nvisible,
            templateData.nent,
        ) = annotate.filterContent(
            node=node,
            bFindRe=bFindRe,
            anyEnt=anyEnt,
            eVals=activeEntity,
            qTokens=qTokens,
            valSelect=valSelect,
            freeState=freeState,
        )

    def setHandling(self):
        &#34;&#34;&#34;Carries out the set-related actions before composing the page.

        These actions are:

        *   switch to an other set than the current set
            and create it if it does not yet exist;
        *   duplicate the current set;
        *   rename the current set;
        *   delete a set.

        The results of the actions are wrapped in messages and stored in the
        `templateData`.
        &#34;&#34;&#34;
        annotate = self.annotate
        annoDir = annotate.annoDir
        settings = annotate.settings
        entitySet = settings.entitySet

        templateData = self.templateData
        chosenAnnoSet = templateData.annoset
        dupAnnoSet = templateData.duannoset
        renamedAnnoSet = templateData.rannoset
        deleteAnnoSet = templateData.dannoset

        messages = []

        if deleteAnnoSet:
            messages.extend(annotate.setDel(deleteAnnoSet))
            templateData.dannoset = &#34;&#34;
            templateData.annoset = &#34;&#34;

        if dupAnnoSet:
            messages.extend(annotate.setDup(dupAnnoSet))
            templateData.annoset = dupAnnoSet
            templateData.duannoset = &#34;&#34;

        if renamedAnnoSet and chosenAnnoSet:
            messages.extend(annotate.setMove(renamedAnnoSet))
            templateData.annoset = renamedAnnoSet
            templateData.rannoset = &#34;&#34;

        chosenAnnoSet = templateData.annoset
        annotate.setSet(chosenAnnoSet)
        setNames = annotate.setNames

        templateData.annosets = wrapAnnoSets(
            annoDir, chosenAnnoSet, setNames, entitySet
        )
        templateData.messages = wrapMessages(messages)

    def updateHandling(self):
        &#34;&#34;&#34;Carries out modification actions in the current annotation set.

        Modification actions are:

        *   deletion of an entity;
        *   addition of an entity.

        The results of the actions are wrapped in a report and stored in the
        `templateData`.
        &#34;&#34;&#34;
        annotate = self.annotate
        templateData = self.templateData

        delData = templateData.deldata
        addData = templateData.adddata
        activeEntity = templateData.activeentity
        tokenStart = templateData.tokenstart
        tokenEnd = templateData.tokenend
        submitter = templateData.submitter
        excludedTokens = templateData.excludedtokens
        bFindRe = templateData.bfindre
        scope = templateData.scope

        hasEnt = activeEntity is not None
        hasOcc = tokenStart is not None and tokenEnd is not None

        if (
            submitter in {&#34;delgo&#34;, &#34;addgo&#34;}
            and (delData or addData)
            and (hasEnt or hasOcc)
        ):
            if bFindRe and scope == SC_ALL:
                self.getBuckets(noFind=True)

            if submitter == &#34;delgo&#34; and delData:
                report = annotate.delEntityRich(
                    delData.deletions, self.buckets, excludedTokens=excludedTokens
                )
                annotate.loadData()
                wrapReport(annotate, templateData, report, &#34;del&#34;)
                if hasEnt:
                    setData = annotate.getSetData()
                    entityIdent = setData.entityIdent

                    stillExists = activeEntity in entityIdent
                    if not stillExists:
                        templateData.activeentity = None

            if submitter == &#34;addgo&#34; and addData:
                report = annotate.addEntityRich(
                    addData.additions, self.buckets, excludedTokens=excludedTokens
                )
                annotate.loadData()
                wrapReport(annotate, templateData, report, &#34;add&#34;)

            adaptValSelect(annotate, templateData)

            self.getBuckets()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.browser.ner.serve.Serve.actionsFull"><code class="name flex">
<span>def <span class="ident">actionsFull</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Carries out requested actions before building the full page.</p>
<ul>
<li>annotation set management actions;</li>
<li>fetch selected buckets from the whole corpus;</li>
<li>modification actions in the selected set.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/serve.py#L135-L147" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def actionsFull(self):
    &#34;&#34;&#34;Carries out requested actions before building the full page.

    *   annotation set management actions;
    *   fetch selected buckets from the whole corpus;
    *   modification actions in the selected set.
    &#34;&#34;&#34;
    templateData = self.templateData

    self.setHandling(templateData)

    self.getBuckets()
    self.updateHandling()</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.serve.Serve.actionsLean"><code class="name flex">
<span>def <span class="ident">actionsLean</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Carries out requested actions before building a portion of the page.</p>
<ul>
<li>fetch all buckets from a section of the corpus.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/serve.py#L149-L154" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def actionsLean(self, node):
    &#34;&#34;&#34;Carries out requested actions before building a portion of the page.

    *   fetch all buckets from a section of the corpus.
    &#34;&#34;&#34;
    self.getBuckets(node=node)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.serve.Serve.getBuckets"><code class="name flex">
<span>def <span class="ident">getBuckets</span></span>(<span>self, noFind=False, node=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a selection of buckets from the corpus.</p>
<p>The selection is defined in the <code>templateData</code>.</p>
<p>We further modify the selection by two additional parameters.</p>
<p>The resulting list of buckets is obtained by
<code><a title="tf.browser.ner.annotate.Annotate.filterContent" href="annotate.html#tf.browser.ner.annotate.Annotate.filterContent">Annotate.filterContent()</a></code>, and each member in the bucket
list is a tuple as indicated in the <code>filterContent</code> function.
The list is stored in the <code><a title="tf.browser.ner.serve.Serve" href="#tf.browser.ner.serve.Serve">Serve</a></code> object.
Additionally, statistics about these buckets and how many entity values
occur in het, are delivered in the <code>templateData</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>noFind</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>
<p>If <code>noFind</code> we override the filtering by the filter widget on the interface.</p>
<p>We use this when the user has indicated that he wants to apply an action
on all buckets instead of the filtered ones.</p>
</dd>
<dt><strong><code>node</code></strong> :&ensp;<code>integer</code>, optional <code>None</code></dt>
<dd>
<p>If passed, it is a TF node, probably for a top-level section.
The effect is that it restricts the result to those buttons that fall
under that TF node.</p>
<p>We use this when we retrieve the context for a given bucket.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/serve.py#L210-L274" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getBuckets(self, noFind=False, node=None):
    &#34;&#34;&#34;Fetch a selection of buckets from the corpus.

    The selection is defined in the `templateData`.

    We further modify the selection by two additional parameters.

    The resulting list of buckets is obtained by
    `tf.browser.ner.annotate.Annotate.filterContent`, and each member in the bucket
    list is a tuple as indicated in the `filterContent` function.
    The list is stored in the `Serve` object.
    Additionally, statistics about these buckets and how many entity values
    occur in het, are delivered in the `templateData`.

    Parameters
    ----------
    noFind: boolean, optional False
        If `noFind` we override the filtering by the filter widget on the interface.

        We use this when the user has indicated that he wants to apply an action
        on all buckets instead of the filtered ones.

    node: integer, optional None
        If passed, it is a TF node, probably for a top-level section.
        The effect is that it restricts the result to those buttons that fall
        under that TF node.

        We use this when we retrieve the context for a given bucket.
    &#34;&#34;&#34;
    annotate = self.annotate
    templateData = self.templateData

    bFindRe = None if noFind else templateData.bfindre
    anyEnt = templateData.anyent
    activeEntity = templateData.activeentity
    tokenStart = templateData.tokenstart
    tokenEnd = templateData.tokenend
    valSelect = templateData.valselect
    freeState = templateData.freestate

    setData = annotate.getSetData()
    entityIdent = setData.entityIdent

    if activeEntity not in entityIdent:
        activeEntity = None
        templateData.activeentity = None

    qTokens = (
        self.getStrings(tokenStart, tokenEnd) if tokenStart and tokenEnd else None
    )

    (
        self.buckets,
        templateData.nfind,
        templateData.nvisible,
        templateData.nent,
    ) = annotate.filterContent(
        node=node,
        bFindRe=bFindRe,
        anyEnt=anyEnt,
        eVals=activeEntity,
        qTokens=qTokens,
        valSelect=valSelect,
        freeState=freeState,
    )</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.serve.Serve.setHandling"><code class="name flex">
<span>def <span class="ident">setHandling</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Carries out the set-related actions before composing the page.</p>
<p>These actions are:</p>
<ul>
<li>switch to an other set than the current set
and create it if it does not yet exist;</li>
<li>duplicate the current set;</li>
<li>rename the current set;</li>
<li>delete a set.</li>
</ul>
<p>The results of the actions are wrapped in messages and stored in the
<code>templateData</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/serve.py#L276-L325" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setHandling(self):
    &#34;&#34;&#34;Carries out the set-related actions before composing the page.

    These actions are:

    *   switch to an other set than the current set
        and create it if it does not yet exist;
    *   duplicate the current set;
    *   rename the current set;
    *   delete a set.

    The results of the actions are wrapped in messages and stored in the
    `templateData`.
    &#34;&#34;&#34;
    annotate = self.annotate
    annoDir = annotate.annoDir
    settings = annotate.settings
    entitySet = settings.entitySet

    templateData = self.templateData
    chosenAnnoSet = templateData.annoset
    dupAnnoSet = templateData.duannoset
    renamedAnnoSet = templateData.rannoset
    deleteAnnoSet = templateData.dannoset

    messages = []

    if deleteAnnoSet:
        messages.extend(annotate.setDel(deleteAnnoSet))
        templateData.dannoset = &#34;&#34;
        templateData.annoset = &#34;&#34;

    if dupAnnoSet:
        messages.extend(annotate.setDup(dupAnnoSet))
        templateData.annoset = dupAnnoSet
        templateData.duannoset = &#34;&#34;

    if renamedAnnoSet and chosenAnnoSet:
        messages.extend(annotate.setMove(renamedAnnoSet))
        templateData.annoset = renamedAnnoSet
        templateData.rannoset = &#34;&#34;

    chosenAnnoSet = templateData.annoset
    annotate.setSet(chosenAnnoSet)
    setNames = annotate.setNames

    templateData.annosets = wrapAnnoSets(
        annoDir, chosenAnnoSet, setNames, entitySet
    )
    templateData.messages = wrapMessages(messages)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.serve.Serve.setupAnnotate"><code class="name flex">
<span>def <span class="ident">setupAnnotate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the Annotate object.</p>
<p>Before doing anything else, we create a
<code><a title="tf.browser.ner.annotate.Annotate" href="annotate.html#tf.browser.ner.annotate.Annotate">Annotate</a></code> object and store it for use
by the actual controllers.</p>
<p>Based on the information in the request, we switch to a particular annotation
set and load its data.</p>
<p>This method will be invoked via two routes:</p>
<ul>
<li><code><a title="tf.browser.ner.serve.Serve.setupFull" href="#tf.browser.ner.serve.Serve.setupFull">Serve.setupFull()</a></code>: for the main page, after a normal request;</li>
<li><code><a title="tf.browser.ner.serve.Serve.setupLean" href="#tf.browser.ner.serve.Serve.setupLean">Serve.setupLean()</a></code>: in response to an Ajax call when context to a
specific line in the corpus is needed.</li>
</ul>
<div class="admonition note">
<p class="admonition-title"><code>templateData</code></p>
<p>We use the dict <code>templateData</code> as the collector of</p>
<ul>
<li>the request information;</li>
<li>selections of corpus material;</li>
<li>HTML fragments under construction;</li>
<li>template variables.</li>
</ul>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/serve.py#L64-L100" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setupAnnotate(self):
    &#34;&#34;&#34;Initialize the Annotate object.

    Before doing anything else, we create a
    `tf.browser.ner.annotate.Annotate` object and store it for use
    by the actual controllers.

    Based on the information in the request, we switch to a particular annotation
    set and load its data.

    This method will be invoked via two routes:

    *   `Serve.setupFull()`: for the main page, after a normal request;
    *   `Serve.setupLean()`: in response to an Ajax call when context to a
        specific line in the corpus is needed.

    !!! note &#34;`templateData`&#34;
        We use the dict `templateData` as the collector of

        *   the request information;
        *   selections of corpus material;
        *   HTML fragments under construction;
        *   template variables.
    &#34;&#34;&#34;
    data = self.data
    app = self.app

    annotate = Annotate(app, data=data, browse=True)

    initTemplate(annotate, app)
    templateData = annotate.templateData

    annoSet = templateData.annoset

    annotate.setSet(annoSet)
    self.annotate = annotate
    annotate.loadData()</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.serve.Serve.setupFull"><code class="name flex">
<span>def <span class="ident">setupFull</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepares to serve a complete page.</p>
<ul>
<li>Creates an <code><a title="tf.browser.ner.annotate.Annotate" href="annotate.html#tf.browser.ner.annotate.Annotate">Annotate</a></code> object;</li>
<li>Sets up the find widget;</li>
<li>Encodes the active entity in hidden <code>input</code> elements;</li>
<li>Collects and generates the specific CSS styles needed for this corpus.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/serve.py#L102-L122" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setupFull(self):
    &#34;&#34;&#34;Prepares to serve a complete page.

    *   Creates an `tf.browser.ner.annotate.Annotate` object;
    *   Sets up the find widget;
    *   Encodes the active entity in hidden `input` elements;
    *   Collects and generates the specific CSS styles needed for this corpus.
    &#34;&#34;&#34;
    css = self.css

    self.setupAnnotate()
    annotate = self.annotate
    settings = annotate.settings
    features = settings.features
    keywordFeatures = settings.keywordFeatures

    templateData = self.templateData

    findSetup(templateData)
    wrapActive(templateData)
    templateData.css = makeCss(features, keywordFeatures, generic=css)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.serve.Serve.setupLean"><code class="name flex">
<span>def <span class="ident">setupLean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepares to update a portion of the page.</p>
<ul>
<li>Creates an <code><a title="tf.browser.ner.annotate.Annotate" href="annotate.html#tf.browser.ner.annotate.Annotate">Annotate</a></code> object;</li>
<li>Encodes the active entity in hidden <code>input</code> elements.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/serve.py#L124-L133" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setupLean(self):
    &#34;&#34;&#34;Prepares to update a portion of the page.

    *   Creates an `tf.browser.ner.annotate.Annotate` object;
    *   Encodes the active entity in hidden `input` elements.
    &#34;&#34;&#34;
    self.setupAnnotate()
    templateData = self.templateData

    wrapActive(templateData)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.serve.Serve.updateHandling"><code class="name flex">
<span>def <span class="ident">updateHandling</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Carries out modification actions in the current annotation set.</p>
<p>Modification actions are:</p>
<ul>
<li>deletion of an entity;</li>
<li>addition of an entity.</li>
</ul>
<p>The results of the actions are wrapped in a report and stored in the
<code>templateData</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/serve.py#L327-L385" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def updateHandling(self):
    &#34;&#34;&#34;Carries out modification actions in the current annotation set.

    Modification actions are:

    *   deletion of an entity;
    *   addition of an entity.

    The results of the actions are wrapped in a report and stored in the
    `templateData`.
    &#34;&#34;&#34;
    annotate = self.annotate
    templateData = self.templateData

    delData = templateData.deldata
    addData = templateData.adddata
    activeEntity = templateData.activeentity
    tokenStart = templateData.tokenstart
    tokenEnd = templateData.tokenend
    submitter = templateData.submitter
    excludedTokens = templateData.excludedtokens
    bFindRe = templateData.bfindre
    scope = templateData.scope

    hasEnt = activeEntity is not None
    hasOcc = tokenStart is not None and tokenEnd is not None

    if (
        submitter in {&#34;delgo&#34;, &#34;addgo&#34;}
        and (delData or addData)
        and (hasEnt or hasOcc)
    ):
        if bFindRe and scope == SC_ALL:
            self.getBuckets(noFind=True)

        if submitter == &#34;delgo&#34; and delData:
            report = annotate.delEntityRich(
                delData.deletions, self.buckets, excludedTokens=excludedTokens
            )
            annotate.loadData()
            wrapReport(annotate, templateData, report, &#34;del&#34;)
            if hasEnt:
                setData = annotate.getSetData()
                entityIdent = setData.entityIdent

                stillExists = activeEntity in entityIdent
                if not stillExists:
                    templateData.activeentity = None

        if submitter == &#34;addgo&#34; and addData:
            report = annotate.addEntityRich(
                addData.additions, self.buckets, excludedTokens=excludedTokens
            )
            annotate.loadData()
            wrapReport(annotate, templateData, report, &#34;add&#34;)

        adaptValSelect(annotate, templateData)

        self.getBuckets()</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.serve.Serve.wrapFull"><code class="name flex">
<span>def <span class="ident">wrapFull</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds the full page.</p>
<p>This includes the controls by which the user makes selections and triggers
axctions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/serve.py#L156-L186" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapFull(self):
    &#34;&#34;&#34;Builds the full page.

    This includes the controls by which the user makes selections and triggers
    axctions.
    &#34;&#34;&#34;
    annotate = self.annotate
    templateData = self.templateData
    sortKey = templateData.sortkey
    sortDir = templateData.sortdir
    activeEntity = templateData.activeentity
    tokenStart = templateData.tokenstart
    tokenEnd = templateData.tokenend
    excludedTokens = templateData.excludedtokens

    buckets = self.buckets

    wrapQuery(annotate, templateData)
    templateData.entitytable = annotate.showEntities(
        activeEntity=activeEntity, sortKey=sortKey, sortDir=sortDir
    )
    templateData.entityoverview = annotate.showEntityOverview()
    templateData.entityheaders = wrapEntityHeaders(annotate, sortKey, sortDir)
    templateData.buckets = annotate.showContent(
        buckets,
        activeEntity=activeEntity,
        excludedTokens=excludedTokens,
        mayLimit=not (tokenStart and tokenEnd),
    )

    return render_template(f&#34;{TOOLKEY}/index.html&#34;, **templateData)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.serve.Serve.wrapLean"><code class="name flex">
<span>def <span class="ident">wrapLean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds a portion of the page.</p>
<p>No need to build user controls, because they are already on the page.</p>
<h2 id="returns">Returns</h2>
<p>The generated HTML for the portion of the page.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/serve.py#L188-L208" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapLean(self):
    &#34;&#34;&#34;Builds a portion of the page.

    No need to build user controls, because they are already on the page.

    Returns
    -------
    The generated HTML for the portion of the page.
    &#34;&#34;&#34;
    annotate = self.annotate
    templateData = self.templateData
    activeEntity = templateData.activeentity
    excludedTokens = templateData.excludedtokens
    buckets = self.buckets

    return annotate.showContent(
        buckets,
        activeEntity=activeEntity,
        excludedTokens=excludedTokens,
        mayLimit=False,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.browser.ner" href="index.html">tf.browser.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.browser.ner.serve.serveNer" href="#tf.browser.ner.serve.serveNer">serveNer</a></code></li>
<li><code><a title="tf.browser.ner.serve.serveNerContext" href="#tf.browser.ner.serve.serveNerContext">serveNerContext</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.browser.ner.serve.Serve" href="#tf.browser.ner.serve.Serve">Serve</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.browser.ner.serve.Serve.actionsFull" href="#tf.browser.ner.serve.Serve.actionsFull">actionsFull</a></code></li>
<li><code><a title="tf.browser.ner.serve.Serve.actionsLean" href="#tf.browser.ner.serve.Serve.actionsLean">actionsLean</a></code></li>
<li><code><a title="tf.browser.ner.serve.Serve.getBuckets" href="#tf.browser.ner.serve.Serve.getBuckets">getBuckets</a></code></li>
<li><code><a title="tf.browser.ner.serve.Serve.setHandling" href="#tf.browser.ner.serve.Serve.setHandling">setHandling</a></code></li>
<li><code><a title="tf.browser.ner.serve.Serve.setupAnnotate" href="#tf.browser.ner.serve.Serve.setupAnnotate">setupAnnotate</a></code></li>
<li><code><a title="tf.browser.ner.serve.Serve.setupFull" href="#tf.browser.ner.serve.Serve.setupFull">setupFull</a></code></li>
<li><code><a title="tf.browser.ner.serve.Serve.setupLean" href="#tf.browser.ner.serve.Serve.setupLean">setupLean</a></code></li>
<li><code><a title="tf.browser.ner.serve.Serve.updateHandling" href="#tf.browser.ner.serve.Serve.updateHandling">updateHandling</a></code></li>
<li><code><a title="tf.browser.ner.serve.Serve.wrapFull" href="#tf.browser.ner.serve.Serve.wrapFull">wrapFull</a></code></li>
<li><code><a title="tf.browser.ner.serve.Serve.wrapLean" href="#tf.browser.ner.serve.Serve.wrapLean">wrapLean</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>