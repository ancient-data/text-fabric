<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.1" />
<title>tf.ner.triggers API documentation</title>
<meta name="description" content="" />
<!-- integrity SRI from https://cdnjs.com/libraries/10up-sanitize.css/11.0.1 -->
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha512-kcbluZFacWN57NgWZ4aH6eUMBEaTyErFhIFD3y5qYZbKuuyImH0K/AKsBbfXlivh2z5C+3IDTIhI11YmKomzmA=="
crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha512-uVeAgzAmieLUTGba0qr9vXQgVD7fko2kcbYIKIraXUIDg9iJLxveTFUrg3DJhqn3cAf3HFDbgmhq0eGko5wEAA=="
crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.ner.triggers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/618cf9d8b4775d721d5e3c1e2a30462a6626db67/tf/ner/triggers.py#L1-L749" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import collections
from textwrap import dedent

from ..core.files import fileOpen
from ..core.helpers import console

from .helpers import hasCommon, toTokens
from .match import occMatch
from .scopes import locInScopes


def makePartitions(triggers, myToTokens):
    &#34;&#34;&#34;Partition a set of triggers into groups where triggers are pairwise disjoint.

    The intention is to explore all triggers that apparently do not have hits.
    We need to look them up in isolation, because then they might have hits.

    But searching per trigger is expensive. We want to group triggers together
    that can not interact with each other: triggers whose tokens are pairwise
    disjoint. A hit of one trigger can then never be part of a hit of any other
    trigger in the group.
    &#34;&#34;&#34;

    triggerTokens = {}
    nTriggerTokens = {}

    for trigger in triggers:
        tokens = myToTokens(trigger)
        triggerTokens[trigger] = tokens
        nTriggerTokens.setdefault(len(tokens), {})[trigger] = tokens

    singleTokenTriggers = list(nTriggerTokens[1]) if 1 in nTriggerTokens else []

    partition = [singleTokenTriggers]

    for n in sorted(nTriggerTokens):
        if n == 1:
            continue
        for triggerA, tokensA in nTriggerTokens[n].items():
            added = False

            for part in partition:
                common = False

                for triggerB in part:
                    tokensB = triggerTokens[triggerB]

                    if hasCommon(tokensA, tokensB):
                        common = True
                        break

                if common:
                    continue

                part.append(triggerA)
                added = True
                break

            if not added:
                partition.append([triggerA])

    return (triggerTokens, partition)


class Triggers:
    def partitionTriggers(self, triggers):
        return makePartitions(triggers, self.getToTokensFunc())[1]

    def reportHits(self, silent=None, showNoHits=False):
        &#34;&#34;&#34;Reports the inventory.&#34;&#34;&#34;
        if not self.properlySetup:
            return

        silent = self.silent if silent is None else silent
        sectionHead = self.sectionHead
        sheetData = self.getSheetData()
        allTriggers = sheetData.allTriggers
        inventory = sheetData.inventory

        setName = self.setName
        annoDir = self.annoDir
        setDir = f&#34;{annoDir}/{setName}&#34;
        reportFile = f&#34;{setDir}/hits.tsv&#34;
        reportTriggerBySlotFile = f&#34;{setDir}/triggerBySlot.tsv&#34;

        hitData = []
        names = set()
        noHits = set()
        triggersBySlot = {}

        for e in sorted(allTriggers):
            (name, eidkind, trigger, scope) = e

            names.add(name)

            entry = (name, trigger, scope)
            section = &#34;&#34;
            hits = &#34;&#34;

            entInfo = inventory.get(eidkind, None)

            if entInfo is None:
                hitData.append((&#34;!E&#34;, *entry, &#34;&#34;, 0))
                noHits.add(trigger)
                continue

            triggerInfo = entInfo.get(trigger, None)

            if triggerInfo is None:
                hitData.append((&#34;!T&#34;, *entry, &#34;&#34;, 0))
                noHits.add(trigger)
                continue

            occs = triggerInfo.get(scope, None)

            if occs is None or len(occs) == 0:
                hitData.append((&#34;!P&#34;, *entry, &#34;&#34;, 0))
                noHits.add(trigger)
                continue

            sectionInfo = collections.Counter()

            for slots in occs:
                for slot in slots:
                    triggersBySlot.setdefault(slot, set()).add(trigger)

                section = sectionHead(slots[0])
                sectionInfo[section] += 1

            for section, hits in sorted(sectionInfo.items()):
                hitData.append((&#34;OK&#34;, *entry, section, hits))

        multipleTriggers = {}
        triggerBySlot = {}
        self.triggerBySlot = triggerBySlot

        for slot, triggers in triggersBySlot.items():
            if len(triggers) &gt; 1:
                multipleTriggers[slot] = triggers

            triggerBySlot[slot] = list(triggers)[0]

        if len(multipleTriggers) == 0:
            self.console(&#34;No slot is covered by more than one trigger&#34;)
        else:
            console(
                f&#34;Slots covered by multiple triggers: {len(multipleTriggers)}&#34;,
                error=True,
            )
            for slot, triggers in multipleTriggers.items():
                triggersRep = &#34;, &#34;.join(f&#34;«{trigger}»&#34; for trigger in sorted(triggers))
                self.console(f&#34;{slot:&gt;7}: {triggersRep}&#34;, error=True)

        trigWithout = len(noHits)

        if showNoHits and (trigWithout &gt; 0):
            uncovered = 0
            console(
                &#34;Triggers without hits: &#34; f&#34;{trigWithout}x:&#34;,
                error=True,
            )

            if len(noHits):
                uncovered = self.diagnoseTriggers(noHits, detail=False)

        with fileOpen(reportFile, &#34;w&#34;) as rh:
            rh.write(&#34;label\tname\ttrigger\tscope\tsection\thits\n&#34;)

            for h in sorted(hitData):
                line = &#34;\t&#34;.join(str(c) for c in h)
                rh.write(f&#34;{line}\n&#34;)

        with fileOpen(reportTriggerBySlotFile, &#34;w&#34;) as rh:
            rh.write(&#34;slot\ttrigger\n&#34;)

            for slot, trigger in sorted(
                triggerBySlot.items(), key=lambda x: (x[1], x[0])
            ):
                rh.write(f&#34;{slot}\t{trigger}\n&#34;)

        nEnt = len(names)
        nTriggers = len(allTriggers)
        nHits = sum(e[-1] for e in hitData)

        msg = (
            f&#34;\t{nEnt} entities targeted with {nHits} occurrences. See {reportFile}&#34;
            if silent
            else dedent(
                f&#34;&#34;&#34;
                Entities targeted:          {nEnt:&gt;5}
                Triggers searched for:      {nTriggers:&gt;5}
                Triggers without hits:      {trigWithout:&gt;5}
                 - completely covered:      {trigWithout - uncovered:&gt;5}
                 - missing hits:            {uncovered:&gt;5}
                Triggers with hits:         {nTriggers - trigWithout:&gt;5}
                Total hits:                 {nHits:&gt;5}

                All hits in report file:      {reportFile}
                Triggers by slot in file:     {reportTriggerBySlotFile}
                &#34;&#34;&#34;
            )
        )
        console(msg)

    def triggerInterference(self, alsoInternal=False, alsoExpected=False):
        &#34;&#34;&#34;Produce a report of interferences between triggers.

        Triggers interfere if they have matches that intersect, i.e. there is a match
        m1 of trigger t1 and a match m2 of trigger t2 such that m1 and m2 intersect.

        Triggers may interfere *potentially*: if the triggers overlap they can have
        intersecting matches. But it does not mean that the corpus contains overlapping
        matches, i.e. that the triggers conflict actually.

        We report *actually* interfering triggers.

        Triggers within one row are associated to the same entity and work in the same
        row. It is not bad if they are conflicting with each other. If there
        are conflicting matches, the trigger that wins still flags the same entity.
        The worst thing is that some of these triggers are superfluous, but there is
        no reason to be picky on superfluous triggers.

        When one trigger is a proper part of another, this is mostly intentional.
        If the longer trigger matches, it wins it from the shorter trigger, unless
        the shorter trigger&#39;s match starts before the longer trigger&#39;s match.

        We think the user expects the longer trigger to win, but it may surprise him
        if the shorter triggers wins because it starts earlier.

        Parameters
        ----------
        alsoInternal: boolean, optional False
            Also report interference between triggers on the same row.
        alsoExpected: boolean, optional False
            Also report expected interferences.
        &#34;&#34;&#34;
        setName = self.setName
        annoDir = self.annoDir
        setDir = f&#34;{annoDir}/{setName}&#34;
        reportFile = f&#34;{setDir}/interference.txt&#34;

        app = self.app
        L = app.api.L
        T = app.api.T
        sheetData = self.getSheetData()
        rowMap = sheetData.rowMap
        triggerScopes = sheetData.triggerScopes

        interferences, parts = self.interference(
            rowMap,
            triggerScopes,
            self.getToTokensFunc(),
            self.seqFromStr,
            alsoInternal=alsoInternal,
            alsoExpected=alsoExpected,
        )

        messages = []
        witnessed = {}

        nParts = len(parts)
        plural = &#34;&#34; if nParts == 1 else &#34;es&#34;
        self.console(
            f&#34;Looking up {len(interferences)} potential interferences &#34;
            f&#34;in {len(parts)} pass{plural} over the corpus &#34;,
            newline=False,
        )

        for part in parts:
            self.console(&#34;.&#34;, newline=False)
            inventory = self.findTriggers(part)

            for trigger, data in inventory.items():
                occs = data.get(trigger, {}).get(&#34;&#34;, [])
                nOccs = len(occs)

                if nOccs:
                    witnessed[trigger] = occs

        self.console(&#34;&#34;)

        msg = (
            f&#34;{len(witnessed)} potential conflicting trigger pairs with &#34;
            f&#34;{sum(len(x) for x in witnessed.values())} conflicts&#34;
        )
        console(msg)
        messages.append(msg)

        conflicts = {}

        for (
            triggerA,
            triggerB,
            triggerC,
            scopeRepA,
            scopeRepB,
            commonScopes,
        ) in interferences:
            if triggerC not in witnessed:
                continue

            rowA = sorted(set(rowMap[triggerA]))
            rowB = sorted(set(rowMap[triggerB]))
            key = &#34;same row&#34; if rowA == rowB else &#34;different rows&#34;
            conflicts.setdefault(key, []).append(
                (
                    rowA,
                    rowB,
                    triggerA,
                    triggerB,
                    witnessed[triggerC],
                    scopeRepA,
                    scopeRepB,
                    commonScopes,
                )
            )

        for key, confls in conflicts.items():
            newConfls = []

            for (
                rowA,
                rowB,
                triggerA,
                triggerB,
                occs,
                scopeRepA,
                scopeRepB,
                commonScopes,
            ) in confls:
                hits = {}

                for occ in sorted(occs):
                    sectionNode = L.u(occ[0], otype=&#34;chunk&#34;)[0]
                    heading = tuple(
                        int(x if type(x) is int else x.lstrip(&#34;0&#34;) or &#34;0&#34;)
                        for x in T.sectionFromNode(sectionNode, fillup=True)
                    )

                    if not locInScopes(heading, commonScopes):
                        continue

                    heading = app.sectionStrFromNode(sectionNode)
                    hits.setdefault(heading, []).append(occ)

                if len(hits) == 0:
                    continue

                newConfls.append(
                    (rowA, rowB, triggerA, triggerB, hits, scopeRepA, scopeRepB)
                )

            msg = f&#34;{key} ({len(newConfls)} pairs)&#34;
            msg = f&#34;----------\n{msg}\n----------&#34;
            console(msg)
            messages.append(msg)

            for (
                rowA,
                rowB,
                triggerA,
                triggerB,
                hits,
                scopeRepA,
                scopeRepB,
            ) in newConfls:
                rowRepA = &#34;,&#34;.join(str(r) for r in rowA)
                rowRepB = &#34;,&#34;.join(str(r) for r in rowB)
                msg = (
                    f&#34;{rowRepA:&lt;12} ({scopeRepA:&lt;12}): «{triggerA}»\n&#34;
                    f&#34;{rowRepB:&lt;12} ({scopeRepB:&lt;12}): «{triggerB}»&#34;
                )
                console(msg)
                messages.append(msg)
                console(f&#34;{hits=}&#34;)

                diags = []

                i = 0

                for heading, occs in sorted(hits.items()):
                    nOccs = len(occs)

                    if i == 0:
                        diags.append([])

                    diags[-1].append(f&#34;{heading} x {nOccs}&#34;)
                    i += 1

                    if i == 5:
                        i = 0

                first = True

                for batch in diags:
                    label = f&#34;{&#39;occurrences&#39;:&gt;25}: &#34; if first else (&#34; &#34; * 27)
                    first = False
                    msg = f&#34;{label} {&#39;, &#39;.join(batch)}&#34;
                    console(msg)
                    messages.append(msg)

        with fileOpen(reportFile, &#34;w&#34;) as fh:
            for msg in messages:
                fh.write(f&#34;{msg}\n&#34;)

        console(f&#34;Diagnostic trigger interferences written to {reportFile}&#34;)

    def diagnoseTriggers(self, triggers, detail=True):
        sheetData = self.getSheetData()
        triggerScopes = sheetData.triggerScopes

        parts = self.partitionTriggers(triggers)

        uncovered = 0

        nParts = len(parts)
        plural = &#34;&#34; if nParts == 1 else &#34;es&#34;
        self.console(
            f&#34;Looking up {len(triggers)} triggers &#34;
            f&#34;in {len(parts)} pass{plural} over the corpus &#34;,
            newline=False,
        )

        items = []

        for part in parts:
            self.console(&#34;.&#34;, newline=False)
            inventory = self.findTriggers(part)

            for trigger, data in inventory.items():
                occs = data.get(trigger, {}).get(&#34;&#34;, [])
                items.append((trigger, occs))

        for trigger, occs in sorted(
            items,
            key=lambda x: (&#34;, &#34;.join(sorted(triggerScopes[x[0]])), x[0].lower()),
        ):
            uncovered += 0 if self.diagnoseTrigger(trigger, occs, detail=detail) else 1

        self.console(&#34;&#34;)

        return uncovered

    def diagnoseTrigger(self, trigger, occs, detail=True):
        app = self.app
        L = app.api.L
        triggerBySlot = self.triggerBySlot
        sheetData = self.getSheetData()
        triggerScopes = sheetData.triggerScopes

        uncoveredSlots = set()
        coveredBy = {}

        for slots in occs:
            for slot in slots:
                cTrigger = triggerBySlot.get(slot, None)

                if cTrigger is None:
                    uncoveredSlots.add(slot)
                else:
                    coveredBy.setdefault(cTrigger, set()).add(slot)

        properHits = {}

        nUncoveredSlots = len(uncoveredSlots)
        ok = nUncoveredSlots == 0

        if nUncoveredSlots:
            for slot in sorted(uncoveredSlots):
                heading = app.sectionStrFromNode(L.u(slot, otype=&#34;chunk&#34;)[0])
                occ = properHits.setdefault(heading, [[]])

                if len(occ[-1]) == 0 or occ[-1][-1] + 1 == slot:
                    occ[-1].append(slot)
                else:
                    occ.append([slot])

        nMissedHits = 0
        properOccsDiag = []
        properOccsDiagCompact = []

        for heading, occs in properHits.items():
            nOccs = len(occs)
            nMissedHits += nOccs
            properOccsDiag.append(f&#34;\t\t{heading}: {nOccs} x&#34;)
            properOccsDiagCompact.append(f&#34;{heading} x {nOccs}&#34;)

        properOccsDiag[0:0] = [f&#34;\tuncovered: {nMissedHits} x&#34;]

        coveredOccsDiag = []

        for cTrigger in sorted(coveredBy, key=lambda x: x.lower()):
            thisCoveredOccsDiag = []
            coveredSlots = sorted(coveredBy[cTrigger])

            coveredHits = {}

            for slot in sorted(coveredSlots):
                heading = app.sectionStrFromNode(L.u(slot, otype=&#34;chunk&#34;)[0])
                occ = coveredHits.setdefault(heading, [[]])

                if len(occ[-1]) == 0 or occ[-1][-1] + 1 == slot:
                    occ[-1].append(slot)
                else:
                    occ.append([slot])

            nCoveredHits = 0

            for heading, occs in coveredHits.items():
                nOccs = len(occs)
                nCoveredHits += nOccs
                thisCoveredOccsDiag.append(f&#34;\t\t{heading}: {nOccs} x&#34;)

            thisCoveredOccsDiag[0:0] = [f&#34;\tcovered by: {cTrigger}: {nCoveredHits} x&#34;]

            coveredOccsDiag.extend(thisCoveredOccsDiag)

        scopeRep = f&#34;({&#39;, &#39;.join(sorted(triggerScopes[trigger]))})&#34;

        if detail:
            console(f&#34;{trigger} {scopeRep}:&#34;)

            for line in properOccsDiag:
                console(line)

            for line in coveredOccsDiag:
                console(line)

        else:
            if nUncoveredSlots == 0:
                if False:
                    console(f&#34;{trigger} {scopeRep}: covered by other triggers&#34;)
            else:
                missedHits = []

                i = 0
                for occRep in properOccsDiagCompact:
                    if i == 0:
                        missedHits.append([occRep])
                    else:
                        missedHits[-1].append(occRep)

                    i += 1
                    if i == 5:
                        i = 0

                missedHitsRep = &#34;, &#34;.join(missedHits[0])
                console(f&#34;{trigger:&lt;40} {scopeRep:&lt;12}: {missedHitsRep}&#34;, error=True)

                for m in missedHits[1:]:
                    missedHitsRep = &#34;, &#34;.join(m)
                    console(f&#34;{&#39; &#39; * 55}{missedHitsRep}&#34;, error=True)

        return ok

    def interference(
        self,
        rowMap,
        triggerScopes,
        myToTokens,
        seqFromStr,
        alsoInternal=False,
        alsoExpected=False,
    ):
        triggers = list(rowMap)

        triggerTokens, parts = makePartitions(triggers, myToTokens)

        nParts = len(parts)

        interferences = []

        intersections = {}

        for i, part in enumerate(parts):
            if i == nParts - 1:
                break

            for otherPart in parts[i + 1 : nParts]:
                for triggerA in part:
                    for triggerB in otherPart:
                        tokensA = triggerTokens[triggerA]
                        tokensB = triggerTokens[triggerB]

                        if not alsoInternal:
                            rowsA = set(rowMap[triggerA])
                            rowsB = set(rowMap[triggerB])
                            if rowsA == rowsB:
                                continue

                        scopesA = &#34;,&#34;.join(sorted(triggerScopes[triggerA]))
                        scopesB = &#34;,&#34;.join(sorted(triggerScopes[triggerB]))
                        commonScopes = intersections.get((triggerA, triggerB), None)

                        if commonScopes is None:
                            commonScopes = self.intersectScopes(scopesA, scopesB)
                            intersections[(triggerA, triggerB)] = commonScopes

                        if len(commonScopes) == 0:
                            continue

                        common = hasCommon(tokensA, tokensB)

                        if common is None:
                            continue

                        ref, pos, length = common
                        nTokensA = len(tokensA)
                        nTokensB = len(tokensB)

                        nTokensLatter = nTokensB if ref == 1 else nTokensA

                        expected = length == nTokensLatter

                        if expected and not alsoExpected:
                            continue

                        if ref == 1:
                            nB = len(tokensB)
                            union = tokensA

                            if length &lt; nB:
                                union += tokensB[length:]
                        else:
                            nA = len(tokensA)
                            union = tokensB

                            if length &lt; nA:
                                union += tokensA[length:]

                        interferences.append(
                            (
                                triggerA,
                                triggerB,
                                &#34; &#34;.join(union),
                                scopesA,
                                scopesB,
                                commonScopes,
                            )
                        )

        parts = makePartitions([x[2] for x in interferences], myToTokens)[1]

        return interferences, parts

    def findTriggers(self, triggers):
        if not self.properlySetup:
            return []

        settings = self.settings
        spaceEscaped = settings.spaceEscaped

        setData = self.getSetData()
        getTokens = self.getTokens
        seqFromNode = self.seqFromNode

        buckets = setData.buckets or ()
        sheetData = self.getSheetData()

        caseSensitive = sheetData.caseSensitive

        idMap = {trigger: trigger for trigger in triggers}
        tMap = {trigger: &#34;&#34; for trigger in triggers}
        tPos = {}
        triggerSet = set()
        instructions = {(): dict(tPos=tPos, tMap=tMap, idMap=idMap)}

        for trigger in triggers:
            triggerT = toTokens(
                trigger, spaceEscaped=spaceEscaped, caseSensitive=caseSensitive
            )
            triggerSet.add(triggerT)

        for triggerT in triggerSet:
            for i, token in enumerate(triggerT):
                tPos.setdefault(i, {}).setdefault(token, set()).add(triggerT)

        inventory = occMatch(
            getTokens,
            seqFromNode,
            buckets,
            instructions,
            spaceEscaped,
            caseSensitive=caseSensitive,
        )

        return inventory

    def findTrigger(self, trigger, show=True):
        if not self.properlySetup:
            return []

        app = self.app
        L = app.api.L

        settings = self.settings
        spaceEscaped = settings.spaceEscaped

        setData = self.getSetData()
        getTokens = self.getTokens
        seqFromNode = self.seqFromNode

        buckets = setData.buckets or ()
        sheetData = self.getSheetData()

        caseSensitive = sheetData.caseSensitive

        triggerT = toTokens(
            trigger, spaceEscaped=spaceEscaped, caseSensitive=caseSensitive
        )
        idMap = {trigger: trigger}
        tMap = {trigger: &#34;&#34;}
        tPos = {}

        for i, token in enumerate(triggerT):
            tPos.setdefault(i, {}).setdefault(token, set()).add(triggerT)

        instructions = {(): dict(tPos=tPos, tMap=tMap, idMap=idMap)}

        inventory = occMatch(
            getTokens,
            seqFromNode,
            buckets,
            instructions,
            spaceEscaped,
            caseSensitive=caseSensitive,
        )

        occs = inventory.get(trigger, {}).get(trigger, {}).get(&#34;&#34;, [])

        if show:
            nOccs = len(occs)
            plural = &#34;&#34; if nOccs == 1 else &#34;s&#34;
            app.dm(f&#34;**{nOccs} occurrence{plural}**\n&#34;)

            if nOccs:
                headings = set()
                highlights = set()

                for occ in occs:
                    headings.add(L.u(occ[0], otype=&#34;chunk&#34;)[0])

                    for slot in occ:
                        highlights.add(slot)

                for hd in sorted(headings):
                    app.plain(hd, highlights=highlights)
        else:
            return occs</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.ner.triggers.makePartitions"><code class="name flex">
<span>def <span class="ident">makePartitions</span></span>(<span>triggers, myToTokens)</span>
</code></dt>
<dd>
<div class="desc"><p>Partition a set of triggers into groups where triggers are pairwise disjoint.</p>
<p>The intention is to explore all triggers that apparently do not have hits.
We need to look them up in isolation, because then they might have hits.</p>
<p>But searching per trigger is expensive. We want to group triggers together
that can not interact with each other: triggers whose tokens are pairwise
disjoint. A hit of one trigger can then never be part of a hit of any other
trigger in the group.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.ner.triggers.Triggers"><code class="flex name class">
<span>class <span class="ident">Triggers</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/618cf9d8b4775d721d5e3c1e2a30462a6626db67/tf/ner/triggers.py#L65-L749" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Triggers:
    def partitionTriggers(self, triggers):
        return makePartitions(triggers, self.getToTokensFunc())[1]

    def reportHits(self, silent=None, showNoHits=False):
        &#34;&#34;&#34;Reports the inventory.&#34;&#34;&#34;
        if not self.properlySetup:
            return

        silent = self.silent if silent is None else silent
        sectionHead = self.sectionHead
        sheetData = self.getSheetData()
        allTriggers = sheetData.allTriggers
        inventory = sheetData.inventory

        setName = self.setName
        annoDir = self.annoDir
        setDir = f&#34;{annoDir}/{setName}&#34;
        reportFile = f&#34;{setDir}/hits.tsv&#34;
        reportTriggerBySlotFile = f&#34;{setDir}/triggerBySlot.tsv&#34;

        hitData = []
        names = set()
        noHits = set()
        triggersBySlot = {}

        for e in sorted(allTriggers):
            (name, eidkind, trigger, scope) = e

            names.add(name)

            entry = (name, trigger, scope)
            section = &#34;&#34;
            hits = &#34;&#34;

            entInfo = inventory.get(eidkind, None)

            if entInfo is None:
                hitData.append((&#34;!E&#34;, *entry, &#34;&#34;, 0))
                noHits.add(trigger)
                continue

            triggerInfo = entInfo.get(trigger, None)

            if triggerInfo is None:
                hitData.append((&#34;!T&#34;, *entry, &#34;&#34;, 0))
                noHits.add(trigger)
                continue

            occs = triggerInfo.get(scope, None)

            if occs is None or len(occs) == 0:
                hitData.append((&#34;!P&#34;, *entry, &#34;&#34;, 0))
                noHits.add(trigger)
                continue

            sectionInfo = collections.Counter()

            for slots in occs:
                for slot in slots:
                    triggersBySlot.setdefault(slot, set()).add(trigger)

                section = sectionHead(slots[0])
                sectionInfo[section] += 1

            for section, hits in sorted(sectionInfo.items()):
                hitData.append((&#34;OK&#34;, *entry, section, hits))

        multipleTriggers = {}
        triggerBySlot = {}
        self.triggerBySlot = triggerBySlot

        for slot, triggers in triggersBySlot.items():
            if len(triggers) &gt; 1:
                multipleTriggers[slot] = triggers

            triggerBySlot[slot] = list(triggers)[0]

        if len(multipleTriggers) == 0:
            self.console(&#34;No slot is covered by more than one trigger&#34;)
        else:
            console(
                f&#34;Slots covered by multiple triggers: {len(multipleTriggers)}&#34;,
                error=True,
            )
            for slot, triggers in multipleTriggers.items():
                triggersRep = &#34;, &#34;.join(f&#34;«{trigger}»&#34; for trigger in sorted(triggers))
                self.console(f&#34;{slot:&gt;7}: {triggersRep}&#34;, error=True)

        trigWithout = len(noHits)

        if showNoHits and (trigWithout &gt; 0):
            uncovered = 0
            console(
                &#34;Triggers without hits: &#34; f&#34;{trigWithout}x:&#34;,
                error=True,
            )

            if len(noHits):
                uncovered = self.diagnoseTriggers(noHits, detail=False)

        with fileOpen(reportFile, &#34;w&#34;) as rh:
            rh.write(&#34;label\tname\ttrigger\tscope\tsection\thits\n&#34;)

            for h in sorted(hitData):
                line = &#34;\t&#34;.join(str(c) for c in h)
                rh.write(f&#34;{line}\n&#34;)

        with fileOpen(reportTriggerBySlotFile, &#34;w&#34;) as rh:
            rh.write(&#34;slot\ttrigger\n&#34;)

            for slot, trigger in sorted(
                triggerBySlot.items(), key=lambda x: (x[1], x[0])
            ):
                rh.write(f&#34;{slot}\t{trigger}\n&#34;)

        nEnt = len(names)
        nTriggers = len(allTriggers)
        nHits = sum(e[-1] for e in hitData)

        msg = (
            f&#34;\t{nEnt} entities targeted with {nHits} occurrences. See {reportFile}&#34;
            if silent
            else dedent(
                f&#34;&#34;&#34;
                Entities targeted:          {nEnt:&gt;5}
                Triggers searched for:      {nTriggers:&gt;5}
                Triggers without hits:      {trigWithout:&gt;5}
                 - completely covered:      {trigWithout - uncovered:&gt;5}
                 - missing hits:            {uncovered:&gt;5}
                Triggers with hits:         {nTriggers - trigWithout:&gt;5}
                Total hits:                 {nHits:&gt;5}

                All hits in report file:      {reportFile}
                Triggers by slot in file:     {reportTriggerBySlotFile}
                &#34;&#34;&#34;
            )
        )
        console(msg)

    def triggerInterference(self, alsoInternal=False, alsoExpected=False):
        &#34;&#34;&#34;Produce a report of interferences between triggers.

        Triggers interfere if they have matches that intersect, i.e. there is a match
        m1 of trigger t1 and a match m2 of trigger t2 such that m1 and m2 intersect.

        Triggers may interfere *potentially*: if the triggers overlap they can have
        intersecting matches. But it does not mean that the corpus contains overlapping
        matches, i.e. that the triggers conflict actually.

        We report *actually* interfering triggers.

        Triggers within one row are associated to the same entity and work in the same
        row. It is not bad if they are conflicting with each other. If there
        are conflicting matches, the trigger that wins still flags the same entity.
        The worst thing is that some of these triggers are superfluous, but there is
        no reason to be picky on superfluous triggers.

        When one trigger is a proper part of another, this is mostly intentional.
        If the longer trigger matches, it wins it from the shorter trigger, unless
        the shorter trigger&#39;s match starts before the longer trigger&#39;s match.

        We think the user expects the longer trigger to win, but it may surprise him
        if the shorter triggers wins because it starts earlier.

        Parameters
        ----------
        alsoInternal: boolean, optional False
            Also report interference between triggers on the same row.
        alsoExpected: boolean, optional False
            Also report expected interferences.
        &#34;&#34;&#34;
        setName = self.setName
        annoDir = self.annoDir
        setDir = f&#34;{annoDir}/{setName}&#34;
        reportFile = f&#34;{setDir}/interference.txt&#34;

        app = self.app
        L = app.api.L
        T = app.api.T
        sheetData = self.getSheetData()
        rowMap = sheetData.rowMap
        triggerScopes = sheetData.triggerScopes

        interferences, parts = self.interference(
            rowMap,
            triggerScopes,
            self.getToTokensFunc(),
            self.seqFromStr,
            alsoInternal=alsoInternal,
            alsoExpected=alsoExpected,
        )

        messages = []
        witnessed = {}

        nParts = len(parts)
        plural = &#34;&#34; if nParts == 1 else &#34;es&#34;
        self.console(
            f&#34;Looking up {len(interferences)} potential interferences &#34;
            f&#34;in {len(parts)} pass{plural} over the corpus &#34;,
            newline=False,
        )

        for part in parts:
            self.console(&#34;.&#34;, newline=False)
            inventory = self.findTriggers(part)

            for trigger, data in inventory.items():
                occs = data.get(trigger, {}).get(&#34;&#34;, [])
                nOccs = len(occs)

                if nOccs:
                    witnessed[trigger] = occs

        self.console(&#34;&#34;)

        msg = (
            f&#34;{len(witnessed)} potential conflicting trigger pairs with &#34;
            f&#34;{sum(len(x) for x in witnessed.values())} conflicts&#34;
        )
        console(msg)
        messages.append(msg)

        conflicts = {}

        for (
            triggerA,
            triggerB,
            triggerC,
            scopeRepA,
            scopeRepB,
            commonScopes,
        ) in interferences:
            if triggerC not in witnessed:
                continue

            rowA = sorted(set(rowMap[triggerA]))
            rowB = sorted(set(rowMap[triggerB]))
            key = &#34;same row&#34; if rowA == rowB else &#34;different rows&#34;
            conflicts.setdefault(key, []).append(
                (
                    rowA,
                    rowB,
                    triggerA,
                    triggerB,
                    witnessed[triggerC],
                    scopeRepA,
                    scopeRepB,
                    commonScopes,
                )
            )

        for key, confls in conflicts.items():
            newConfls = []

            for (
                rowA,
                rowB,
                triggerA,
                triggerB,
                occs,
                scopeRepA,
                scopeRepB,
                commonScopes,
            ) in confls:
                hits = {}

                for occ in sorted(occs):
                    sectionNode = L.u(occ[0], otype=&#34;chunk&#34;)[0]
                    heading = tuple(
                        int(x if type(x) is int else x.lstrip(&#34;0&#34;) or &#34;0&#34;)
                        for x in T.sectionFromNode(sectionNode, fillup=True)
                    )

                    if not locInScopes(heading, commonScopes):
                        continue

                    heading = app.sectionStrFromNode(sectionNode)
                    hits.setdefault(heading, []).append(occ)

                if len(hits) == 0:
                    continue

                newConfls.append(
                    (rowA, rowB, triggerA, triggerB, hits, scopeRepA, scopeRepB)
                )

            msg = f&#34;{key} ({len(newConfls)} pairs)&#34;
            msg = f&#34;----------\n{msg}\n----------&#34;
            console(msg)
            messages.append(msg)

            for (
                rowA,
                rowB,
                triggerA,
                triggerB,
                hits,
                scopeRepA,
                scopeRepB,
            ) in newConfls:
                rowRepA = &#34;,&#34;.join(str(r) for r in rowA)
                rowRepB = &#34;,&#34;.join(str(r) for r in rowB)
                msg = (
                    f&#34;{rowRepA:&lt;12} ({scopeRepA:&lt;12}): «{triggerA}»\n&#34;
                    f&#34;{rowRepB:&lt;12} ({scopeRepB:&lt;12}): «{triggerB}»&#34;
                )
                console(msg)
                messages.append(msg)
                console(f&#34;{hits=}&#34;)

                diags = []

                i = 0

                for heading, occs in sorted(hits.items()):
                    nOccs = len(occs)

                    if i == 0:
                        diags.append([])

                    diags[-1].append(f&#34;{heading} x {nOccs}&#34;)
                    i += 1

                    if i == 5:
                        i = 0

                first = True

                for batch in diags:
                    label = f&#34;{&#39;occurrences&#39;:&gt;25}: &#34; if first else (&#34; &#34; * 27)
                    first = False
                    msg = f&#34;{label} {&#39;, &#39;.join(batch)}&#34;
                    console(msg)
                    messages.append(msg)

        with fileOpen(reportFile, &#34;w&#34;) as fh:
            for msg in messages:
                fh.write(f&#34;{msg}\n&#34;)

        console(f&#34;Diagnostic trigger interferences written to {reportFile}&#34;)

    def diagnoseTriggers(self, triggers, detail=True):
        sheetData = self.getSheetData()
        triggerScopes = sheetData.triggerScopes

        parts = self.partitionTriggers(triggers)

        uncovered = 0

        nParts = len(parts)
        plural = &#34;&#34; if nParts == 1 else &#34;es&#34;
        self.console(
            f&#34;Looking up {len(triggers)} triggers &#34;
            f&#34;in {len(parts)} pass{plural} over the corpus &#34;,
            newline=False,
        )

        items = []

        for part in parts:
            self.console(&#34;.&#34;, newline=False)
            inventory = self.findTriggers(part)

            for trigger, data in inventory.items():
                occs = data.get(trigger, {}).get(&#34;&#34;, [])
                items.append((trigger, occs))

        for trigger, occs in sorted(
            items,
            key=lambda x: (&#34;, &#34;.join(sorted(triggerScopes[x[0]])), x[0].lower()),
        ):
            uncovered += 0 if self.diagnoseTrigger(trigger, occs, detail=detail) else 1

        self.console(&#34;&#34;)

        return uncovered

    def diagnoseTrigger(self, trigger, occs, detail=True):
        app = self.app
        L = app.api.L
        triggerBySlot = self.triggerBySlot
        sheetData = self.getSheetData()
        triggerScopes = sheetData.triggerScopes

        uncoveredSlots = set()
        coveredBy = {}

        for slots in occs:
            for slot in slots:
                cTrigger = triggerBySlot.get(slot, None)

                if cTrigger is None:
                    uncoveredSlots.add(slot)
                else:
                    coveredBy.setdefault(cTrigger, set()).add(slot)

        properHits = {}

        nUncoveredSlots = len(uncoveredSlots)
        ok = nUncoveredSlots == 0

        if nUncoveredSlots:
            for slot in sorted(uncoveredSlots):
                heading = app.sectionStrFromNode(L.u(slot, otype=&#34;chunk&#34;)[0])
                occ = properHits.setdefault(heading, [[]])

                if len(occ[-1]) == 0 or occ[-1][-1] + 1 == slot:
                    occ[-1].append(slot)
                else:
                    occ.append([slot])

        nMissedHits = 0
        properOccsDiag = []
        properOccsDiagCompact = []

        for heading, occs in properHits.items():
            nOccs = len(occs)
            nMissedHits += nOccs
            properOccsDiag.append(f&#34;\t\t{heading}: {nOccs} x&#34;)
            properOccsDiagCompact.append(f&#34;{heading} x {nOccs}&#34;)

        properOccsDiag[0:0] = [f&#34;\tuncovered: {nMissedHits} x&#34;]

        coveredOccsDiag = []

        for cTrigger in sorted(coveredBy, key=lambda x: x.lower()):
            thisCoveredOccsDiag = []
            coveredSlots = sorted(coveredBy[cTrigger])

            coveredHits = {}

            for slot in sorted(coveredSlots):
                heading = app.sectionStrFromNode(L.u(slot, otype=&#34;chunk&#34;)[0])
                occ = coveredHits.setdefault(heading, [[]])

                if len(occ[-1]) == 0 or occ[-1][-1] + 1 == slot:
                    occ[-1].append(slot)
                else:
                    occ.append([slot])

            nCoveredHits = 0

            for heading, occs in coveredHits.items():
                nOccs = len(occs)
                nCoveredHits += nOccs
                thisCoveredOccsDiag.append(f&#34;\t\t{heading}: {nOccs} x&#34;)

            thisCoveredOccsDiag[0:0] = [f&#34;\tcovered by: {cTrigger}: {nCoveredHits} x&#34;]

            coveredOccsDiag.extend(thisCoveredOccsDiag)

        scopeRep = f&#34;({&#39;, &#39;.join(sorted(triggerScopes[trigger]))})&#34;

        if detail:
            console(f&#34;{trigger} {scopeRep}:&#34;)

            for line in properOccsDiag:
                console(line)

            for line in coveredOccsDiag:
                console(line)

        else:
            if nUncoveredSlots == 0:
                if False:
                    console(f&#34;{trigger} {scopeRep}: covered by other triggers&#34;)
            else:
                missedHits = []

                i = 0
                for occRep in properOccsDiagCompact:
                    if i == 0:
                        missedHits.append([occRep])
                    else:
                        missedHits[-1].append(occRep)

                    i += 1
                    if i == 5:
                        i = 0

                missedHitsRep = &#34;, &#34;.join(missedHits[0])
                console(f&#34;{trigger:&lt;40} {scopeRep:&lt;12}: {missedHitsRep}&#34;, error=True)

                for m in missedHits[1:]:
                    missedHitsRep = &#34;, &#34;.join(m)
                    console(f&#34;{&#39; &#39; * 55}{missedHitsRep}&#34;, error=True)

        return ok

    def interference(
        self,
        rowMap,
        triggerScopes,
        myToTokens,
        seqFromStr,
        alsoInternal=False,
        alsoExpected=False,
    ):
        triggers = list(rowMap)

        triggerTokens, parts = makePartitions(triggers, myToTokens)

        nParts = len(parts)

        interferences = []

        intersections = {}

        for i, part in enumerate(parts):
            if i == nParts - 1:
                break

            for otherPart in parts[i + 1 : nParts]:
                for triggerA in part:
                    for triggerB in otherPart:
                        tokensA = triggerTokens[triggerA]
                        tokensB = triggerTokens[triggerB]

                        if not alsoInternal:
                            rowsA = set(rowMap[triggerA])
                            rowsB = set(rowMap[triggerB])
                            if rowsA == rowsB:
                                continue

                        scopesA = &#34;,&#34;.join(sorted(triggerScopes[triggerA]))
                        scopesB = &#34;,&#34;.join(sorted(triggerScopes[triggerB]))
                        commonScopes = intersections.get((triggerA, triggerB), None)

                        if commonScopes is None:
                            commonScopes = self.intersectScopes(scopesA, scopesB)
                            intersections[(triggerA, triggerB)] = commonScopes

                        if len(commonScopes) == 0:
                            continue

                        common = hasCommon(tokensA, tokensB)

                        if common is None:
                            continue

                        ref, pos, length = common
                        nTokensA = len(tokensA)
                        nTokensB = len(tokensB)

                        nTokensLatter = nTokensB if ref == 1 else nTokensA

                        expected = length == nTokensLatter

                        if expected and not alsoExpected:
                            continue

                        if ref == 1:
                            nB = len(tokensB)
                            union = tokensA

                            if length &lt; nB:
                                union += tokensB[length:]
                        else:
                            nA = len(tokensA)
                            union = tokensB

                            if length &lt; nA:
                                union += tokensA[length:]

                        interferences.append(
                            (
                                triggerA,
                                triggerB,
                                &#34; &#34;.join(union),
                                scopesA,
                                scopesB,
                                commonScopes,
                            )
                        )

        parts = makePartitions([x[2] for x in interferences], myToTokens)[1]

        return interferences, parts

    def findTriggers(self, triggers):
        if not self.properlySetup:
            return []

        settings = self.settings
        spaceEscaped = settings.spaceEscaped

        setData = self.getSetData()
        getTokens = self.getTokens
        seqFromNode = self.seqFromNode

        buckets = setData.buckets or ()
        sheetData = self.getSheetData()

        caseSensitive = sheetData.caseSensitive

        idMap = {trigger: trigger for trigger in triggers}
        tMap = {trigger: &#34;&#34; for trigger in triggers}
        tPos = {}
        triggerSet = set()
        instructions = {(): dict(tPos=tPos, tMap=tMap, idMap=idMap)}

        for trigger in triggers:
            triggerT = toTokens(
                trigger, spaceEscaped=spaceEscaped, caseSensitive=caseSensitive
            )
            triggerSet.add(triggerT)

        for triggerT in triggerSet:
            for i, token in enumerate(triggerT):
                tPos.setdefault(i, {}).setdefault(token, set()).add(triggerT)

        inventory = occMatch(
            getTokens,
            seqFromNode,
            buckets,
            instructions,
            spaceEscaped,
            caseSensitive=caseSensitive,
        )

        return inventory

    def findTrigger(self, trigger, show=True):
        if not self.properlySetup:
            return []

        app = self.app
        L = app.api.L

        settings = self.settings
        spaceEscaped = settings.spaceEscaped

        setData = self.getSetData()
        getTokens = self.getTokens
        seqFromNode = self.seqFromNode

        buckets = setData.buckets or ()
        sheetData = self.getSheetData()

        caseSensitive = sheetData.caseSensitive

        triggerT = toTokens(
            trigger, spaceEscaped=spaceEscaped, caseSensitive=caseSensitive
        )
        idMap = {trigger: trigger}
        tMap = {trigger: &#34;&#34;}
        tPos = {}

        for i, token in enumerate(triggerT):
            tPos.setdefault(i, {}).setdefault(token, set()).add(triggerT)

        instructions = {(): dict(tPos=tPos, tMap=tMap, idMap=idMap)}

        inventory = occMatch(
            getTokens,
            seqFromNode,
            buckets,
            instructions,
            spaceEscaped,
            caseSensitive=caseSensitive,
        )

        occs = inventory.get(trigger, {}).get(trigger, {}).get(&#34;&#34;, [])

        if show:
            nOccs = len(occs)
            plural = &#34;&#34; if nOccs == 1 else &#34;s&#34;
            app.dm(f&#34;**{nOccs} occurrence{plural}**\n&#34;)

            if nOccs:
                headings = set()
                highlights = set()

                for occ in occs:
                    headings.add(L.u(occ[0], otype=&#34;chunk&#34;)[0])

                    for slot in occ:
                        highlights.add(slot)

                for hd in sorted(headings):
                    app.plain(hd, highlights=highlights)
        else:
            return occs</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tf.ner.sheets.Sheets" href="sheets.html#tf.ner.sheets.Sheets">Sheets</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tf.ner.triggers.Triggers.diagnoseTrigger"><code class="name flex">
<span>def <span class="ident">diagnoseTrigger</span></span>(<span>self, trigger, occs, detail=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tf.ner.triggers.Triggers.diagnoseTriggers"><code class="name flex">
<span>def <span class="ident">diagnoseTriggers</span></span>(<span>self, triggers, detail=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tf.ner.triggers.Triggers.findTrigger"><code class="name flex">
<span>def <span class="ident">findTrigger</span></span>(<span>self, trigger, show=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tf.ner.triggers.Triggers.findTriggers"><code class="name flex">
<span>def <span class="ident">findTriggers</span></span>(<span>self, triggers)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tf.ner.triggers.Triggers.interference"><code class="name flex">
<span>def <span class="ident">interference</span></span>(<span>self, rowMap, triggerScopes, myToTokens, seqFromStr, alsoInternal=False, alsoExpected=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tf.ner.triggers.Triggers.partitionTriggers"><code class="name flex">
<span>def <span class="ident">partitionTriggers</span></span>(<span>self, triggers)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tf.ner.triggers.Triggers.reportHits"><code class="name flex">
<span>def <span class="ident">reportHits</span></span>(<span>self, silent=None, showNoHits=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Reports the inventory.</p></div>
</dd>
<dt id="tf.ner.triggers.Triggers.triggerInterference"><code class="name flex">
<span>def <span class="ident">triggerInterference</span></span>(<span>self, alsoInternal=False, alsoExpected=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a report of interferences between triggers.</p>
<p>Triggers interfere if they have matches that intersect, i.e. there is a match
m1 of trigger t1 and a match m2 of trigger t2 such that m1 and m2 intersect.</p>
<p>Triggers may interfere <em>potentially</em>: if the triggers overlap they can have
intersecting matches. But it does not mean that the corpus contains overlapping
matches, i.e. that the triggers conflict actually.</p>
<p>We report <em>actually</em> interfering triggers.</p>
<p>Triggers within one row are associated to the same entity and work in the same
row. It is not bad if they are conflicting with each other. If there
are conflicting matches, the trigger that wins still flags the same entity.
The worst thing is that some of these triggers are superfluous, but there is
no reason to be picky on superfluous triggers.</p>
<p>When one trigger is a proper part of another, this is mostly intentional.
If the longer trigger matches, it wins it from the shorter trigger, unless
the shorter trigger's match starts before the longer trigger's match.</p>
<p>We think the user expects the longer trigger to win, but it may surprise him
if the shorter triggers wins because it starts earlier.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>alsoInternal</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Also report interference between triggers on the same row.</dd>
<dt><strong><code>alsoExpected</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Also report expected interferences.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.ner" href="index.html">tf.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.ner.triggers.makePartitions" href="#tf.ner.triggers.makePartitions">makePartitions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.ner.triggers.Triggers" href="#tf.ner.triggers.Triggers">Triggers</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.ner.triggers.Triggers.diagnoseTrigger" href="#tf.ner.triggers.Triggers.diagnoseTrigger">diagnoseTrigger</a></code></li>
<li><code><a title="tf.ner.triggers.Triggers.diagnoseTriggers" href="#tf.ner.triggers.Triggers.diagnoseTriggers">diagnoseTriggers</a></code></li>
<li><code><a title="tf.ner.triggers.Triggers.findTrigger" href="#tf.ner.triggers.Triggers.findTrigger">findTrigger</a></code></li>
<li><code><a title="tf.ner.triggers.Triggers.findTriggers" href="#tf.ner.triggers.Triggers.findTriggers">findTriggers</a></code></li>
<li><code><a title="tf.ner.triggers.Triggers.interference" href="#tf.ner.triggers.Triggers.interference">interference</a></code></li>
<li><code><a title="tf.ner.triggers.Triggers.partitionTriggers" href="#tf.ner.triggers.Triggers.partitionTriggers">partitionTriggers</a></code></li>
<li><code><a title="tf.ner.triggers.Triggers.reportHits" href="#tf.ner.triggers.Triggers.reportHits">reportHits</a></code></li>
<li><code><a title="tf.ner.triggers.Triggers.triggerInterference" href="#tf.ner.triggers.Triggers.triggerInterference">triggerInterference</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
