<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.convert.watm_translatin API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-GjqubOlYA6/wOZV7F31o2t4ogk4JGDGFa6XmL+BfAG0=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-qDPJ4nH38AgHyK3U6cvI6DBifA+7hPBo8mVoH6pyN9c=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.convert.watm_translatin</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm_translatin.py#L1-L390" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import json
import re

from tf.core.helpers import console
from tf.core.files import initTree, dirContents, expanduser as ex
from tf.core.timestamp import DEEP
from tf.parameters import OTYPE, OSLOTS
from tf.app import use


TT_NAME = &#34;watm&#34;

NS_TF = &#34;tf&#34;
NS_PAGEXML = &#34;pagexml&#34;
NS_TEI = &#34;tei&#34;
NS_NLP = &#34;nlp&#34;
NS_TT = &#34;tt&#34;
NS_NONE = &#34;tf&#34;

NS_FROM_OTYPE = dict(
    doc=NS_TF,
    page=NS_TF,
    file=NS_TF,
    folder=NS_TF,
    letter=NS_TF,
    chapter=NS_TF,
    chunk=NS_TF,
    word=NS_TF,
    char=NS_TF,
    token=NS_NLP,
    sentence=NS_NLP,
)
NS_FROM_FEAT = dict(
    otype=NS_TF,
    doc=NS_TF,
    page=NS_TF,
    line=NS_TF,
    after=NS_TF,
    rafter=NS_TF,
    str=NS_TF,
    rstr=NS_TF,
)

KIND_NODE = &#34;node&#34;
KIND_EDGE = &#34;edge&#34;
KIND_ELEM = &#34;element&#34;
KIND_PI = &#34;pi&#34;
KIND_ATTR = &#34;attribute&#34;
KIND_FMT = &#34;format&#34;
KIND_ANNO = &#34;anno&#34;

REL_RE = re.compile(r&#34;&#34;&#34;/tf\b&#34;&#34;&#34;)


class WATM:
    def __init__(self, app, nsOrig, skipMeta=False, extra={}):
        self.app = app
        self.nsOrig = nsOrig
        self.extra = extra
        api = app.api
        F = api.F
        warning = app.warning

        self.L = api.L
        self.E = api.E
        self.Es = api.Es
        self.F = F
        self.Fs = api.Fs
        self.slotType = self.F.otype.slotType
        self.otypes = self.F.otype.all
        self.info = app.info
        self.warning = warning
        self.repoLocation = app.repoLocation

        Fall = api.Fall
        Eall = api.Eall
        excludedFeatures = {OTYPE, OSLOTS, &#34;after&#34;, &#34;str&#34;}
        self.nodeFeatures = [f for f in Fall() if f not in excludedFeatures]
        self.edgeFeatures = [f for f in Eall() if f not in excludedFeatures]

        FAllSet = set(Fall())
        F = api.F

        self.emptyv = F.empty.v if &#34;empty&#34; in FAllSet else None
        self.strv = F.str.v if &#34;str&#34; in FAllSet else None
        self.rstrv = F.rstr.v if &#34;rstr&#34; in FAllSet else None
        self.afterv = F.after.v if &#34;after&#34; in FAllSet else None
        self.rafterv = F.rafter.v if &#34;rafter&#34; in FAllSet else None
        is_metav = F.is_meta.v if &#34;is_meta&#34; in FAllSet else None
        self.is_metav = is_metav

        if skipMeta and not is_metav:
            warning(
                &#34;skipMeta=True has no effect because feature is_meta is not defined.&#34;
            )
            skipMeta = False

        self.skipMeta = skipMeta

    def makeText(self):
        F = self.F
        slotType = self.slotType
        skipMeta = self.skipMeta

        text = []
        tlFromTf = {}

        self.text = text
        self.tlFromTf = tlFromTf

        for s in F.otype.s(slotType):
            if skipMeta and F.is_meta.v(s):
                continue

            value = F.rstr.v(s)
            if value is None:
                value = F.str.v(s) or &#34;&#34;

            after = F.rafter.v(s)
            if after is None:
                after = F.after.v(s) or &#34;&#34;

            value = f&#34;{value}{after}&#34;

            text.append(value)
            t = len(text) - 1
            tlFromTf[s] = t

    def mkAnno(self, kind, ns, body, target):
        &#34;&#34;&#34;Make an annotation and return its id.

        Parameters
        ----------
        kind: string
            The kind of annotation.
        ns: string
            The namespace of the annotation.
        body: string
            The body of the annotation.
        target: string  or tuple of strings
            The target of the annotation.
        &#34;&#34;&#34;
        annos = self.annos
        aId = f&#34;a{len(annos):&gt;08}&#34;
        annos.append((kind, aId, ns, body, target))
        return aId

    def makeAnno(self):
        E = self.E
        Es = self.Es
        F = self.F
        Fs = self.Fs
        nodeFeatures = self.nodeFeatures
        edgeFeatures = self.edgeFeatures
        slotType = self.slotType
        otypes = self.otypes
        nsOrig = self.nsOrig
        skipMeta = self.skipMeta
        warning = self.warning

        tlFromTf = self.tlFromTf

        annos = []
        text = self.text
        self.annos = annos

        wrongTargets = []

        for otype in otypes:
            isSlot = otype == slotType

            for n in F.otype.s(otype):
                if isSlot:
                    if skipMeta and F.is_meta.v(n):
                        continue
                    t = tlFromTf[n]
                    target = f&#34;{t}-{t + 1}&#34;
                    self.mkAnno(KIND_NODE, NS_TF, n, target)
                else:
                    ws = E.oslots.s(n)
                    if skipMeta and (F.is_meta.v(ws[0]) or F.is_meta.v(ws[-1])):
                        continue
                    start = tlFromTf[ws[0]]
                    end = tlFromTf[ws[-1]]
                    if end &lt; start:
                        wrongTargets.append((otype, start, end))

                    target = f&#34;{start}-{end + 1}&#34;
                    aId = (
                        self.mkAnno(KIND_PI, nsOrig, otype[1:], target)
                        if otype.startswith(&#34;?&#34;)
                        else self.mkAnno(
                            KIND_ELEM, NS_FROM_OTYPE.get(otype, nsOrig), otype, target
                        )
                    )
                    tlFromTf[n] = aId
                    self.mkAnno(KIND_NODE, NS_TF, n, aId)

        for feat in nodeFeatures:
            ns = Fs(feat).meta.get(&#34;conversionCode&#34;, NS_FROM_FEAT.get(feat, nsOrig))

            if ns is None:
                warning(
                    f&#34;Node feature {feat} has no namespace, &#34;
                    f&#34;defaulting to {NS_NONE}&#34;
                )
                ns = NS_NONE

            for n, val in Fs(feat).items():
                t = tlFromTf.get(n, None)
                if t is None:
                    continue
                target = f&#34;{t}-{t + 1}&#34; if F.otype.v(n) == slotType else t
                aId = self.mkAnno(KIND_ATTR, ns, f&#34;{feat}={val}&#34;, target)

        for feat in edgeFeatures:
            ns = Es(feat).meta.get(&#34;conversionCode&#34;, NS_FROM_FEAT.get(feat, nsOrig))

            if ns is None:
                warning(
                    f&#34;Edge feature {feat} has no conversion code, &#34;
                    f&#34;defaulting to {NS_NONE}&#34;
                )
                ns = NS_NONE

            for fromNode, toNodes in Es(feat).items():
                if skipMeta and F.is_meta.v(fromNode):
                    continue
                fromT = tlFromTf.get(fromNode, None)
                if fromT is None:
                    continue
                targetFrom = (
                    f&#34;{fromT}-{fromT + 1}&#34; if F.otype.v(fromNode) == slotType else fromT
                )

                if type(toNodes) is dict:
                    for toNode, val in toNodes.items():
                        if skipMeta and F.is_meta.v(toNode):
                            continue
                        toT = tlFromTf.get(toNode, None)
                        if toT is None:
                            continue

                        targetTo = (
                            f&#34;{toT}-{toT + 1}&#34; if F.otype.v(toNode) == slotType else toT
                        )
                        target = f&#34;{targetFrom}-&gt;{targetTo}&#34;
                        aId = self.mkAnno(KIND_EDGE, ns, f&#34;{feat}={val}&#34;, target)
                else:
                    for toNode in toNodes:
                        if skipMeta and F.is_meta.v(toNode):
                            continue
                        toT = tlFromTf.get(toNode, None)
                        if toT is None:
                            continue
                        target = f&#34;{fromT}-&gt;{toT}&#34;
                        aId = self.mkAnno(KIND_EDGE, ns, feat, target)

        extra = {}
        extra.update(self.extra)

        for n, value in extra.items():
            t = tlFromTf[n]
            target = f&#34;{t}-{t + 1}&#34; if F.otype.v(n) == slotType else t
            aId = self.mkAnno(KIND_ANNO, NS_TT, str(value), target)

        if len(wrongTargets):
            print(f&#34;WARNING: wrong targets, {len(wrongTargets)}x&#34;)
            for otype, start, end in wrongTargets:
                sega = text[start]
                segb = text[end - 1]
                print(f&#34;{otype:&gt;20} {start:&gt;6} `{sega}` &gt; {end - 1} `{segb}`&#34;)

    def writeAll(self):
        app = self.app
        info = self.info
        warning = self.warning
        text = self.text
        annos = self.annos

        baseDir = self.repoLocation
        relative = app.context.relative
        version = app.version
        wRelative = REL_RE.sub(f&#34;/{TT_NAME}/{version}/&#34;, relative, count=1)
        resultDir = f&#34;{baseDir}{wRelative}&#34;
        textFile = f&#34;{resultDir}/text.json&#34;

        self.textFile = textFile

        initTree(resultDir, fresh=True)

        with open(textFile, &#34;w&#34;) as fh:
            json.dump(dict(_ordered_segments=text), fh, ensure_ascii=False, indent=1)

        info(f&#34;Text file: {len(text):&gt;7} segments to {textFile}&#34;, tm=False)

        annoStore = {}

        for kind, aId, ns, body, target in annos:
            annoStore[aId] = (kind, ns, body, target)

        aIdSorted = sorted(annoStore.keys())

        annoFile = f&#34;{resultDir}/anno.tsv&#34;

        if False:
            with open(annoFile, &#34;w&#34;) as fh:
                for aId in aIdSorted:
                    (kind, ns, body, target) = annoStore[aId]
                    fh.write(f&#34;{aId}\t{kind}\t{ns}\t{body}\t{target}\n&#34;)

        thisAnnoStore = {}
        thisA = 1
        annoFiles = []
        self.annoFiles = annoFiles

        LIMIT = 400000
        j = 0
        total = 0

        def writeThis():
            annoFile = f&#34;{resultDir}/anno-{thisA:&gt;01}.json&#34;
            annoFiles.append(annoFile)

            with open(annoFile, &#34;w&#34;) as fh:
                json.dump(thisAnnoStore, fh, ensure_ascii=False, indent=1)

            info(f&#34;{j:&gt;6} annotations written to {annoFile}&#34;)

        for aId in aIdSorted:
            if j &gt;= LIMIT:
                writeThis()
                thisA += 1
                thisAnnoStore = {}
                total += j
                j = 0

            thisAnnoStore[aId] = annoStore[aId]
            j += 1

        if len(thisAnnoStore):
            writeThis()
            total += j

        if len(annos) != total:
            info(f&#34;Sum of batches : {total:&gt;8}&#34;, tm=False)
            info(f&#34;All annotations: {len(annoStore):&gt;8}&#34;, tm=False)
            warning(&#34;Mismatch in number of annotations&#34;, tm=False)
        info(
            f&#34;Anno files: {len(annos):&gt;7} annotations to {len(annoFiles)} files&#34;,
            tm=False,
        )


class WATMS:
    def __init__(self, org, repo, backend):
        self.org = org
        self.repo = repo
        self.backend = backend

        repoDir = ex(f&#34;~/{backend}/{org}/{repo}&#34;)
        tfDir = f&#34;{repoDir}/tf&#34;
        docs = dirContents(tfDir)[1]
        console(f&#34;Found {len(docs)} docs in {tfDir}&#34;)
        self.docs = docs

    def produce(self, doc=None):
        org = self.org
        repo = self.repo
        backend = self.backend
        docs = self.docs

        chosenDoc = doc

        for doc in sorted(docs, key=lambda x: (x[0], int(x[1:]))):
            if chosenDoc is not None and chosenDoc != doc:
                continue

            console(f&#34;{doc:&gt;5} ... &#34;, newline=False)
            A = use(
                f&#34;{org}/{repo}:clone&#34;,
                relative=f&#34;tf/{doc}&#34;,
                checkout=&#34;clone&#34;,
                backend=backend,
                silent=DEEP,
            )
            WA = WATM(A)
            WA.makeText()
            WA.makeAnno()
            WA.writeAll()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.convert.watm_translatin.WATM"><code class="flex name class">
<span>class <span class="ident">WATM</span></span>
<span>(</span><span>app, nsOrig, skipMeta=False, extra={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm_translatin.py#L55-L352" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class WATM:
    def __init__(self, app, nsOrig, skipMeta=False, extra={}):
        self.app = app
        self.nsOrig = nsOrig
        self.extra = extra
        api = app.api
        F = api.F
        warning = app.warning

        self.L = api.L
        self.E = api.E
        self.Es = api.Es
        self.F = F
        self.Fs = api.Fs
        self.slotType = self.F.otype.slotType
        self.otypes = self.F.otype.all
        self.info = app.info
        self.warning = warning
        self.repoLocation = app.repoLocation

        Fall = api.Fall
        Eall = api.Eall
        excludedFeatures = {OTYPE, OSLOTS, &#34;after&#34;, &#34;str&#34;}
        self.nodeFeatures = [f for f in Fall() if f not in excludedFeatures]
        self.edgeFeatures = [f for f in Eall() if f not in excludedFeatures]

        FAllSet = set(Fall())
        F = api.F

        self.emptyv = F.empty.v if &#34;empty&#34; in FAllSet else None
        self.strv = F.str.v if &#34;str&#34; in FAllSet else None
        self.rstrv = F.rstr.v if &#34;rstr&#34; in FAllSet else None
        self.afterv = F.after.v if &#34;after&#34; in FAllSet else None
        self.rafterv = F.rafter.v if &#34;rafter&#34; in FAllSet else None
        is_metav = F.is_meta.v if &#34;is_meta&#34; in FAllSet else None
        self.is_metav = is_metav

        if skipMeta and not is_metav:
            warning(
                &#34;skipMeta=True has no effect because feature is_meta is not defined.&#34;
            )
            skipMeta = False

        self.skipMeta = skipMeta

    def makeText(self):
        F = self.F
        slotType = self.slotType
        skipMeta = self.skipMeta

        text = []
        tlFromTf = {}

        self.text = text
        self.tlFromTf = tlFromTf

        for s in F.otype.s(slotType):
            if skipMeta and F.is_meta.v(s):
                continue

            value = F.rstr.v(s)
            if value is None:
                value = F.str.v(s) or &#34;&#34;

            after = F.rafter.v(s)
            if after is None:
                after = F.after.v(s) or &#34;&#34;

            value = f&#34;{value}{after}&#34;

            text.append(value)
            t = len(text) - 1
            tlFromTf[s] = t

    def mkAnno(self, kind, ns, body, target):
        &#34;&#34;&#34;Make an annotation and return its id.

        Parameters
        ----------
        kind: string
            The kind of annotation.
        ns: string
            The namespace of the annotation.
        body: string
            The body of the annotation.
        target: string  or tuple of strings
            The target of the annotation.
        &#34;&#34;&#34;
        annos = self.annos
        aId = f&#34;a{len(annos):&gt;08}&#34;
        annos.append((kind, aId, ns, body, target))
        return aId

    def makeAnno(self):
        E = self.E
        Es = self.Es
        F = self.F
        Fs = self.Fs
        nodeFeatures = self.nodeFeatures
        edgeFeatures = self.edgeFeatures
        slotType = self.slotType
        otypes = self.otypes
        nsOrig = self.nsOrig
        skipMeta = self.skipMeta
        warning = self.warning

        tlFromTf = self.tlFromTf

        annos = []
        text = self.text
        self.annos = annos

        wrongTargets = []

        for otype in otypes:
            isSlot = otype == slotType

            for n in F.otype.s(otype):
                if isSlot:
                    if skipMeta and F.is_meta.v(n):
                        continue
                    t = tlFromTf[n]
                    target = f&#34;{t}-{t + 1}&#34;
                    self.mkAnno(KIND_NODE, NS_TF, n, target)
                else:
                    ws = E.oslots.s(n)
                    if skipMeta and (F.is_meta.v(ws[0]) or F.is_meta.v(ws[-1])):
                        continue
                    start = tlFromTf[ws[0]]
                    end = tlFromTf[ws[-1]]
                    if end &lt; start:
                        wrongTargets.append((otype, start, end))

                    target = f&#34;{start}-{end + 1}&#34;
                    aId = (
                        self.mkAnno(KIND_PI, nsOrig, otype[1:], target)
                        if otype.startswith(&#34;?&#34;)
                        else self.mkAnno(
                            KIND_ELEM, NS_FROM_OTYPE.get(otype, nsOrig), otype, target
                        )
                    )
                    tlFromTf[n] = aId
                    self.mkAnno(KIND_NODE, NS_TF, n, aId)

        for feat in nodeFeatures:
            ns = Fs(feat).meta.get(&#34;conversionCode&#34;, NS_FROM_FEAT.get(feat, nsOrig))

            if ns is None:
                warning(
                    f&#34;Node feature {feat} has no namespace, &#34;
                    f&#34;defaulting to {NS_NONE}&#34;
                )
                ns = NS_NONE

            for n, val in Fs(feat).items():
                t = tlFromTf.get(n, None)
                if t is None:
                    continue
                target = f&#34;{t}-{t + 1}&#34; if F.otype.v(n) == slotType else t
                aId = self.mkAnno(KIND_ATTR, ns, f&#34;{feat}={val}&#34;, target)

        for feat in edgeFeatures:
            ns = Es(feat).meta.get(&#34;conversionCode&#34;, NS_FROM_FEAT.get(feat, nsOrig))

            if ns is None:
                warning(
                    f&#34;Edge feature {feat} has no conversion code, &#34;
                    f&#34;defaulting to {NS_NONE}&#34;
                )
                ns = NS_NONE

            for fromNode, toNodes in Es(feat).items():
                if skipMeta and F.is_meta.v(fromNode):
                    continue
                fromT = tlFromTf.get(fromNode, None)
                if fromT is None:
                    continue
                targetFrom = (
                    f&#34;{fromT}-{fromT + 1}&#34; if F.otype.v(fromNode) == slotType else fromT
                )

                if type(toNodes) is dict:
                    for toNode, val in toNodes.items():
                        if skipMeta and F.is_meta.v(toNode):
                            continue
                        toT = tlFromTf.get(toNode, None)
                        if toT is None:
                            continue

                        targetTo = (
                            f&#34;{toT}-{toT + 1}&#34; if F.otype.v(toNode) == slotType else toT
                        )
                        target = f&#34;{targetFrom}-&gt;{targetTo}&#34;
                        aId = self.mkAnno(KIND_EDGE, ns, f&#34;{feat}={val}&#34;, target)
                else:
                    for toNode in toNodes:
                        if skipMeta and F.is_meta.v(toNode):
                            continue
                        toT = tlFromTf.get(toNode, None)
                        if toT is None:
                            continue
                        target = f&#34;{fromT}-&gt;{toT}&#34;
                        aId = self.mkAnno(KIND_EDGE, ns, feat, target)

        extra = {}
        extra.update(self.extra)

        for n, value in extra.items():
            t = tlFromTf[n]
            target = f&#34;{t}-{t + 1}&#34; if F.otype.v(n) == slotType else t
            aId = self.mkAnno(KIND_ANNO, NS_TT, str(value), target)

        if len(wrongTargets):
            print(f&#34;WARNING: wrong targets, {len(wrongTargets)}x&#34;)
            for otype, start, end in wrongTargets:
                sega = text[start]
                segb = text[end - 1]
                print(f&#34;{otype:&gt;20} {start:&gt;6} `{sega}` &gt; {end - 1} `{segb}`&#34;)

    def writeAll(self):
        app = self.app
        info = self.info
        warning = self.warning
        text = self.text
        annos = self.annos

        baseDir = self.repoLocation
        relative = app.context.relative
        version = app.version
        wRelative = REL_RE.sub(f&#34;/{TT_NAME}/{version}/&#34;, relative, count=1)
        resultDir = f&#34;{baseDir}{wRelative}&#34;
        textFile = f&#34;{resultDir}/text.json&#34;

        self.textFile = textFile

        initTree(resultDir, fresh=True)

        with open(textFile, &#34;w&#34;) as fh:
            json.dump(dict(_ordered_segments=text), fh, ensure_ascii=False, indent=1)

        info(f&#34;Text file: {len(text):&gt;7} segments to {textFile}&#34;, tm=False)

        annoStore = {}

        for kind, aId, ns, body, target in annos:
            annoStore[aId] = (kind, ns, body, target)

        aIdSorted = sorted(annoStore.keys())

        annoFile = f&#34;{resultDir}/anno.tsv&#34;

        if False:
            with open(annoFile, &#34;w&#34;) as fh:
                for aId in aIdSorted:
                    (kind, ns, body, target) = annoStore[aId]
                    fh.write(f&#34;{aId}\t{kind}\t{ns}\t{body}\t{target}\n&#34;)

        thisAnnoStore = {}
        thisA = 1
        annoFiles = []
        self.annoFiles = annoFiles

        LIMIT = 400000
        j = 0
        total = 0

        def writeThis():
            annoFile = f&#34;{resultDir}/anno-{thisA:&gt;01}.json&#34;
            annoFiles.append(annoFile)

            with open(annoFile, &#34;w&#34;) as fh:
                json.dump(thisAnnoStore, fh, ensure_ascii=False, indent=1)

            info(f&#34;{j:&gt;6} annotations written to {annoFile}&#34;)

        for aId in aIdSorted:
            if j &gt;= LIMIT:
                writeThis()
                thisA += 1
                thisAnnoStore = {}
                total += j
                j = 0

            thisAnnoStore[aId] = annoStore[aId]
            j += 1

        if len(thisAnnoStore):
            writeThis()
            total += j

        if len(annos) != total:
            info(f&#34;Sum of batches : {total:&gt;8}&#34;, tm=False)
            info(f&#34;All annotations: {len(annoStore):&gt;8}&#34;, tm=False)
            warning(&#34;Mismatch in number of annotations&#34;, tm=False)
        info(
            f&#34;Anno files: {len(annos):&gt;7} annotations to {len(annoFiles)} files&#34;,
            tm=False,
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.convert.watm_translatin.WATM.makeAnno"><code class="name flex">
<span>def <span class="ident">makeAnno</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm_translatin.py#L148-L272" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeAnno(self):
    E = self.E
    Es = self.Es
    F = self.F
    Fs = self.Fs
    nodeFeatures = self.nodeFeatures
    edgeFeatures = self.edgeFeatures
    slotType = self.slotType
    otypes = self.otypes
    nsOrig = self.nsOrig
    skipMeta = self.skipMeta
    warning = self.warning

    tlFromTf = self.tlFromTf

    annos = []
    text = self.text
    self.annos = annos

    wrongTargets = []

    for otype in otypes:
        isSlot = otype == slotType

        for n in F.otype.s(otype):
            if isSlot:
                if skipMeta and F.is_meta.v(n):
                    continue
                t = tlFromTf[n]
                target = f&#34;{t}-{t + 1}&#34;
                self.mkAnno(KIND_NODE, NS_TF, n, target)
            else:
                ws = E.oslots.s(n)
                if skipMeta and (F.is_meta.v(ws[0]) or F.is_meta.v(ws[-1])):
                    continue
                start = tlFromTf[ws[0]]
                end = tlFromTf[ws[-1]]
                if end &lt; start:
                    wrongTargets.append((otype, start, end))

                target = f&#34;{start}-{end + 1}&#34;
                aId = (
                    self.mkAnno(KIND_PI, nsOrig, otype[1:], target)
                    if otype.startswith(&#34;?&#34;)
                    else self.mkAnno(
                        KIND_ELEM, NS_FROM_OTYPE.get(otype, nsOrig), otype, target
                    )
                )
                tlFromTf[n] = aId
                self.mkAnno(KIND_NODE, NS_TF, n, aId)

    for feat in nodeFeatures:
        ns = Fs(feat).meta.get(&#34;conversionCode&#34;, NS_FROM_FEAT.get(feat, nsOrig))

        if ns is None:
            warning(
                f&#34;Node feature {feat} has no namespace, &#34;
                f&#34;defaulting to {NS_NONE}&#34;
            )
            ns = NS_NONE

        for n, val in Fs(feat).items():
            t = tlFromTf.get(n, None)
            if t is None:
                continue
            target = f&#34;{t}-{t + 1}&#34; if F.otype.v(n) == slotType else t
            aId = self.mkAnno(KIND_ATTR, ns, f&#34;{feat}={val}&#34;, target)

    for feat in edgeFeatures:
        ns = Es(feat).meta.get(&#34;conversionCode&#34;, NS_FROM_FEAT.get(feat, nsOrig))

        if ns is None:
            warning(
                f&#34;Edge feature {feat} has no conversion code, &#34;
                f&#34;defaulting to {NS_NONE}&#34;
            )
            ns = NS_NONE

        for fromNode, toNodes in Es(feat).items():
            if skipMeta and F.is_meta.v(fromNode):
                continue
            fromT = tlFromTf.get(fromNode, None)
            if fromT is None:
                continue
            targetFrom = (
                f&#34;{fromT}-{fromT + 1}&#34; if F.otype.v(fromNode) == slotType else fromT
            )

            if type(toNodes) is dict:
                for toNode, val in toNodes.items():
                    if skipMeta and F.is_meta.v(toNode):
                        continue
                    toT = tlFromTf.get(toNode, None)
                    if toT is None:
                        continue

                    targetTo = (
                        f&#34;{toT}-{toT + 1}&#34; if F.otype.v(toNode) == slotType else toT
                    )
                    target = f&#34;{targetFrom}-&gt;{targetTo}&#34;
                    aId = self.mkAnno(KIND_EDGE, ns, f&#34;{feat}={val}&#34;, target)
            else:
                for toNode in toNodes:
                    if skipMeta and F.is_meta.v(toNode):
                        continue
                    toT = tlFromTf.get(toNode, None)
                    if toT is None:
                        continue
                    target = f&#34;{fromT}-&gt;{toT}&#34;
                    aId = self.mkAnno(KIND_EDGE, ns, feat, target)

    extra = {}
    extra.update(self.extra)

    for n, value in extra.items():
        t = tlFromTf[n]
        target = f&#34;{t}-{t + 1}&#34; if F.otype.v(n) == slotType else t
        aId = self.mkAnno(KIND_ANNO, NS_TT, str(value), target)

    if len(wrongTargets):
        print(f&#34;WARNING: wrong targets, {len(wrongTargets)}x&#34;)
        for otype, start, end in wrongTargets:
            sega = text[start]
            segb = text[end - 1]
            print(f&#34;{otype:&gt;20} {start:&gt;6} `{sega}` &gt; {end - 1} `{segb}`&#34;)</code></pre>
</details>
</dd>
<dt id="tf.convert.watm_translatin.WATM.makeText"><code class="name flex">
<span>def <span class="ident">makeText</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm_translatin.py#L100-L127" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeText(self):
    F = self.F
    slotType = self.slotType
    skipMeta = self.skipMeta

    text = []
    tlFromTf = {}

    self.text = text
    self.tlFromTf = tlFromTf

    for s in F.otype.s(slotType):
        if skipMeta and F.is_meta.v(s):
            continue

        value = F.rstr.v(s)
        if value is None:
            value = F.str.v(s) or &#34;&#34;

        after = F.rafter.v(s)
        if after is None:
            after = F.after.v(s) or &#34;&#34;

        value = f&#34;{value}{after}&#34;

        text.append(value)
        t = len(text) - 1
        tlFromTf[s] = t</code></pre>
</details>
</dd>
<dt id="tf.convert.watm_translatin.WATM.mkAnno"><code class="name flex">
<span>def <span class="ident">mkAnno</span></span>(<span>self, kind, ns, body, target)</span>
</code></dt>
<dd>
<div class="desc"><p>Make an annotation and return its id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code></dt>
<dd>The kind of annotation.</dd>
<dt><strong><code>ns</code></strong> :&ensp;<code>string</code></dt>
<dd>The namespace of the annotation.</dd>
<dt><strong><code>body</code></strong> :&ensp;<code>string</code></dt>
<dd>The body of the annotation.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>string</code>
or <code>tuple</code> of <code>strings</code></dt>
<dd>The target of the annotation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm_translatin.py#L129-L146" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mkAnno(self, kind, ns, body, target):
    &#34;&#34;&#34;Make an annotation and return its id.

    Parameters
    ----------
    kind: string
        The kind of annotation.
    ns: string
        The namespace of the annotation.
    body: string
        The body of the annotation.
    target: string  or tuple of strings
        The target of the annotation.
    &#34;&#34;&#34;
    annos = self.annos
    aId = f&#34;a{len(annos):&gt;08}&#34;
    annos.append((kind, aId, ns, body, target))
    return aId</code></pre>
</details>
</dd>
<dt id="tf.convert.watm_translatin.WATM.writeAll"><code class="name flex">
<span>def <span class="ident">writeAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm_translatin.py#L274-L352" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def writeAll(self):
    app = self.app
    info = self.info
    warning = self.warning
    text = self.text
    annos = self.annos

    baseDir = self.repoLocation
    relative = app.context.relative
    version = app.version
    wRelative = REL_RE.sub(f&#34;/{TT_NAME}/{version}/&#34;, relative, count=1)
    resultDir = f&#34;{baseDir}{wRelative}&#34;
    textFile = f&#34;{resultDir}/text.json&#34;

    self.textFile = textFile

    initTree(resultDir, fresh=True)

    with open(textFile, &#34;w&#34;) as fh:
        json.dump(dict(_ordered_segments=text), fh, ensure_ascii=False, indent=1)

    info(f&#34;Text file: {len(text):&gt;7} segments to {textFile}&#34;, tm=False)

    annoStore = {}

    for kind, aId, ns, body, target in annos:
        annoStore[aId] = (kind, ns, body, target)

    aIdSorted = sorted(annoStore.keys())

    annoFile = f&#34;{resultDir}/anno.tsv&#34;

    if False:
        with open(annoFile, &#34;w&#34;) as fh:
            for aId in aIdSorted:
                (kind, ns, body, target) = annoStore[aId]
                fh.write(f&#34;{aId}\t{kind}\t{ns}\t{body}\t{target}\n&#34;)

    thisAnnoStore = {}
    thisA = 1
    annoFiles = []
    self.annoFiles = annoFiles

    LIMIT = 400000
    j = 0
    total = 0

    def writeThis():
        annoFile = f&#34;{resultDir}/anno-{thisA:&gt;01}.json&#34;
        annoFiles.append(annoFile)

        with open(annoFile, &#34;w&#34;) as fh:
            json.dump(thisAnnoStore, fh, ensure_ascii=False, indent=1)

        info(f&#34;{j:&gt;6} annotations written to {annoFile}&#34;)

    for aId in aIdSorted:
        if j &gt;= LIMIT:
            writeThis()
            thisA += 1
            thisAnnoStore = {}
            total += j
            j = 0

        thisAnnoStore[aId] = annoStore[aId]
        j += 1

    if len(thisAnnoStore):
        writeThis()
        total += j

    if len(annos) != total:
        info(f&#34;Sum of batches : {total:&gt;8}&#34;, tm=False)
        info(f&#34;All annotations: {len(annoStore):&gt;8}&#34;, tm=False)
        warning(&#34;Mismatch in number of annotations&#34;, tm=False)
    info(
        f&#34;Anno files: {len(annos):&gt;7} annotations to {len(annoFiles)} files&#34;,
        tm=False,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tf.convert.watm_translatin.WATMS"><code class="flex name class">
<span>class <span class="ident">WATMS</span></span>
<span>(</span><span>org, repo, backend)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm_translatin.py#L355-L390" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class WATMS:
    def __init__(self, org, repo, backend):
        self.org = org
        self.repo = repo
        self.backend = backend

        repoDir = ex(f&#34;~/{backend}/{org}/{repo}&#34;)
        tfDir = f&#34;{repoDir}/tf&#34;
        docs = dirContents(tfDir)[1]
        console(f&#34;Found {len(docs)} docs in {tfDir}&#34;)
        self.docs = docs

    def produce(self, doc=None):
        org = self.org
        repo = self.repo
        backend = self.backend
        docs = self.docs

        chosenDoc = doc

        for doc in sorted(docs, key=lambda x: (x[0], int(x[1:]))):
            if chosenDoc is not None and chosenDoc != doc:
                continue

            console(f&#34;{doc:&gt;5} ... &#34;, newline=False)
            A = use(
                f&#34;{org}/{repo}:clone&#34;,
                relative=f&#34;tf/{doc}&#34;,
                checkout=&#34;clone&#34;,
                backend=backend,
                silent=DEEP,
            )
            WA = WATM(A)
            WA.makeText()
            WA.makeAnno()
            WA.writeAll()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.convert.watm_translatin.WATMS.produce"><code class="name flex">
<span>def <span class="ident">produce</span></span>(<span>self, doc=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm_translatin.py#L367-L390" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def produce(self, doc=None):
    org = self.org
    repo = self.repo
    backend = self.backend
    docs = self.docs

    chosenDoc = doc

    for doc in sorted(docs, key=lambda x: (x[0], int(x[1:]))):
        if chosenDoc is not None and chosenDoc != doc:
            continue

        console(f&#34;{doc:&gt;5} ... &#34;, newline=False)
        A = use(
            f&#34;{org}/{repo}:clone&#34;,
            relative=f&#34;tf/{doc}&#34;,
            checkout=&#34;clone&#34;,
            backend=backend,
            silent=DEEP,
        )
        WA = WATM(A)
        WA.makeText()
        WA.makeAnno()
        WA.writeAll()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.convert" href="index.html">tf.convert</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.convert.watm_translatin.WATM" href="#tf.convert.watm_translatin.WATM">WATM</a></code></h4>
<ul class="">
<li><code><a title="tf.convert.watm_translatin.WATM.makeAnno" href="#tf.convert.watm_translatin.WATM.makeAnno">makeAnno</a></code></li>
<li><code><a title="tf.convert.watm_translatin.WATM.makeText" href="#tf.convert.watm_translatin.WATM.makeText">makeText</a></code></li>
<li><code><a title="tf.convert.watm_translatin.WATM.mkAnno" href="#tf.convert.watm_translatin.WATM.mkAnno">mkAnno</a></code></li>
<li><code><a title="tf.convert.watm_translatin.WATM.writeAll" href="#tf.convert.watm_translatin.WATM.writeAll">writeAll</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tf.convert.watm_translatin.WATMS" href="#tf.convert.watm_translatin.WATMS">WATMS</a></code></h4>
<ul class="">
<li><code><a title="tf.convert.watm_translatin.WATMS.produce" href="#tf.convert.watm_translatin.WATMS.produce">produce</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>