<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.convert.tei API documentation</title>
<meta name="description" content="TEI import â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.convert.tei</code></h1>
</header>
<section id="section-intro">
<h1 id="tei-import">TEI import</h1>
<p>You can convert any TEI source into TF by specifying a few details about the source.</p>
<p>Text-Fabric then invokes the <code><a title="tf.convert.walker" href="walker.html">tf.convert.walker</a></code> machinery to produce a Text-Fabric
dataset out of the source.</p>
<p>Text-Fabric knows the TEI elements, because it will read and parse the complete
TEI schema. From this the set of complex, mixed elements is distilled.</p>
<p>If the TEI source conforms to a customised TEI schema, you can pass it to the TEI
importer, and it will read it and override the generic information of the TEI elements.</p>
<p>The converter goes the extra mile: it generates a TF-app and documentation
(an <em>about.md</em> file and a <em>transcription.md</em> file), in such a way that the Text-Fabric
browser is instantly usable.</p>
<p>The TEI conversion is rather straightforward because of some conventions
that cannot be changed.</p>
<h2 id="tasks">Tasks</h2>
<p>We have the following conversion tasks:</p>
<ol>
<li><code>check</code>: makes and inventory of all XML elements and attributes used.</li>
<li><code>convert</code>: produces actual TF files by converting XML files.</li>
<li><code>load</code>: loads the generated TF for the first time, by which the precomputation
step is triggered. During precomputation some checks are performed. Once this
has succeeded, we have a workable Text-Fabric dataset.</li>
<li><code>app</code>: creates or updates a corpus specific TF-app with minimal sensible settings,
plus basic documentation.</li>
<li><code>apptoken</code>: updates a corpus specific TF-app from a character-based dataset
to a token-based dataset.</li>
<li><code>browse</code>: starts the text-fabric browser on the newly created dataset.</li>
</ol>
<p>Tasks can be run by passing any choice of task keywords to the
<code><a title="tf.convert.tei.TEI.task" href="#tf.convert.tei.TEI.task">TEI.task()</a></code> method.</p>
<h2 id="flags">Flags</h2>
<p>We have one flag:</p>
<ol>
<li><code>test</code>: only converts those files in the input that are named in a test set.</li>
</ol>
<p>The test set is passed as argument to the <code><a title="tf.convert.tei.TEI" href="#tf.convert.tei.TEI">TEI</a></code> constructur.</p>
<p>The <code>test</code> flag is passed to the <code><a title="tf.convert.tei.TEI.task" href="#tf.convert.tei.TEI.task">TEI.task()</a></code> method.</p>
<h2 id="usage">Usage</h2>
<p>It is intended that you call this converter in a script.</p>
<p>In that script you can define auxiliary Python functions and pass them
to the converter. The <code><a title="tf.convert.tei.TEI" href="#tf.convert.tei.TEI">TEI</a></code> class has some hooks where such functions
can be plugged in.</p>
<p>Here you can also define a test set, in case you want to experiment with the
conversion.</p>
<p>Last, but not least, you can assemble all the input parameters needed to
get the conversion off the ground.</p>
<p>The resulting script will look like
<a href="https://github.com/annotation/text-fabric/blob/master/tf/convert/tfFromTeiExample.py">tfFromTeiExample.py</a>
which you can use as a starting point.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L1-L2733" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# TEI import

You can convert any TEI source into TF by specifying a few details about the source.

Text-Fabric then invokes the `tf.convert.walker` machinery to produce a Text-Fabric
dataset out of the source.

Text-Fabric knows the TEI elements, because it will read and parse the complete
TEI schema. From this the set of complex, mixed elements is distilled.

If the TEI source conforms to a customised TEI schema, you can pass it to the TEI
importer, and it will read it and override the generic information of the TEI elements.

The converter goes the extra mile: it generates a TF-app and documentation
(an *about.md* file and a *transcription.md* file), in such a way that the Text-Fabric
browser is instantly usable.

The TEI conversion is rather straightforward because of some conventions
that cannot be changed.

## Tasks

We have the following conversion tasks:

1.  `check`: makes and inventory of all XML elements and attributes used.
1.  `convert`: produces actual TF files by converting XML files.
1.  `load`: loads the generated TF for the first time, by which the precomputation
    step is triggered. During precomputation some checks are performed. Once this
    has succeeded, we have a workable Text-Fabric dataset.
1.  `app`: creates or updates a corpus specific TF-app with minimal sensible settings,
    plus basic documentation.
1.  `apptoken`: updates a corpus specific TF-app from a character-based dataset
    to a token-based dataset.
1.  `browse`: starts the text-fabric browser on the newly created dataset.

Tasks can be run by passing any choice of task keywords to the
`TEI.task()` method.

## Flags

We have one flag:

1. `test`: only converts those files in the input that are named in a test set.

The test set is passed as argument to the `TEI` constructur.

The `test` flag is passed to the `TEI.task()` method.

## Usage

It is intended that you call this converter in a script.

In that script you can define auxiliary Python functions and pass them
to the converter. The `TEI` class has some hooks where such functions
can be plugged in.

Here you can also define a test set, in case you want to experiment with the
conversion.

Last, but not least, you can assemble all the input parameters needed to
get the conversion off the ground.

The resulting script will look like
[tfFromTeiExample.py](https://github.com/annotation/text-fabric/blob/master/tf/convert/tfFromTeiExample.py)
which you can use as a starting point.
&#34;&#34;&#34;

import sys
import collections
import re
from textwrap import dedent
from io import BytesIO
from subprocess import run

import yaml
from lxml import etree
from ..parameters import BRANCH_DEFAULT_NEW
from ..fabric import Fabric
from ..core.helpers import console
from ..convert.walker import CV
from ..core.helpers import mergeDict
from ..core.files import (
    abspath,
    expanduser as ex,
    unexpanduser as ux,
    getLocation,
    initTree,
    dirNm,
    dirExists,
    fileExists,
    fileCopy,
    fileRemove,
    scanDir,
)

from ..tools.xmlschema import Analysis


CSS_REND = dict(
    h1=(
        &#34;heading of level 1&#34;,
        dedent(
            &#34;&#34;&#34;
        font-size: xx-large;
        font-weight: bold;
        margin-top: 3rem;
        margin-bottom: 1rem;
        &#34;&#34;&#34;
        ),
    ),
    h2=(
        &#34;heading of level 2&#34;,
        dedent(
            &#34;&#34;&#34;
        font-size: x-large;
        font-weight: bold;
        margin-top: 2rem;
        margin-bottom: 1rem;
        &#34;&#34;&#34;
        ),
    ),
    h3=(
        &#34;heading of level 3&#34;,
        dedent(
            &#34;&#34;&#34;
        font-size: large;
        font-weight: bold;
        margin-top: 1rem;
        margin-bottom: 0.5rem;
        &#34;&#34;&#34;
        ),
    ),
    h4=(
        &#34;heading of level 4&#34;,
        dedent(
            &#34;&#34;&#34;
        font-size: large;
        font-style: italic;
        margin-top: 1rem;
        margin-bottom: 0.5rem;
        &#34;&#34;&#34;
        ),
    ),
    h5=(
        &#34;heading of level 5&#34;,
        dedent(
            &#34;&#34;&#34;
        font-size: medium;
        font-weight: bold;
        font-variant: small-caps;
        margin-top: 0.5rem;
        margin-bottom: 0.25rem;
        &#34;&#34;&#34;
        ),
    ),
    h6=(
        &#34;heading of level 6&#34;,
        dedent(
            &#34;&#34;&#34;
        font-size: medium;
        font-weight: normal;
        font-variant: small-caps;
        margin-top: 0.25rem;
        margin-bottom: 0.125rem;
        &#34;&#34;&#34;
        ),
    ),
    italic=(
        &#34;cursive font style&#34;,
        dedent(
            &#34;&#34;&#34;
        font-style: italic;
        &#34;&#34;&#34;
        ),
    ),
    bold=(
        &#34;bold font weight&#34;,
        dedent(
            &#34;&#34;&#34;
        font-weight: bold;
        &#34;&#34;&#34;
        ),
    ),
    underline=(
        &#34;underlined text&#34;,
        dedent(
            &#34;&#34;&#34;
        text-decoration: underline;
        &#34;&#34;&#34;
        ),
    ),
    center=(
        &#34;horizontally centered text&#34;,
        dedent(
            &#34;&#34;&#34;
        text-align: center;
        &#34;&#34;&#34;
        ),
    ),
    large=(
        &#34;large font size&#34;,
        dedent(
            &#34;&#34;&#34;
        font-size: large;
        &#34;&#34;&#34;
        ),
    ),
    spaced=(
        &#34;widely spaced between characters&#34;,
        dedent(
            &#34;&#34;&#34;
        letter-spacing: .2rem;
        &#34;&#34;&#34;
        ),
    ),
    margin=(
        &#34;in the margin&#34;,
        dedent(
            &#34;&#34;&#34;
        position: relative;
        top: -0.3em;
        font-weight: bold;
        color: #0000ee;
        &#34;&#34;&#34;
        ),
    ),
    above=(
        &#34;above the line&#34;,
        dedent(
            &#34;&#34;&#34;
        position: relative;
        top: -0.3em;
        &#34;&#34;&#34;
        ),
    ),
    below=(
        &#34;below the line&#34;,
        dedent(
            &#34;&#34;&#34;
        position: relative;
        top: 0.3em;
        &#34;&#34;&#34;
        ),
    ),
    small_caps=(
        &#34;small-caps font variation&#34;,
        dedent(
            &#34;&#34;&#34;
        font-variant: small-caps;
        &#34;&#34;&#34;
        ),
    ),
    sub=(
        &#34;as subscript&#34;,
        dedent(
            &#34;&#34;&#34;
        vertical-align: sub;
        font-size: small;
        &#34;&#34;&#34;
        ),
    ),
    super=(
        &#34;as superscript&#34;,
        dedent(
            &#34;&#34;&#34;
        vertical-align: super;
        font-size: small;
        &#34;&#34;&#34;
        ),
    ),
)
CSS_REND_ALIAS = dict(
    italic=&#34;italics i&#34;,
    bold=&#34;b&#34;,
    underline=&#34;ul&#34;,
    spaced=&#34;spat&#34;,
    small_caps=&#34;smallcaps sc&#34;,
    super=&#34;sup&#34;,
)


KNOWN_RENDS = set()
REND_DESC = {}

NEST = &#34;nest&#34;
SLOT = &#34;slot&#34;
WORD = &#34;word&#34;
CHAR = &#34;char&#34;
TOKEN = &#34;token&#34;

FOLDER = &#34;folder&#34;
FILE = &#34;file&#34;
CHAPTER = &#34;chapter&#34;
CHUNK = &#34;chunk&#34;


def makeCssInfo():
    rends = &#34;&#34;

    for (rend, (description, css)) in sorted(CSS_REND.items()):
        aliases = CSS_REND_ALIAS.get(rend, &#34;&#34;)
        aliases = sorted(set(aliases.split()) | {rend})
        for alias in aliases:
            KNOWN_RENDS.add(alias)
            REND_DESC[alias] = description
        selector = &#34;,&#34;.join(f&#34;.r_{alias}&#34; for alias in aliases)
        contribution = f&#34;\n{selector} {{{css}}}\n&#34;
        rends += contribution

    return rends


SECTION_MODELS = dict(
    I=dict(levels=(list, [FOLDER, FILE, CHUNK])),
    II=dict(
        levels=(list, [CHAPTER, CHUNK]),
        element=(str, &#34;head&#34;),
        attributes=(dict, {}),
    ),
)
SECTION_MODEL_DEFAULT = &#34;I&#34;


def checkSectionModel(sectionModel):
    if sectionModel is None:
        model = SECTION_MODEL_DEFAULT
        console(f&#34;WARNING: No section model specified. Assuming model {model}.&#34;)
        properties = {k: v[1] for (k, v) in SECTION_MODELS[model].items()}
        return dict(model=model, properties=properties)

    if type(sectionModel) is str:
        if sectionModel in SECTION_MODELS:
            sectionModel = dict(model=sectionModel)
        else:
            console(f&#34;WARNING: unknown section model: {sectionModel}&#34;)
            return False

    elif type(sectionModel) is not dict:
        console(
            f&#34;ERROR: Section model must be a dict. You passed a {type(sectionModel)}&#34;
        )
        return False

    model = sectionModel.get(&#34;model&#34;, None)
    if model is None:
        model = SECTION_MODEL_DEFAULT
        console(f&#34;WARNING: No section model specified. Assuming model {model}.&#34;)
        sectionModel[&#34;model&#34;] = model
    if model not in SECTION_MODELS:
        console(f&#34;WARNING: unknown section model: {sectionModel}&#34;)
        return False

    properties = {k: v for (k, v) in sectionModel.items() if k != &#34;model&#34;}
    modelProperties = SECTION_MODELS[model]

    good = True
    delKeys = []

    for (k, v) in properties.items():
        if k not in modelProperties:
            console(f&#34;WARNING: ignoring unknown model property {k}={v}&#34;)
            delKeys.append(k)
        elif type(v) is not modelProperties[k][0]:
            console(
                f&#34;ERROR: property {k} should have type {modelProperties[k][0]}&#34;
                f&#34; but {v} has type {type(v)}&#34;
            )
            good = False
    if good:
        for k in delKeys:
            del properties[k]

    for (k, v) in modelProperties.items():
        if k not in properties:
            console(f&#34;WARNING: model property {k} not specified, taking default {v[1]}&#34;)
            properties[k] = v[1]

    if not good:
        return False

    return dict(model=model, properties=properties)


def tweakTrans(template, wordAsSlot, tokenBased, sectionModel, sectionProperties):
    if wordAsSlot:
        slot = WORD
        slotc = &#34;Word&#34;
        slotf = &#34;words&#34;
        xslot = &#34;`word`&#34;
    else:
        slotc = &#34;Char&#34;
        slot = CHAR
        slotf = &#34;characters&#34;
        xslot = &#34;`char` and `word`&#34;
    if tokenBased:
        slot = TOKEN
        slotc = &#34;Token&#34;
        slotf = &#34;tokens&#34;
        xslot = &#34;`token`&#34;
        tokenGen = dedent(
            &#34;&#34;&#34;
            Tokens and sentence boundaries have been generated by a Natural Language
            Pipeline, such as Spacy.
            &#34;&#34;&#34;
        )
        tokenWord = &#34;token&#34;
        hasToken = &#34;Yes&#34;
    else:
        tokenGen = &#34;&#34;
        tokenWord = &#34;word&#34;
        hasToken = &#34;No&#34;

    levelNames = sectionProperties[&#34;levels&#34;]

    if sectionModel == &#34;II&#34;:
        nLevels = &#34;2&#34;
        chapterSection = levelNames[0]
        chunkSection = levelNames[1]
        head = sectionProperties[&#34;element&#34;]
        attributes = sectionProperties[&#34;attributes&#34;]
        propertiesRaw = repr(sectionProperties)
        properties = (
            &#34;&#34;.join(
                f&#34;\t*\t`{att}` = `{val}`\n&#34; for (att, val) in sorted(attributes.items())
            )
            if attributes
            else &#34;\t*\t*no attribute properties*\n&#34;
        )
    else:
        nLevels = &#34;3&#34;
        folderSection = levelNames[0]
        fileSection = levelNames[1]
        chunkSection = levelNames[2]

    rendDesc = &#34;\n&#34;.join(
        f&#34;`{val}` | {desc}&#34; for (val, desc) in sorted(REND_DESC.items())
    )
    modelKeepRe = re.compile(rf&#34;Â«(?:begin|end)Model{sectionModel}Â»&#34;)
    modelRemoveRe = re.compile(r&#34;Â«beginModel([^Â»]+)Â».*?Â«endModel\1Â»&#34;, re.S)
    slotKeepRe = re.compile(rf&#34;Â«(?:begin|end)Slot{slot}Â»&#34;)
    slotRemoveRe = re.compile(r&#34;Â«beginSlot([^Â»]+)Â».*?Â«endSlot\1Â»&#34;, re.S)
    tokenKeepRe = re.compile(rf&#34;Â«(?:begin|end)Token{hasToken}Â»&#34;)
    tokenRemoveRe = re.compile(r&#34;Â«beginToken([^Â»]+)Â».*?Â«endToken\1Â»&#34;, re.S)

    skipVars = re.compile(r&#34;Â«[^Â»]+Â»&#34;)

    text = (
        template.replace(&#34;Â«slotÂ»&#34;, slot)
        .replace(&#34;Â«SlotÂ»&#34;, slotc)
        .replace(&#34;Â«slotfÂ»&#34;, slotf)
        .replace(&#34;Â«char and wordÂ»&#34;, xslot)
        .replace(&#34;Â«tokenWordÂ»&#34;, tokenWord)
        .replace(&#34;Â«token generationÂ»&#34;, tokenGen)
        .replace(&#34;Â«nLevelsÂ»&#34;, nLevels)
        .replace(&#34;Â«sectionModelÂ»&#34;, sectionModel)
        .replace(&#34;Â«rendDescÂ»&#34;, rendDesc)
    )
    if sectionModel == &#34;II&#34;:
        text = (
            text.replace(&#34;Â«headÂ»&#34;, head)
            .replace(&#34;Â«propertiesÂ»&#34;, properties)
            .replace(&#34;Â«propertiesRawÂ»&#34;, propertiesRaw)
            .replace(&#34;Â«chapterÂ»&#34;, chapterSection)
            .replace(&#34;Â«chunkÂ»&#34;, chunkSection)
        )
    else:
        text = (
            text.replace(&#34;Â«folderÂ»&#34;, folderSection)
            .replace(&#34;Â«fileÂ»&#34;, fileSection)
            .replace(&#34;Â«chunkÂ»&#34;, chunkSection)
        )

    text = tokenKeepRe.sub(&#34;&#34;, text)
    text = tokenRemoveRe.sub(&#34;&#34;, text)
    text = modelKeepRe.sub(&#34;&#34;, text)
    text = modelRemoveRe.sub(&#34;&#34;, text)
    text = slotKeepRe.sub(&#34;&#34;, text)
    text = slotRemoveRe.sub(&#34;&#34;, text)

    text = skipVars.sub(&#34;&#34;, text)
    return text


class TEI:
    def __init__(
        self,
        sourceVersion=&#34;0.1&#34;,
        schema=None,
        testSet=set(),
        wordAsSlot=True,
        sectionModel=None,
        generic={},
        transform=None,
        tfVersion=&#34;0.1&#34;,
        appConfig={},
        docMaterial={},
        force=False,
    ):
        &#34;&#34;&#34;Converts TEI to TF.

        For documentation of the resulting encoding, read the
        [transcription template](https://github.com/annotation/text-fabric/blob/master/tf/convert/app/transcription.md).

        Below we describe how to control the conversion machinery.

        We adopt a fair bit of &#34;convention over configuration&#34; here, in order to lessen
        the burden for the user of specifying so many details.

        Based on current directory from where the script is called,
        it defines all the ingredients to carry out
        a `tf.convert.walker` conversion of the TEI input.

        This function is assumed to work in the context of a repository,
        i.e. a directory on your computer relative to which the input directory exists,
        and various output directories: `tf`, `app`, `docs`.

        Your current directory must be at

        ```
        ~/backend/org/repo/relative
        ```

        where

        *   `~` is your home directory;
        *   `backend` is an online *backend* name,
            like `github`, `gitlab`, `git.huc.knaw.nl`;
        *   `org` is an organisation, person, or group in the backend;
        *   `repo` is a repository in the `org`.
        *   `relative` is a directory path within the repo (0 or more components)

        This is only about the directory structure on your local computer;
        it is not required that you have online incarnations of your repository
        in that backend.
        Even your local repository does not have to be a git repository.

        The only thing that matters is that the full path to your repo can be parsed
        as a sequence of *home*/*backend*/*org*/*repo*/*relative*.

        Relative to this directory the program expects and creates
        input/output directories.

        ## Input directories

        ### `tei`

        *Location of the TEI-XML sources.*

        **If it does not exist, the program aborts with an error.**

        Several levels of subfolders are assumed:

        1.  the version of the source (this could be a date string).
        2.  volumes/collections of documents. The subfolder `__ignore__` is ignored.
        3.  the TEI documents themselves, conforming to the TEI schema or some
            customisation of it.

        ### `schema`

        *Location of the TEI-XML schemas against which the sources can be validated.*

        It should be an `.xsd` file, and the parameter `schema` may specify
        its name (without extension).

        !!! note &#34;Multiple `.xsd` files&#34;
            When you started with a `.rng` file and used `tf.tools.xmlschema` to
            convert it to `xsd`, you may have got multiple `.xsd` files.
            One of them has the same base name as the original `.rng` file,
            and you should pass that name. It will import the remaining `.xsd` files,
            so do not throw them away.

        We use this file as custom TEI schema,
        but to be sure, we still analyse the full TEI schema and
        use the schema passed here as a set of overriding element definitions.

        If no schema is specified, we use the *full* TEI schema.

        ## Output directories

        ### `report`

        Directory to write the results of the `check` task to: an inventory
        of elements/attributes encountered, and possible validation errors.
        If the directory does not exist, it will be created.
        The default value is `.` (i.e. the current directory in which
        the script is invoked).

        ### `tf`

        The directory under which the text-fabric output file (with extension `.tf`)
        are placed.
        If it does not exist, it will be created.
        The tf files will be generated in a folder named by a version number,
        passed as `tfVersion`.

        ### `app` and `docs`

        Location of additional TF-app configuration and documentation files.
        If they do not exist, they will be created with some sensible default
        settings and generated documentation.
        These settings can be overriden by the parameter `appConfig`.
        Also a default `display.css` file and a logo are added.

        If such a file already exists, it will be left untouched and a generated file
        is put next to the item, with `_generated` in the file name.

        This behaviour can be modified by passing `force=True` to the initialization
        of the TEI object.

        ### `docs`

        Location of additional documentation.
        This can be generated or had-written material, or a mixture of the two.

        !!! caution &#34;Dataloss by overwriting app and docs files.
            When `force` is `False`, the app docs files will not be overwritten by
            generated files. Instead, the generated files are produced
            alongside them, with `_generated` in their names.
            These `_generated` files will be overwritten by successive runs
            of the `app` task.

            When you have generated your files, and they cannot be improved anymore,
            be sure to set `force` to `False`.

            Then you can edit the apps and docs files by hand, and they will not be
            overwritten inadvertently.

        Parameters
        ----------

        sourceVersion: string, optional &#34;0.1&#34;
            Version of the source files. This is the name of a top-level
            subfolder of the `tei` input folder.

        schema: string, optional None
            Which XML schema to be used, if not specified we fall back on full TEI.
            If specified, leave out the `.xsd` extension. The file is relative to the
            `schema` directory.

        testSet: set, optional empty
            A set of file names. If you run the conversion in test mode
            (pass `test` as argument to the `TEI.task()` method),
            only the files in the test set are converted.

        wordAsSlot: boolean, optional False
            Whether to take words as the basic entities (slots).
            If not, the characters are taken as basic entities.
        sectionModel: dict, optional {}
            If not passed, or an empty dict, section model I is assumed.
            A section model must be specified with the parameters relevant for the
            model:

            ```
            dict(
                model=&#34;II&#34;,
                levels=[&#34;chapter&#34;, &#34;chunk&#34;],
                element=&#34;head&#34;,
                attributes=dict(rend=&#34;h3&#34;),
            )
            ```

            or

            ```
            dict(
                model=&#34;I&#34;,
                levels=[&#34;folder&#34;, &#34;file&#34;, &#34;chunk&#34;],
            )
            ```

            because model I does not require the *attribute* parameter.

            For model II, the default parameters are:

            ```
            element=&#34;head&#34;
            levels=[&#34;chapter&#34;, &#34;chunk&#34;],
            attributes={}
            ```

        generic: dict, optional {}
            Metadata for all generated TF feature.

        transform: function, optional None
            If not None, a function that transforms text to text, used
            as a preprocessing step for each input xml file.

        tfVersion: string, optional &#34;0.1&#34;
            Version of the generated tf files. This is the name of a top-level
            subfolder of the `tf` output folder.

        appConfig: dict, optional {}
            Additional configuration settings, which will override the initial
            settings.

        docMaterial: dict, optional {}
            Additional documentation:

            *   under key `about`: colofon-like information;
            *   under key `trans`: additional information about the
                transcription and encoding details.

        force: boolean, optional False
            If True, the `app` task will overwrite existing files with generated
            files, and remove any files with `_generated` in the name.
            Except for the logo, which will not be overwritten.
        &#34;&#34;&#34;
        (backend, org, repo, relative) = getLocation()
        if any(s is None for s in (backend, org, repo, relative)):
            console(
                &#34;Not working in a repo: &#34;
                f&#34;backend={backend} org={org} repo={repo} relative={relative}&#34;
            )
            quit()

        console(f&#34;Working in repository {org}/{repo}{relative} in backend {backend}&#34;)

        base = ex(f&#34;~/{backend}&#34;)
        repoDir = f&#34;{base}/{org}/{repo}&#34;
        refDir = f&#34;{repoDir}{relative}&#34;
        sourceDir = f&#34;{refDir}/tei/{sourceVersion}&#34;
        reportDir = f&#34;{refDir}/report&#34;
        tfDir = f&#34;{refDir}/tf&#34;
        appDir = f&#34;{refDir}/app&#34;
        docsDir = f&#34;{refDir}/docs&#34;

        self.refDir = refDir
        self.sourceDir = sourceDir
        self.reportDir = reportDir
        self.tfDir = tfDir
        self.appDir = appDir
        self.docsDir = docsDir
        self.backend = backend
        self.org = org
        self.repo = repo
        self.relative = relative

        self.good = True

        if sourceDir is None or not dirExists(sourceDir):
            console(f&#34;Source location does not exist: {sourceDir}&#34;)
            self.good = False
            return

        self.schema = schema
        self.schemaFile = None if schema is None else f&#34;{refDir}/schema/{schema}.xsd&#34;
        self.sourceVersion = sourceVersion
        self.testMode = False
        self.testSet = testSet
        self.wordAsSlot = wordAsSlot
        sectionModel = checkSectionModel(sectionModel)
        if not sectionModel:
            self.good = False
            return

        self.sectionModel = sectionModel[&#34;model&#34;]
        sectionProperties = sectionModel.get(&#34;properties&#34;, None)
        self.sectionProperties = sectionProperties
        levelNames = sectionProperties[&#34;levels&#34;]
        self.levelNames = levelNames
        self.chunkLevel = levelNames[-1]

        if self.sectionModel == &#34;II&#34;:
            self.chapterSection = levelNames[0]
            self.chunkSection = levelNames[1]
        else:
            self.folderSection = levelNames[0]
            self.fileSection = levelNames[1]
            self.chunkSection = levelNames[2]

        self.generic = generic
        self.transform = transform
        self.tfVersion = tfVersion
        self.tfPath = f&#34;{tfDir}/{tfVersion}&#34;
        if (
            &#34;provenanceSpec&#34; not in appConfig
            or &#34;branch&#34; not in appConfig[&#34;provenanceSpec&#34;]
        ):
            appConfig.setdefault(&#34;provenanceSpec&#34;, {})[&#34;branch&#34;] = BRANCH_DEFAULT_NEW
        self.appConfig = appConfig
        self.docMaterial = docMaterial
        self.force = force
        myDir = dirNm(abspath(__file__))
        self.myDir = myDir

    @staticmethod
    def help(program):
        &#34;&#34;&#34;Print a help text to the console.

        The intended use of this module is that it is included by a conversion
        script.
        In order to give help on the command line, here is a pre-baked help text.
        Only the name of the conversion script needs to be merged in.

        Parameters
        ----------
        program: string
            The name of the program that you want to display
            in the help string.
        &#34;&#34;&#34;

        console(
            f&#34;&#34;&#34;

        Convert TEI to TF.
        There are also commands to check the TEI and to load the TF.

        python3 {program} [tasks/flags] [--help]

        --help: show this text and exit

        tasks:
            a sequence of tasks:
            check:
                just reports on the elements in the source.
            convert:
                just converts TEI to TF
            load:
                just loads the generated TF;
            app:
                just configures the TF-app for the result;
            apptoken:
                just modifies the TF-app to make it token- instead of character-based;
            browse:
                just starts the text-fabric browser on the result;

        flags:
            test:
                run in test mode
            force:
                when generating app files, overwrite previously existing app files
        &#34;&#34;&#34;
        )

    @staticmethod
    def getParser():
        &#34;&#34;&#34;Configure the lxml parser.

        See [parser options](https://lxml.de/parsing.html#parser-options).

        Returns
        -------
        object
            A configured lxml parse object.
        &#34;&#34;&#34;
        return etree.XMLParser(
            remove_blank_text=False,
            collect_ids=False,
            remove_comments=True,
            remove_pis=True,
        )

    def getValidator(self):
        &#34;&#34;&#34;Parse the schema.

        A parsed schema can be used for XML-validation.
        This will only happen during the `check` task.

        Returns
        -------
        object
            A configured lxml schema validator.
        &#34;&#34;&#34;
        schemaFile = self.schemaFile

        if schemaFile is None:
            return None

        schemaDoc = etree.parse(schemaFile)
        return etree.XMLSchema(schemaDoc)

    def getElementInfo(self):
        &#34;&#34;&#34;Analyse the schema.

        The XML schema has useful information about the XML elements that
        occur in the source. Here we extract that information and make it
        fast-accessible.

        Returns
        -------
        dict
            Keyed by element name (without namespaces), where the value
            for each name is a tuple of booleans: whether the element is simple
            or complex; whether the element allows mixed content or only pure content.
        &#34;&#34;&#34;
        schemaFile = self.schemaFile

        self.elementDefs = {}

        A = Analysis()
        A.configure(override=schemaFile)
        A.interpret()
        if not A.good:
            quit()

        self.elementDefs = {name: (typ, mixed) for (name, typ, mixed) in A.getDefs()}

    def getXML(self):
        &#34;&#34;&#34;Make an inventory of the TEI source files.

        Returns
        -------
        tuple of tuple | string
            If section model I is in force:

            The outer tuple has sorted entries corresponding to folders under the
            TEI input directory.
            Each such entry consists of the folder name and an inner tuple
            that contains the file names in that folder, sorted.

            If section model II is in force:

            It is the name of the single XML file.
        &#34;&#34;&#34;
        sourceDir = self.sourceDir
        sectionModel = self.sectionModel
        console(f&#34;Section model {sectionModel}&#34;)

        if sectionModel == &#34;I&#34;:
            testMode = self.testMode
            testSet = self.testSet

            IGNORE = &#34;__ignore__&#34;

            xmlFilesRaw = collections.defaultdict(list)

            with scanDir(sourceDir) as dh:
                for folder in dh:
                    folderName = folder.name
                    if folderName == IGNORE:
                        continue
                    if not folder.is_dir():
                        continue
                    with scanDir(f&#34;{sourceDir}/{folderName}&#34;) as fh:
                        for file in fh:
                            fileName = file.name
                            if not (
                                fileName.lower().endswith(&#34;.xml&#34;) and file.is_file()
                            ):
                                continue
                            if testMode and fileName not in testSet:
                                continue
                            xmlFilesRaw[folderName].append(fileName)

            xmlFiles = tuple(
                (folderName, tuple(sorted(fileNames)))
                for (folderName, fileNames) in sorted(xmlFilesRaw.items())
            )
            return xmlFiles

        if sectionModel == &#34;II&#34;:
            xmlFile = None
            with scanDir(sourceDir) as fh:
                for file in fh:
                    fileName = file.name
                    if not (fileName.lower().endswith(&#34;.xml&#34;) and file.is_file()):
                        continue
                    xmlFile = fileName
                    break
            return xmlFile

    def checkTask(self):
        &#34;&#34;&#34;Implementation of the &#34;check&#34; task.

        It validates the TEI, but only if a schema file has been passed explicitly
        when constructing the `TEI()` object.

        Then it makes an inventory of all elements and attributes in the TEI files.

        If tags are used in multiple namespaces, it will be reported.

        !!! caution &#34;Conflation of namespaces&#34;
            The TEI to TF conversion does constructs node types and attributes
            without taking namespaces into account.
            However, the parsing process is namespace aware.

        The inventory lists all elements and attributes, and many attribute values.
        But is represents any digit with `n`, and some attributes that contain
        ids or keywords, are reduced to the value `x`.

        This information reduction helps to get a clear overview.

        It writes reports to the `reportDir`:

        *   `errors.txt`: validation errors
        *   `elements.txt`: element/attribute inventory.
        &#34;&#34;&#34;
        if not self.good:
            return

        sourceDir = self.sourceDir
        reportDir = self.reportDir
        docsDir = self.docsDir
        sectionModel = self.sectionModel

        console(f&#34;TEI to TF checking: {ux(sourceDir)} =&gt; {ux(reportDir)}&#34;)

        kindLabels = dict(
            format=&#34;Formatting Attributes&#34;,
            keyword=&#34;Keyword Attributes&#34;,
            rest=&#34;Remaining Attributes and Elements&#34;,
        )
        getStore = lambda: collections.defaultdict(  # noqa: E731
            lambda: collections.defaultdict(collections.Counter)
        )
        analysis = {x: getStore() for x in kindLabels}
        errors = []
        tagByNs = collections.defaultdict(collections.Counter)

        parser = self.getParser()
        validator = self.getValidator()
        self.getElementInfo()
        elementDefs = self.elementDefs

        initTree(reportDir)
        initTree(docsDir)

        def analyse(root, analysis):
            FORMAT_ATTS = set(
                &#34;&#34;&#34;
                dim
                level
                place
                rend
            &#34;&#34;&#34;.strip().split()
            )

            KEYWORD_ATTS = set(
                &#34;&#34;&#34;
                facs
                form
                function
                lang
                reason
                type
                unit
                who
            &#34;&#34;&#34;.strip().split()
            )

            TRIM_ATTS = set(
                &#34;&#34;&#34;
                id
                key
                target
                value
            &#34;&#34;&#34;.strip().split()
            )

            NUM_RE = re.compile(r&#34;&#34;&#34;[0-9]&#34;&#34;&#34;, re.S)

            def nodeInfo(node):
                qName = etree.QName(node.tag)
                tag = qName.localname
                ns = qName.namespace
                atts = node.attrib

                tagByNs[tag][ns] += 1

                if len(atts) == 0:
                    kind = &#34;rest&#34;
                    analysis[kind][tag][&#34;&#34;][&#34;&#34;] += 1
                else:
                    for (kOrig, v) in atts.items():
                        k = etree.QName(kOrig).localname
                        kind = (
                            &#34;format&#34;
                            if k in FORMAT_ATTS
                            else &#34;keyword&#34;
                            if k in KEYWORD_ATTS
                            else &#34;rest&#34;
                        )
                        dest = analysis[kind]

                        if kind == &#34;rest&#34;:
                            vTrim = &#34;X&#34; if k in TRIM_ATTS else NUM_RE.sub(&#34;N&#34;, v)
                            dest[tag][k][vTrim] += 1
                        else:
                            words = v.strip().split()
                            for w in words:
                                dest[tag][k][w.strip()] += 1

                for child in node.iterchildren(tag=etree.Element):
                    nodeInfo(child)

            nodeInfo(root)

        def writeErrors():
            errorFile = f&#34;{reportDir}/errors.txt&#34;

            nErrors = 0

            with open(errorFile, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                for (xmlFile, lines) in errors:
                    fh.write(f&#34;{xmlFile}\n&#34;)
                    for line in lines:
                        fh.write(line)
                        nErrors += 1
                    fh.write(&#34;\n&#34;)

            console(
                f&#34;{nErrors} error(s) in {len(errors)} file(s) written to {errorFile}&#34;
            )

        def writeNamespaces():
            errorFile = f&#34;{reportDir}/namespaces.txt&#34;

            nErrors = 0

            nTags = len(tagByNs)

            with open(errorFile, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                for (tag, nsInfo) in sorted(
                    tagByNs.items(), key=lambda x: (-len(x[1]), x[0])
                ):
                    label = &#34;OK&#34;
                    nNs = len(nsInfo)
                    if nNs &gt; 1:
                        nErrors += 1
                        label = &#34;XX&#34;

                    for (ns, amount) in sorted(
                        nsInfo.items(), key=lambda x: (-x[1], x[0])
                    ):
                        fh.write(
                            f&#34;{label} {nNs:&gt;2} namespace for &#34;
                            f&#34;{tag:&lt;16} : {amount:&gt;5}x {ns}\n&#34;
                        )

            console(
                f&#34;{nTags} tags of which {nErrors} with multiple namespaces &#34;
                f&#34;written to {errorFile}&#34;
            )

        def writeReport():
            reportFile = f&#34;{reportDir}/elements.txt&#34;
            with open(reportFile, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                fh.write(
                    &#34;Inventory of tags and attributes in the source XML file(s).\n&#34;
                    &#34;Contains the following sections:\n&#34;
                )
                for label in kindLabels.values():
                    fh.write(f&#34;\t{label}\n&#34;)
                fh.write(&#34;\n\n&#34;)

                infoLines = 0

                def writeAttInfo(tag, att, attInfo):
                    nonlocal infoLines
                    nl = &#34;&#34; if tag == &#34;&#34; else &#34;\n&#34;
                    tagRep = &#34;&#34; if tag == &#34;&#34; else f&#34;&lt;{tag}&gt;&#34;
                    attRep = &#34;&#34; if att == &#34;&#34; else f&#34;{att}=&#34;
                    atts = sorted(attInfo.items())
                    (val, amount) = atts[0]
                    if tag:
                        (typ, mixed) = elementDefs[tag]
                        extraInfo = f&#34;{&#39;mixed&#39; if mixed else &#39;pure &#39;}: &#34;
                    else:
                        extraInfo = &#34;&#34;
                    fh.write(
                        f&#34;{nl}\t{extraInfo}{tagRep:&lt;18} &#34;
                        f&#34;{attRep:&lt;18} {amount:&gt;5}x {val}\n&#34;
                    )
                    infoLines += 1
                    for (val, amount) in atts[1:]:
                        fh.write(
                            f&#34;&#34;&#34;\t{&#39;&#39;:&lt;7}{&#39;&#39;:&lt;18} {&#39;&#34;&#39;:&lt;18} {amount:&gt;5}x {val}\n&#34;&#34;&#34;
                        )
                        infoLines += 1

                def writeTagInfo(tag, tagInfo):
                    nonlocal infoLines
                    tags = sorted(tagInfo.items())
                    (att, attInfo) = tags[0]
                    writeAttInfo(tag, att, attInfo)
                    infoLines += 1
                    for (att, attInfo) in tags[1:]:
                        writeAttInfo(&#34;&#34;, att, attInfo)

                for (kind, label) in kindLabels.items():
                    fh.write(f&#34;\n{label}\n&#34;)
                    for (tag, tagInfo) in sorted(analysis[kind].items()):
                        writeTagInfo(tag, tagInfo)

            console(f&#34;{infoLines} info line(s) written to {reportFile}&#34;)

        def writeDoc():
            teiUrl = &#34;https://tei-c.org/release/doc/tei-p5-doc/en/html&#34;
            elUrlPrefix = f&#34;{teiUrl}/ref-&#34;
            attUrlPrefix = f&#34;{teiUrl}/REF-ATTS.html#&#34;
            docFile = f&#34;{docsDir}/elements.md&#34;
            with open(docFile, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                fh.write(
                    dedent(
                        &#34;&#34;&#34;
                        # Element and attribute inventory

                        Table of contents

                        &#34;&#34;&#34;
                    )
                )
                for label in kindLabels.values():
                    labelAnchor = label.replace(&#34; &#34;, &#34;-&#34;)
                    fh.write(f&#34;*\t[{label}](#{labelAnchor})\n&#34;)

                fh.write(&#34;\n&#34;)

                tableHeader = dedent(
                    &#34;&#34;&#34;
                    element | attribute | value | amount
                    --- | --- | --- | ---
                    &#34;&#34;&#34;
                )

                def writeAttInfo(tag, att, attInfo):
                    tagRep = &#34; &#34; if tag == &#34;&#34; else f&#34;[{tag}]({elUrlPrefix}{tag}.html)&#34;
                    attRep = &#34; &#34; if att == &#34;&#34; else f&#34;[{att}]({attUrlPrefix}{att})&#34;
                    atts = sorted(attInfo.items())
                    (val, amount) = atts[0]
                    valRep = f&#34;`{val}`&#34; if val else &#34;&#34;
                    fh.write(f&#34;{tagRep} | {attRep} | {valRep} | {amount}\n&#34;)
                    for (val, amount) in atts[1:]:
                        valRep = f&#34;`{val}`&#34; if val else &#34;&#34;
                        fh.write(f&#34;&#34;&#34;\u00a0| | {valRep} | {amount}\n&#34;&#34;&#34;)

                def writeTagInfo(tag, tagInfo):
                    tags = sorted(tagInfo.items())
                    (att, attInfo) = tags[0]
                    writeAttInfo(tag, att, attInfo)
                    for (att, attInfo) in tags[1:]:
                        writeAttInfo(&#34;&#34;, att, attInfo)

                for (kind, label) in kindLabels.items():
                    fh.write(f&#34;## {label}\n{tableHeader}&#34;)
                    for (tag, tagInfo) in sorted(analysis[kind].items()):
                        writeTagInfo(tag, tagInfo)
                    fh.write(&#34;\n&#34;)

        def filterError(msg):
            return msg == (
                &#34;Element &#39;graphic&#39;, attribute &#39;url&#39;: [facet &#39;pattern&#39;] &#34;
                &#34;The value &#39;&#39; is not accepted by the pattern &#39;\\S+&#39;.&#34;
            )

        NS_RE = re.compile(r&#34;&#34;&#34;\{[^}]+}&#34;&#34;&#34;)

        def doXMLFile(xmlPath):
            tree = etree.parse(xmlPath, parser)
            if validator is not None and not validator.validate(tree):
                theseErrors = []
                for entry in validator.error_log:
                    msg = entry.message
                    msg = NS_RE.sub(&#34;&#34;, msg)
                    if filterError(msg):
                        continue
                    # domain = entry.domain_name
                    # typ = entry.type_name
                    level = entry.level_name
                    line = entry.line
                    col = entry.column
                    address = f&#34;{line}:{col}&#34;
                    theseErrors.append(f&#34;{address:&lt;6} {level:} {msg}\n&#34;)
                if len(theseErrors):
                    console(&#34;ERROR\n&#34;)
                    errors.append((xmlFile, theseErrors))
                return

            root = tree.getroot()
            analyse(root, analysis)

        if sectionModel == &#34;I&#34;:
            i = 0
            for (xmlFolder, xmlFiles) in self.getXML():
                console(f&#34;Start folder {xmlFolder}:&#34;)
                for xmlFile in xmlFiles:
                    i += 1
                    console(f&#34;\r{i:&gt;4} {xmlFile:&lt;50}&#34;, newline=False)
                    xmlPath = f&#34;{sourceDir}/{xmlFolder}/{xmlFile}&#34;
                    doXMLFile(xmlPath)
                console(&#34;&#34;)
                console(f&#34;End   folder {xmlFolder}&#34;)

        elif sectionModel == &#34;II&#34;:
            xmlFile = self.getXML()
            if xmlFile is None:
                console(&#34;No XML files found!&#34;)
                return False

            xmlPath = f&#34;{sourceDir}/{xmlFile}&#34;
            doXMLFile(xmlPath)

        console(&#34;&#34;)
        writeReport()
        writeDoc()
        writeErrors()
        writeNamespaces()

    # SET UP CONVERSION

    def getConverter(self):
        &#34;&#34;&#34;Initializes a converter.

        Returns
        -------
        object
            The `tf.convert.walker.CV` converter object, initialized.
        &#34;&#34;&#34;
        tfPath = self.tfPath

        TF = Fabric(locations=tfPath)
        return CV(TF)

    # DIRECTOR

    def getDirector(self):
        &#34;&#34;&#34;Factory for the director function.

        The `tf.convert.walker` relies on a corpus dependent `director` function
        that walks through the source data and spits out actions that
        produces the TF dataset.

        The director function that walks through the TEI input must be conditioned
        by the properties defined in the TEI schema and the customised schema, if any,
        that describes the source.

        Also some special additions need to be programmed, such as an extra section
        level, word boundaries, etc.

        We collect all needed data, store it, and define a local director function
        that has access to this data.

        Returns
        -------
        function
            The local director function that has been constructed.
        &#34;&#34;&#34;
        TEI_HEADER = &#34;teiHeader&#34;

        TEXT_ANCESTOR = &#34;text&#34;
        TEXT_ANCESTORS = set(
            &#34;&#34;&#34;
            front
            body
            back
            group
            &#34;&#34;&#34;.strip().split()
        )
        CHUNK_PARENTS = TEXT_ANCESTORS | {TEI_HEADER}

        CHUNK_ELEMS = set(
            &#34;&#34;&#34;
            facsimile
            fsdDecl
            sourceDoc
            standOff
            &#34;&#34;&#34;.strip().split()
        )

        PASS_THROUGH = set(
            &#34;&#34;&#34;
            TEI
            &#34;&#34;&#34;.strip().split()
        )

        # CHECKING

        HY = &#34;\u2010&#34;  # hyphen

        IN_WORD_HYPHENS = {HY, &#34;-&#34;}

        ZWSP = &#34;\u200b&#34;  # zero-width space

        sourceDir = self.sourceDir
        wordAsSlot = self.wordAsSlot
        featureMeta = self.featureMeta
        intFeatures = self.intFeatures
        transform = self.transform
        chunkLevel = self.chunkLevel

        transformFunc = (
            (lambda x: x)
            if transform is None
            else (lambda x: BytesIO(transform(x).encode(&#34;utf-8&#34;)))
        )

        parser = self.getParser()
        self.getElementInfo()

        # WALKERS

        WHITE_TRIM_RE = re.compile(r&#34;\s+&#34;, re.S)
        NON_NAME_RE = re.compile(r&#34;[^a-zA-Z0-9_]+&#34;, re.S)

        NOTE_LIKE = set(
            &#34;&#34;&#34;
            note
            &#34;&#34;&#34;.strip().split()
        )
        EMPTY_ELEMENTS = set(
            &#34;&#34;&#34;
            addSpan
            alt
            anchor
            anyElement
            attRef
            binary
            caesura
            catRef
            cb
            citeData
            classRef
            conversion
            damageSpan
            dataFacet
            default
            delSpan
            elementRef
            empty
            equiv
            fsdLink
            gb
            handShift
            iff
            lacunaEnd
            lacunaStart
            lb
            link
            localProp
            macroRef
            milestone
            move
            numeric
            param
            path
            pause
            pb
            ptr
            redo
            refState
            specDesc
            specGrpRef
            symbol
            textNode
            then
            undo
            unicodeProp
            unihanProp
            variantEncoding
            when
            witEnd
            witStart
            &#34;&#34;&#34;.strip().split()
        )
        # N.B. We will alway generate newlines at the closing tags of
        # elements that occur in pure elements
        NEWLINE_ELEMENTS = set(
            &#34;&#34;&#34;
            ab
            cb
            l
            lb
            lg
            list
            p
            pb
            seg
            table
            u
            &#34;&#34;&#34;.strip().split()
        )

        def makeNameLike(x):
            return NON_NAME_RE.sub(&#34;_&#34;, x).strip(&#34;_&#34;)

        def walkNode(cv, cur, node):
            &#34;&#34;&#34;Internal function to deal with a single element.

            Will be called recursively.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            node: object
                An lxml element node.
            &#34;&#34;&#34;
            tag = etree.QName(node.tag).localname
            cur[NEST].append(tag)

            beforeChildren(cv, cur, node, tag)

            for child in node.iterchildren(tag=etree.Element):
                walkNode(cv, cur, child)

            afterChildren(cv, cur, node, tag)
            cur[NEST].pop()
            afterTag(cv, cur, node, tag)

        def isChapter(cur):
            &#34;&#34;&#34;Whether the current element counts as a chapter node.

            ## Model I

            Not relevant: there are no chapter nodes inside an XML file.

            ## Model II

            Chapters are the highest section level (the only lower level is chunks).

            Chapters come in two kinds:

            *   the TEI header;
            *   the immediate children of `&lt;text&gt;`
                except `&lt;front&gt;`, `&lt;body&gt;`, `&lt;back&gt;`, `&lt;group&gt;`;
            *   the immediate children of
                `&lt;front&gt;`, `&lt;body&gt;`, `&lt;back&gt;`, `&lt;group&gt;`.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            sectionModel = self.sectionModel

            if sectionModel == &#34;II&#34;:
                nest = cur[NEST]
                nNest = len(nest)

                if nNest &gt; 0 and nest[-1] in EMPTY_ELEMENTS:
                    return False

                return nNest &gt; 0 and (
                    nest[-1] == TEI_HEADER
                    or (
                        nNest &gt; 1
                        and (
                            nest[-2] in TEXT_ANCESTORS
                            or nest[-2] == TEXT_ANCESTOR
                            and nest[-1] not in TEXT_ANCESTORS
                        )
                    )
                )

            return False

        def isChunk(cur):
            &#34;&#34;&#34;Whether the current element counts as a chunk node.

            ## Model I

            Chunks are the lowest section level (the higher levels are folders
            and then files)

            Chunks are the immediate children of the `&lt;teiHeader&gt;` and the `&lt;body&gt;`
            elements, and a few other elements also count as chunks.

            ## Model II

            Chunks are the lowest section level (the only higher level is chapters).

            Chunks are the immediate children of the chapters, and they come in two
            kinds: the ones that are `&lt;p&gt;` elements, and the rest.

            Deviation from this rule:

            *   If a chapter is a mixed content node, then it is also a chunk.
                and its subelements are not chunks

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            sectionModel = self.sectionModel

            nest = cur[NEST]
            nNest = len(nest)

            if sectionModel == &#34;II&#34;:
                meChptChnk = isChapter(cur) and cur[NEST][-1] not in cur[&#34;pureElems&#34;]
                return nNest &gt; 1 and (
                    meChptChnk
                    or (
                        nest[-2] == TEI_HEADER
                        or (
                            nNest &gt; 2
                            and (
                                nest[-3] in TEXT_ANCESTORS
                                and nest[-1] not in EMPTY_ELEMENTS
                                or nest[-3] == TEXT_ANCESTOR
                                and nest[-2] not in TEXT_ANCESTORS
                            )
                            and cur[NEST][-2] in cur[&#34;pureElems&#34;]
                        )
                    )
                )

            return nNest &gt; 0 and (
                nest[-1] in CHUNK_ELEMS
                or (
                    nNest &gt; 1
                    and (
                        nest[-2] in CHUNK_PARENTS
                        and nest[-1] not in EMPTY_ELEMENTS
                        or nest[-2] == TEXT_ANCESTOR
                        and nest[-1] not in TEXT_ANCESTORS
                    )
                )
            )

        def isPure(cur):
            &#34;&#34;&#34;Whether the current tag has pure content.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            nest = cur[NEST]
            return len(nest) == 0 or len(nest) &gt; 0 and nest[-1] in cur[&#34;pureElems&#34;]

        def isEndInPure(cur):
            &#34;&#34;&#34;Whether the current end tag occurs in an element with pure content.

            If that is the case, then it is very likely that the end tag also
            marks the end of the current word.

            And we should not strip spaces after it.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            nest = cur[NEST]
            return len(nest) &gt; 1 and nest[-2] in cur[&#34;pureElems&#34;]

        def startWord(cv, cur, ch):
            &#34;&#34;&#34;Start a word node if necessary.

            Whenever we encounter a character, we determine
            whether it starts or ends a word, and if it starts
            one, this function takes care of the necessary actions.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            ch: string
                A single character, the next slot in the result data.
            &#34;&#34;&#34;
            curWord = cur[WORD]
            if not curWord:
                prevWord = cur[&#34;prevWord&#34;]
                if prevWord is not None:
                    cv.feature(prevWord, after=cur[&#34;afterStr&#34;])
                if ch is not None:
                    if wordAsSlot:
                        curWord = cv.slot()
                    else:
                        curWord = cv.node(WORD)
                    cur[WORD] = curWord
                    addSlotFeatures(cv, cur, curWord)

            if ch is not None:
                cur[&#34;wordStr&#34;] += ch

        def finishWord(cv, cur, ch, withNewline):
            &#34;&#34;&#34;Terminate a word node if necessary.

            Whenever we encounter a character, we determine
            whether it starts or ends a word, and if it ends
            one, this function takes care of the necessary actions.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            ch: string
                A single character, the next slot in the result data.
            withNewline:
                Whether to add a newline after the word.
            &#34;&#34;&#34;
            curWord = cur[WORD]
            if curWord:
                cv.feature(curWord, str=cur[&#34;wordStr&#34;])
                if not wordAsSlot:
                    cv.terminate(curWord)
                cur[WORD] = None
                cur[&#34;wordStr&#34;] = &#34;&#34;
                cur[&#34;prevWord&#34;] = curWord
                cur[&#34;afterStr&#34;] = &#34;&#34;

            if ch is not None:
                cur[&#34;afterStr&#34;] += ch
            if withNewline:
                cur[&#34;afterStr&#34;] = cur[&#34;afterStr&#34;].rstrip() + &#34;\n&#34;
                if not wordAsSlot:
                    addNewline(cv, cur)

        def addEmpty(cv, cur):
            &#34;&#34;&#34;Add an empty slot.

            We also terminate the current word.
            If words are slots, the empty slot is a word on its own.

            Returns
            -------
            node
                The empty slot
            &#34;&#34;&#34;
            finishWord(cv, cur, None, False)
            startWord(cv, cur, ZWSP)
            emptyNode = cur[WORD]
            cv.feature(emptyNode, empty=1)

            if not wordAsSlot:
                emptyNode = cv.slot()
                cv.feature(emptyNode, ch=ZWSP, empty=1)

            finishWord(cv, cur, None, False)

            return emptyNode

        def addSlotFeatures(cv, cur, s):
            &#34;&#34;&#34;Add generic features to a slot.

            Whenever we encounter a character, we add it as a new slot, unless
            `wordAsSlot` is in force. In that case we suppress the triggering of a
            slot node.
            If needed, we start/terminate word nodes as well.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            s: slot
                A previously added (slot) node
            &#34;&#34;&#34;
            if cur[&#34;inHeader&#34;]:
                cv.feature(s, is_meta=1)
            if cur[&#34;inNote&#34;]:
                cv.feature(s, is_note=1)
            for (r, stack) in cur.get(&#34;rend&#34;, {}).items():
                if len(stack) &gt; 0:
                    cv.feature(s, **{f&#34;rend_{r}&#34;: 1})

        def addSlot(cv, cur, ch):
            &#34;&#34;&#34;Add a slot.

            Whenever we encounter a character, we add it as a new slot, unless
            `wordAsSlot` is in force. In that case we suppress the triggering of a
            slot node.
            If needed, we start/terminate word nodes as well.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            ch: string
                A single character, the next slot in the result data.
            &#34;&#34;&#34;
            if ch is None or ch.isalnum() or ch in IN_WORD_HYPHENS:
                startWord(cv, cur, ch)
            else:
                finishWord(cv, cur, ch, False)

            if wordAsSlot:
                s = cur[WORD]
            elif ch is None:
                s = None
            else:
                s = cv.slot()
                cv.feature(s, ch=ch)
            if s is not None:
                addSlotFeatures(cv, cur, s)

        def addNewline(cv, cur):
            &#34;&#34;&#34;Adds a new line.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Only meant for the case where slots are characters.

            Suppressed when not in a lowest-level section.
            &#34;&#34;&#34;
            if chunkLevel in cv.activeTypes():
                s = cv.slot()
                cv.feature(s, ch=&#34;\n&#34;)
                addSlotFeatures(cv, cur, s)

        def beforeChildren(cv, cur, node, tag):
            &#34;&#34;&#34;Actions before dealing with the element&#39;s children.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            node: object
                An lxml element node.
            tag: string
                The tag of the lxml node.
            &#34;&#34;&#34;
            sectionModel = self.sectionModel
            sectionProperties = self.sectionProperties

            atts = {etree.QName(k).localname: v for (k, v) in node.attrib.items()}

            if sectionModel == &#34;II&#34;:
                chapterSection = self.chapterSection
                chunkSection = self.chunkSection

                if isChapter(cur):
                    cur[&#34;chapterNum&#34;] += 1
                    cur[&#34;prevChapter&#34;] = cur.get(CHAPTER, None)
                    cur[CHAPTER] = cv.node(chapterSection)
                    for danglingSlot in cur[&#34;danglingSlots&#34;]:
                        cv.link(cur[CHAPTER], danglingSlot)

                    value = {chapterSection: f&#34;{cur[&#39;chapterNum&#39;]} {tag}&#34;}
                    cv.feature(cur[CHAPTER], **value)
                    cur[&#34;chunkPNum&#34;] = 0
                    cur[&#34;chunkONum&#34;] = 0
                    cur[&#34;prevChunk&#34;] = cur.get(CHUNK, None)
                    cur[CHUNK] = cv.node(chunkSection)
                    for danglingSlot in cur[&#34;danglingSlots&#34;]:
                        cv.link(cur[CHUNK], danglingSlot)
                    cur[&#34;danglingSlots&#34;] = set()
                    cur[&#34;infirstChunk&#34;] = True

                # N.B. A node can count both as chapter and as chunk,
                # e.g. a &lt;trailer&gt; sibling of the chapter &lt;div&gt;s
                # A trailer has mixed content, so its subelements aren&#39;t typical chunks.
                if isChunk(cur):
                    if cur[&#34;infirstChunk&#34;]:
                        cur[&#34;infirstChunk&#34;] = False
                    else:
                        cur[CHUNK] = cv.node(chunkSection)
                        for danglingSlot in cur[&#34;danglingSlots&#34;]:
                            cv.link(cur[CHUNK], danglingSlot)
                        cur[&#34;danglingSlots&#34;] = set()
                    if tag == &#34;p&#34;:
                        cur[&#34;chunkPNum&#34;] += 1
                        cn = cur[&#34;chunkPNum&#34;]
                    else:
                        cur[&#34;chunkONum&#34;] -= 1
                        cn = cur[&#34;chunkONum&#34;]
                    value = {chunkSection: cn}
                    cv.feature(cur[CHUNK], **value)

                if tag == sectionProperties[&#34;element&#34;]:
                    criticalAtts = sectionProperties[&#34;attributes&#34;]
                    match = True
                    for (k, v) in criticalAtts.items():
                        if atts.get(k, None) != v:
                            match = False
                            break
                    if match:
                        heading = etree.tostring(
                            node, encoding=&#34;unicode&#34;, method=&#34;text&#34;, with_tail=False
                        ).replace(&#34;\n&#34;, &#34; &#34;)
                        value = {chapterSection: heading}
                        cv.feature(cur[CHAPTER], **value)
                        chapterNum = cur[&#34;chapterNum&#34;]
                        console(
                            f&#34;\rchapter {chapterNum:&gt;4} {heading:&lt;50}&#34;, newline=False
                        )
            else:
                chunkSection = self.chunkSection

                if isChunk(cur):
                    cur[&#34;chunkNum&#34;] += 1
                    cur[&#34;prevChunk&#34;] = cur.get(CHUNK, None)
                    cur[CHUNK] = cv.node(chunkSection)
                    for danglingSlot in cur[&#34;danglingSlots&#34;]:
                        cv.link(cur[CHUNK], danglingSlot)
                    cur[&#34;danglingSlots&#34;] = set()
                    value = {chunkSection: cur[&#34;chunkNum&#34;]}
                    cv.feature(cur[CHUNK], **value)

            if tag == TEI_HEADER:
                cur[&#34;inHeader&#34;] = True
                if sectionModel == &#34;II&#34;:
                    value = {chapterSection: &#34;TEI header&#34;}
                    cv.feature(cur[CHAPTER], **value)
            if tag in NOTE_LIKE:
                cur[&#34;inNote&#34;] = True
                finishWord(cv, cur, None, False)

            if tag not in PASS_THROUGH:
                curNode = cv.node(tag)
                if wordAsSlot:
                    if cur[WORD]:
                        cv.link(curNode, [cur[WORD][1]])
                cur[&#34;elems&#34;].append(curNode)
                if len(atts):
                    cv.feature(curNode, **atts)
                    if &#34;rend&#34; in atts:
                        rValue = atts[&#34;rend&#34;]
                        r = makeNameLike(rValue)
                        if r:
                            cur.setdefault(&#34;rend&#34;, {}).setdefault(r, []).append(True)
            if node.text:
                textMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, node.text)
                if isPure(cur):
                    if textMaterial and textMaterial != &#34; &#34;:
                        console(
                            &#34;WARNING: Text material at the start of &#34;
                            f&#34;pure-content element &lt;{tag}&gt;&#34;
                        )
                        stack = &#34;-&#34;.join(cur[NEST])
                        console(f&#34;\tElement stack: {stack}&#34;)
                        console(f&#34;\tMaterial: `{textMaterial}`&#34;)
                else:
                    for ch in textMaterial:
                        addSlot(cv, cur, ch)

        def afterChildren(cv, cur, node, tag):
            &#34;&#34;&#34;Node actions after dealing with the children, but before the end tag.

            Here we make sure that the newline elements will get their last slot
            having a newline at the end of their `after` feature.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            node: object
                An lxml element node.
            tag: string
                The tag of the lxml node.
            &#34;&#34;&#34;
            sectionModel = self.sectionModel
            isChap = isChapter(cur)
            isChnk = isChunk(cur)

            hasFinishedWord = False

            if tag not in PASS_THROUGH:
                if isEndInPure(cur) or tag in NEWLINE_ELEMENTS:
                    finishWord(cv, cur, None, True)
                    hasFinishedWord = True

                curNode = cur[&#34;elems&#34;].pop()

                slots = cv.linked(curNode)

                if not len(slots):
                    lastSlot = addEmpty(cv, cur)
                    if cur[&#34;inHeader&#34;]:
                        cv.feature(lastSlot, is_meta=1)
                    if cur[&#34;inNote&#34;]:
                        cv.feature(lastSlot, is_note=1)
                    # take care that this empty slot falls under all sections
                    # for folders and files this is already guaranteed
                    # We need only to watch out for chapters and chunks
                    if cur.get(CHUNK, None) is None:
                        prevChunk = cur.get(&#34;prevChunk&#34;, None)
                        if prevChunk is None:
                            cur[&#34;danglingSlots&#34;].add(lastSlot)
                        else:
                            cv.link(prevChunk, lastSlot)
                    if sectionModel == &#34;II&#34;:
                        if cur.get(CHAPTER, None) is None:
                            prevChapter = cur.get(&#34;prevChapter&#34;, None)
                            if prevChapter is None:
                                cur[&#34;danglingSlots&#34;].add(lastSlot)
                            else:
                                cv.link(prevChapter, lastSlot)

                cv.terminate(curNode)

            if isChnk:
                if not hasFinishedWord:
                    finishWord(cv, cur, None, True)
                cv.terminate(cur[CHUNK])
            if sectionModel == &#34;II&#34;:
                if isChap:
                    if not hasFinishedWord:
                        finishWord(cv, cur, None, True)
                    cv.terminate(cur[CHAPTER])

        def afterTag(cv, cur, node, tag):
            &#34;&#34;&#34;Node actions after dealing with the children and after the end tag.

            This is the place where we proces the `tail` of an lxml node: the
            text material after the element and before the next open/close
            tag of any element.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            node: object
                An lxml element node.
            tag: string
                The tag of the lxml node.
            &#34;&#34;&#34;
            if tag == TEI_HEADER:
                cur[&#34;inHeader&#34;] = False
            elif tag in NOTE_LIKE:
                cur[&#34;inNote&#34;] = False

            if tag not in PASS_THROUGH:
                atts = {etree.QName(k).localname: v for (k, v) in node.attrib.items()}
                if &#34;rend&#34; in atts:
                    rValue = atts[&#34;rend&#34;]
                    r = makeNameLike(rValue)
                    if r:
                        cur[&#34;rend&#34;][r].pop()

            if node.tail:
                tailMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, node.tail)
                if isPure(cur):
                    if tailMaterial and tailMaterial != &#34; &#34;:
                        elem = cur[NEST][-1]
                        console(
                            &#34;WARNING: Text material after &#34;
                            f&#34;&lt;{tag}&gt; in pure-content element &lt;{elem}&gt;&#34;
                        )
                        stack = &#34;-&#34;.join(cur[NEST])
                        console(f&#34;\tElement stack: {stack}-{tag}&#34;)
                        console(f&#34;\tMaterial: `{tailMaterial}`&#34;)
                else:
                    for ch in tailMaterial:
                        addSlot(cv, cur, ch)

        def director(cv):
            &#34;&#34;&#34;Director function.

            Here we program a walk through the TEI sources.
            At every step of the walk we fire some actions that build TF nodes
            and assign features for them.

            Because everything is rather dynamic, we generate fairly standard
            metadata for the features, namely a link to the tei website.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            &#34;&#34;&#34;
            sectionModel = self.sectionModel
            elementDefs = self.elementDefs

            cur = {}
            cur[&#34;pureElems&#34;] = {
                x for (x, (typ, mixed)) in elementDefs.items() if not mixed
            }

            if sectionModel == &#34;I&#34;:
                folderSection = self.folderSection
                fileSection = self.fileSection

                i = 0
                for (xmlFolder, xmlFiles) in self.getXML():
                    console(f&#34;Start folder {xmlFolder}:&#34;)

                    cur[FOLDER] = cv.node(folderSection)
                    value = {folderSection: xmlFolder}
                    cv.feature(cur[FOLDER], **value)

                    for xmlFile in xmlFiles:
                        i += 1
                        console(f&#34;\r{i:&gt;4} {xmlFile:&lt;50}&#34;, newline=False)

                        cur[FILE] = cv.node(fileSection)
                        value = {fileSection: xmlFile.removesuffix(&#34;.xml&#34;)}
                        cv.feature(cur[FILE], **value)

                        with open(
                            f&#34;{sourceDir}/{xmlFolder}/{xmlFile}&#34;, encoding=&#34;utf8&#34;
                        ) as fh:
                            text = fh.read()
                            text = transformFunc(text)
                            tree = etree.parse(text, parser)
                            root = tree.getroot()
                            cur[&#34;inHeader&#34;] = False
                            cur[&#34;inNote&#34;] = False
                            cur[NEST] = []
                            cur[&#34;elems&#34;] = []
                            cur[&#34;chunkNum&#34;] = 0
                            cur[&#34;prevChunk&#34;] = None
                            cur[&#34;danglingSlots&#34;] = set()
                            cur[WORD] = None
                            cur[&#34;prevWord&#34;] = None
                            cur[&#34;wordStr&#34;] = &#34;&#34;
                            cur[&#34;afterStr&#34;] = &#34;&#34;
                            walkNode(cv, cur, root)

                        addSlot(cv, cur, None)
                        cv.terminate(cur[FILE])

                    console(&#34;&#34;)
                    console(f&#34;End   folder {xmlFolder}&#34;)
                    cv.terminate(cur[FOLDER])

            elif sectionModel == &#34;II&#34;:
                xmlFile = self.getXML()
                if xmlFile is None:
                    console(&#34;No XML files found!&#34;)
                    return False

                with open(f&#34;{sourceDir}/{xmlFile}&#34;, encoding=&#34;utf8&#34;) as fh:
                    text = fh.read()
                    text = transformFunc(text)
                    tree = etree.parse(text, parser)
                    root = tree.getroot()
                    cur[&#34;inHeader&#34;] = False
                    cur[&#34;inNote&#34;] = False
                    cur[NEST] = []
                    cur[&#34;elems&#34;] = []
                    cur[&#34;chapterNum&#34;] = 0
                    cur[&#34;chunkPNum&#34;] = 0
                    cur[&#34;chunkONum&#34;] = 0
                    cur[&#34;prevChunk&#34;] = None
                    cur[&#34;prevChapter&#34;] = None
                    cur[&#34;danglingSlots&#34;] = set()
                    cur[WORD] = None
                    cur[&#34;prevWord&#34;] = None
                    cur[&#34;wordStr&#34;] = &#34;&#34;
                    cur[&#34;afterStr&#34;] = &#34;&#34;
                    for child in root.iterchildren(tag=etree.Element):
                        walkNode(cv, cur, child)

                addSlot(cv, cur, None)

            console(&#34;&#34;)

            for fName in featureMeta:
                if not cv.occurs(fName):
                    cv.meta(fName)
            for fName in cv.features():
                if fName not in featureMeta:
                    if fName.startswith(&#34;rend_&#34;):
                        r = fName[5:]
                        cv.meta(
                            fName,
                            description=f&#34;whether text is to be rendered as {r}&#34;,
                            valueType=&#34;int&#34;,
                        )
                        intFeatures.add(fName)
                    else:
                        cv.meta(
                            fName,
                            description=f&#34;this is TEI attribute {fName}&#34;,
                            valueType=&#34;str&#34;,
                        )
            console(&#34;source reading done&#34;)
            return True

        return director

    def convertTask(self):
        &#34;&#34;&#34;Implementation of the &#34;convert&#34; task.

        It sets up the `tf.convert.walker` machinery and runs it.

        Returns
        -------
        boolean
            Whether the conversion was successful.
        &#34;&#34;&#34;
        if not self.good:
            return

        wordAsSlot = self.wordAsSlot
        sectionModel = self.sectionModel
        tfPath = self.tfPath
        sourceDir = self.sourceDir
        chunkSection = self.chunkSection
        levelNames = self.levelNames

        console(f&#34;TEI to TF converting: {ux(sourceDir)} =&gt; {ux(tfPath)}&#34;)

        slotType = WORD if wordAsSlot else CHAR

        sectionFeatures = &#34;,&#34;.join(levelNames)
        sectionTypes = &#34;,&#34;.join(levelNames)

        textFeatures = &#34;{str}{after}&#34; if wordAsSlot else &#34;{ch}&#34;
        otext = {
            &#34;fmt:text-orig-full&#34;: textFeatures,
            &#34;sectionFeatures&#34;: sectionFeatures,
            &#34;sectionTypes&#34;: sectionTypes,
            &#34;levelConstraints&#34;: &#34;note &lt; chunk, p&#34;,
        }
        intFeatures = {&#34;empty&#34;, chunkSection}
        featureMeta = dict(
            str=dict(description=&#34;the text of a word&#34;),
            after=dict(description=&#34;the text after a word till the next word&#34;),
            empty=dict(
                description=&#34;whether a slot has been inserted in an empty element&#34;
            ),
            is_meta=dict(
                description=&#34;whether a slot or word is in the teiHeader element&#34;
            ),
            is_note=dict(description=&#34;whether a slot or word is in the note element&#34;),
        )
        featureMeta[chunkSection] = dict(
            description=f&#34;number of a {chunkSection} within a document&#34;
        )

        if not wordAsSlot:
            featureMeta[&#34;ch&#34;] = dict(description=&#34;the unicode character of a slot&#34;)
        if sectionModel == &#34;II&#34;:
            chapterSection = self.chapterSection
            featureMeta[chapterSection] = dict(description=f&#34;name of {chapterSection}&#34;)
        else:
            folderSection = self.folderSection
            fileSection = self.fileSection
            featureMeta[folderSection] = dict(
                description=f&#34;name of source {folderSection}&#34;
            )
            featureMeta[fileSection] = dict(description=f&#34;name of source {fileSection}&#34;)

        self.intFeatures = intFeatures
        self.featureMeta = featureMeta

        schema = self.schema
        tfVersion = self.tfVersion
        generic = self.generic
        generic[&#34;sourceFormat&#34;] = &#34;TEI&#34;
        generic[&#34;version&#34;] = tfVersion
        if schema:
            generic[&#34;schema&#34;] = schema

        initTree(tfPath, fresh=True, gentle=True)

        cv = self.getConverter()

        self.good = cv.walk(
            self.getDirector(),
            slotType,
            otext=otext,
            generic=generic,
            intFeatures=intFeatures,
            featureMeta=featureMeta,
            generateTf=True,
        )

    def loadTask(self):
        &#34;&#34;&#34;Implementation of the &#34;load&#34; task.

        It loads the tf data that resides in the directory where the &#34;convert&#34; task
        deliver its results.

        During loading there are additional checks. If they succeed, we have evidence
        that we have a valid TF dataset.

        Also, during the first load intensive precomputation of TF data takes place,
        the results of which will be cached in the invisible `.tf` directory there.

        That makes the TF data ready to be loaded fast, next time it is needed.

        Returns
        -------
        boolean
            Whether the loading was successful.
        &#34;&#34;&#34;
        if not self.good:
            return

        tfPath = self.tfPath

        if not dirExists(tfPath):
            console(f&#34;Directory {ux(tfPath)} does not exist.&#34;)
            console(&#34;No tf found, nothing to load&#34;)
            self.good = False
            return

        TF = Fabric(locations=[tfPath])
        allFeatures = TF.explore(silent=True, show=True)
        loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
        api = TF.load(loadableFeatures, silent=False)
        if api:
            console(f&#34;max node = {api.F.otype.maxNode}&#34;)
            self.good = True
            return

        self.good = False

    # APP CREATION/UPDATING

    def appTask(self, tokenBased=False):
        &#34;&#34;&#34;Implementation of the &#34;app&#34; task.

        It creates/updates a corpus-specific app.
        There should be a valid TF dataset in place, because some
        settings in the app derive from it.

        Returns
        -------
        boolean
            Whether the operation was successful.
        &#34;&#34;&#34;
        if not self.good:
            return

        refDir = self.refDir
        myDir = self.myDir
        appConfig = self.appConfig
        force = self.force
        wordAsSlot = self.wordAsSlot
        sectionModel = self.sectionModel
        sectionProperties = self.sectionProperties
        docsDir = self.docsDir

        initTree(docsDir)

        itemSpecs = (
            (&#34;about&#34;, &#34;docs&#34;, &#34;about.md&#34;, False),
            (&#34;trans&#34;, (&#34;app&#34;, &#34;docs&#34;), &#34;transcription.md&#34;, True),
            (&#34;logo&#34;, &#34;app/static&#34;, &#34;logo.png&#34;, True),
            (&#34;display&#34;, &#34;app/static&#34;, &#34;display.css&#34;, True),
            (&#34;config&#34;, &#34;app&#34;, &#34;config.yaml&#34;, True),
            (&#34;app&#34;, &#34;app&#34;, &#34;app.py&#34;, True),
        )
        items = {
            s[0]: dict(parent=s[1], file=s[2], hasTemplate=s[3]) for s in itemSpecs
        }
        cssInfo = makeCssInfo()

        def createConfig(itemSource, itemTarget):
            tfVersion = self.tfVersion

            with open(itemSource, encoding=&#34;utf8&#34;) as fh:
                text = fh.read()

            version = tfVersion.removesuffix(&#34;pre&#34;) if tokenBased else tfVersion
            text = text.replace(&#34;Â«versionÂ»&#34;, f&#39;&#34;{version}&#34;&#39;)

            settings = yaml.load(text, Loader=yaml.FullLoader)
            mergeDict(settings, appConfig)

            if tokenBased:
                if &#34;typeDisplay&#34; in settings and &#34;word&#34; in settings[&#34;typeDisplay&#34;]:
                    del settings[&#34;typeDisplay&#34;][&#34;word&#34;]
            text = yaml.dump(settings, allow_unicode=True)

            with open(itemTarget, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                fh.write(text)

        def createDisplay(itemSource, itemTarget):
            &#34;&#34;&#34;Copies and tweaks the display.css file of an TF app.

            We generate css code for a certain text formatting styles,
            triggered by `rend` attributes in the source.
            &#34;&#34;&#34;

            with open(itemSource, encoding=&#34;utf8&#34;) as fh:
                css = fh.read()

            css = css.replace(&#34;Â«rendsÂ»&#34;, cssInfo)

            with open(itemTarget, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                fh.write(css)

        def createApp(itemSource, itemTarget):
            &#34;&#34;&#34;Copies and tweaks the app.py file of an TF app.

            The template app.py provides text formatting functions.
            It retrieves text from features, but that is dependent on
            the settings of the conversion, in particular whether we have words as
            slots or characters.

            Depending on that we insert some code in the template.

            The template contains the string `F.matÃ©rial`, and it will be replaced
            by something like

            ```
            F.ch.v(n)
            ```

            or

            ```
            f&#34;{F.str.v(n)}{F.after.v(n)}&#34;
            ```

            That&#39;s why the variable `materialCode` in the body gets a rather
            unusual value: it is interpreted later on as code.
            &#34;&#34;&#34;

            materialCode = (
                &#34;&#34;&#34;f&#39;{F.str.v(n) or &#34;&#34;}{F.after.v(n) or &#34;&#34;}&#39;&#34;&#34;&#34;
                if wordAsSlot or tokenBased
                else &#39;&#39;&#39;F.ch.v(n) or &#34;&#34;&#39;&#39;&#39;
            )
            rendValues = repr(KNOWN_RENDS)

            with open(itemSource, encoding=&#34;utf8&#34;) as fh:
                code = fh.read()

            code = code.replace(&#34;F.matÃ©rial&#34;, materialCode)
            code = code.replace(&#39;&#34;rÃ¨ndValues&#34;&#39;, rendValues)

            with open(itemTarget, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                fh.write(code)

        def createTranscription(itemSource, itemTarget):
            &#34;&#34;&#34;Copies and tweaks the transcription.md file for a TF corpus.&#34;&#34;&#34;
            org = self.org
            repo = self.repo
            relative = self.relative
            generic = self.generic

            generic = &#34;\n\n&#34;.join(
                f&#34;## {key}\n\n{value}\n&#34; for (key, value) in generic.items()
            )

            with open(itemSource, encoding=&#34;utf8&#34;) as fh:
                template = fh.read()

            result = (
                dedent(
                    f&#34;&#34;&#34;
                # Corpus {org} - {repo}{relative}

                &#34;&#34;&#34;
                )
                + tweakTrans(
                    template, wordAsSlot, tokenBased, sectionModel, sectionProperties
                )
                + dedent(
                    &#34;&#34;&#34;

                    ## See also

                    *   [about](about.md)
                    &#34;&#34;&#34;
                )
            )
            with open(itemTarget, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                fh.write(result)

        def createAbout():
            org = self.org
            repo = self.repo
            relative = self.relative
            generic = self.generic

            generic = &#34;\n\n&#34;.join(
                f&#34;## {key}\n\n{value}\n&#34; for (key, value) in generic.items()
            )

            return (
                dedent(
                    f&#34;&#34;&#34;
                # Corpus {org} - {repo}{relative}

                &#34;&#34;&#34;
                )
                + generic
                + dedent(
                    &#34;&#34;&#34;

                    ## Conversion

                    Converted from TEI to Text-Fabric

                    ## See also

                    *   [transcription](transcription.md)
                    &#34;&#34;&#34;
                )
            )

        console(&#34;App updating ...&#34;)

        for (name, info) in items.items():
            parent = info[&#34;parent&#34;]
            (sourceBit, targetBit) = (
                parent if type(parent) is tuple else (parent, parent)
            )
            file = info[FILE]
            hasTemplate = info[&#34;hasTemplate&#34;]

            targetDir = f&#34;{refDir}/{targetBit}&#34;
            itemTarget = f&#34;{targetDir}/{file}&#34;
            fileParts = file.rsplit(&#34;.&#34;, 1)
            if len(fileParts) == 1:
                fileParts = [file, &#34;&#34;]
            (fileBase, fileExt) = fileParts
            itemTargetGen = f&#34;{targetDir}/{fileBase}_generated.{fileExt}&#34;
            itemExists = fileExists(itemTarget)
            itemGenExists = fileExists(itemTargetGen)

            existRep = &#34;exists &#34; if itemExists else &#34;missing&#34;
            changeRep = &#34;generated&#34; if itemExists else &#34;added   &#34;

            initTree(targetDir, fresh=False)

            target = itemTarget

            if force:
                if itemGenExists:
                    fileRemove(itemTargetGen)
            else:
                if itemExists:
                    target = itemTargetGen

            if force and itemExists and name == &#34;logo&#34;:
                continue

            if hasTemplate:
                sourceDir = f&#34;{myDir}/{sourceBit}&#34;
                itemSource = f&#34;{sourceDir}/{file}&#34;
                (
                    createConfig
                    if name == &#34;config&#34;
                    else createApp
                    if name == &#34;app&#34;
                    else createDisplay
                    if name == &#34;display&#34;
                    else createTranscription
                    if name == &#34;trans&#34;
                    else fileCopy
                )(itemSource, target)

            else:
                with open(target, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                    fh.write(createAbout())
            console(f&#34;\t{name:&lt;7}: {existRep}, {changeRep} {ux(target)}&#34;)

    # START the TEXT-FABRIC BROWSER on this CORPUS

    def browseTask(self):
        &#34;&#34;&#34;Implementation of the &#34;browse&#34; task.

        It gives a shell command to start the text-fabric browser on
        the newly created corpus.
        There should be a valid TF dataset and app configuraiton in place

        Returns
        -------
        boolean
            Whether the operation was successful.
        &#34;&#34;&#34;
        if not self.good:
            return

        org = self.org
        repo = self.repo
        relative = self.relative
        backend = self.backend
        tfVersion = self.tfVersion

        backendOpt = &#34;&#34; if backend == &#34;github&#34; else f&#34;--backend={backend}&#34;
        versionOpt = f&#34;--version={tfVersion}&#34;
        try:
            run(
                (
                    f&#34;text-fabric {org}/{repo}{relative}:clone --checkout=clone &#34;
                    f&#34;{versionOpt} {backendOpt}&#34;
                ),
                shell=True,
            )
        except KeyboardInterrupt:
            pass

    def task(
        self,
        check=False,
        convert=False,
        load=False,
        app=False,
        apptoken=False,
        browse=False,
        test=None,
        force=False,
    ):
        &#34;&#34;&#34;Carry out any task, possibly modified by any flag.

        This is a higher level function that can execute a selection of tasks.

        The tasks will be executed in a fixed order: check, convert load.
        But you can select which one(s) must be executed.

        If multiple tasks must be executed and one fails, the subsequent tasks
        will not be executed.

        Parameters
        ----------
        check: boolean, optional False
            Whether to carry out the &#34;check&#34; task.
        convert: boolean, optional False
            Whether to carry out the &#34;convert&#34; task.
        load: boolean, optional False
            Whether to carry out the &#34;load&#34; task.
        app: boolean, optional False
            Whether to carry out the &#34;app&#34; task.
        apptoken: boolean, optional False
            Whether to carry out the &#34;apptoken&#34; task.
        browse: boolean, optional False
            Whether to carry out the &#34;browse&#34; task&#34;
        test: boolean, optional None
            Whether to run in test mode.
            In test mode only the files in the test set are converted.
        force: boolean, optional False
            Whether the app task should overwrite previously generated files

            If None, it will read its value from the attribute `testMode` of the
            `TEI` object.

        Returns
        -------
        boolean
            Whether all tasks have executed successfully.
        &#34;&#34;&#34;
        if test is not None:
            self.testMode = test

        self.force = force

        if not self.good:
            return

        for (condition, method, kwargs) in (
            (check, self.checkTask, {}),
            (convert, self.convertTask, {}),
            (load, self.loadTask, {}),
            (app, self.appTask, {}),
            (apptoken, self.appTask, dict(tokenBased=True)),
            (browse, self.browseTask, {}),
        ):
            if condition:
                method(**kwargs)

    def run(self, program=None):
        &#34;&#34;&#34;Carry out tasks specified by arguments on the command line.

        The intended use of this module is that it is included by a conversion
        script.
        When that script is invoked, you can pass arguments to specify tasks
        and flags.

        This function inspects those arguments, and runs the specified tasks,
        with the specified flags enabled.

        Parameters
        ----------
        program: string
            The name of the program that you want to display
            in the help string, in case a help text must be displayed.

        Returns
        -------
        integer
            In fact, this function will terminate the conversion program
            an return a status code: 0 for succes, 1 for failure.
        &#34;&#34;&#34;
        programRep = &#34;TEI-converter&#34; if program is None else program
        possibleTasks = {&#34;check&#34;, &#34;convert&#34;, &#34;load&#34;, &#34;app&#34;, &#34;apptoken&#34;, &#34;browse&#34;}
        possibleFlags = {&#34;test&#34;, &#34;force&#34;}
        possibleArgs = possibleTasks | possibleFlags

        args = sys.argv[1:]

        if not len(args) or &#34;--help&#34; in args or &#34;-h&#34; in args:
            self.help(programRep)
            console(&#34;No task specified&#34;)
            sys.exit(-1)

        illegalArgs = {arg for arg in args if arg not in possibleArgs}

        if len(illegalArgs):
            self.help(programRep)
            for arg in illegalArgs:
                console(f&#34;Illegal argument `{arg}`&#34;)
            sys.exit(-1)

        tasks = {arg: True for arg in args if arg in possibleTasks}
        flags = {arg: True for arg in args if arg in possibleFlags}

        self.task(**tasks, **flags)
        if self.good:
            sys.exit(0)
        else:
            sys.exit(1)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.convert.tei.checkSectionModel"><code class="name flex">
<span>def <span class="ident">checkSectionModel</span></span>(<span>sectionModel)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L325-L382" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkSectionModel(sectionModel):
    if sectionModel is None:
        model = SECTION_MODEL_DEFAULT
        console(f&#34;WARNING: No section model specified. Assuming model {model}.&#34;)
        properties = {k: v[1] for (k, v) in SECTION_MODELS[model].items()}
        return dict(model=model, properties=properties)

    if type(sectionModel) is str:
        if sectionModel in SECTION_MODELS:
            sectionModel = dict(model=sectionModel)
        else:
            console(f&#34;WARNING: unknown section model: {sectionModel}&#34;)
            return False

    elif type(sectionModel) is not dict:
        console(
            f&#34;ERROR: Section model must be a dict. You passed a {type(sectionModel)}&#34;
        )
        return False

    model = sectionModel.get(&#34;model&#34;, None)
    if model is None:
        model = SECTION_MODEL_DEFAULT
        console(f&#34;WARNING: No section model specified. Assuming model {model}.&#34;)
        sectionModel[&#34;model&#34;] = model
    if model not in SECTION_MODELS:
        console(f&#34;WARNING: unknown section model: {sectionModel}&#34;)
        return False

    properties = {k: v for (k, v) in sectionModel.items() if k != &#34;model&#34;}
    modelProperties = SECTION_MODELS[model]

    good = True
    delKeys = []

    for (k, v) in properties.items():
        if k not in modelProperties:
            console(f&#34;WARNING: ignoring unknown model property {k}={v}&#34;)
            delKeys.append(k)
        elif type(v) is not modelProperties[k][0]:
            console(
                f&#34;ERROR: property {k} should have type {modelProperties[k][0]}&#34;
                f&#34; but {v} has type {type(v)}&#34;
            )
            good = False
    if good:
        for k in delKeys:
            del properties[k]

    for (k, v) in modelProperties.items():
        if k not in properties:
            console(f&#34;WARNING: model property {k} not specified, taking default {v[1]}&#34;)
            properties[k] = v[1]

    if not good:
        return False

    return dict(model=model, properties=properties)</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.makeCssInfo"><code class="name flex">
<span>def <span class="ident">makeCssInfo</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L298-L311" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeCssInfo():
    rends = &#34;&#34;

    for (rend, (description, css)) in sorted(CSS_REND.items()):
        aliases = CSS_REND_ALIAS.get(rend, &#34;&#34;)
        aliases = sorted(set(aliases.split()) | {rend})
        for alias in aliases:
            KNOWN_RENDS.add(alias)
            REND_DESC[alias] = description
        selector = &#34;,&#34;.join(f&#34;.r_{alias}&#34; for alias in aliases)
        contribution = f&#34;\n{selector} {{{css}}}\n&#34;
        rends += contribution

    return rends</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.tweakTrans"><code class="name flex">
<span>def <span class="ident">tweakTrans</span></span>(<span>template, wordAsSlot, tokenBased, sectionModel, sectionProperties)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L385-L482" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tweakTrans(template, wordAsSlot, tokenBased, sectionModel, sectionProperties):
    if wordAsSlot:
        slot = WORD
        slotc = &#34;Word&#34;
        slotf = &#34;words&#34;
        xslot = &#34;`word`&#34;
    else:
        slotc = &#34;Char&#34;
        slot = CHAR
        slotf = &#34;characters&#34;
        xslot = &#34;`char` and `word`&#34;
    if tokenBased:
        slot = TOKEN
        slotc = &#34;Token&#34;
        slotf = &#34;tokens&#34;
        xslot = &#34;`token`&#34;
        tokenGen = dedent(
            &#34;&#34;&#34;
            Tokens and sentence boundaries have been generated by a Natural Language
            Pipeline, such as Spacy.
            &#34;&#34;&#34;
        )
        tokenWord = &#34;token&#34;
        hasToken = &#34;Yes&#34;
    else:
        tokenGen = &#34;&#34;
        tokenWord = &#34;word&#34;
        hasToken = &#34;No&#34;

    levelNames = sectionProperties[&#34;levels&#34;]

    if sectionModel == &#34;II&#34;:
        nLevels = &#34;2&#34;
        chapterSection = levelNames[0]
        chunkSection = levelNames[1]
        head = sectionProperties[&#34;element&#34;]
        attributes = sectionProperties[&#34;attributes&#34;]
        propertiesRaw = repr(sectionProperties)
        properties = (
            &#34;&#34;.join(
                f&#34;\t*\t`{att}` = `{val}`\n&#34; for (att, val) in sorted(attributes.items())
            )
            if attributes
            else &#34;\t*\t*no attribute properties*\n&#34;
        )
    else:
        nLevels = &#34;3&#34;
        folderSection = levelNames[0]
        fileSection = levelNames[1]
        chunkSection = levelNames[2]

    rendDesc = &#34;\n&#34;.join(
        f&#34;`{val}` | {desc}&#34; for (val, desc) in sorted(REND_DESC.items())
    )
    modelKeepRe = re.compile(rf&#34;Â«(?:begin|end)Model{sectionModel}Â»&#34;)
    modelRemoveRe = re.compile(r&#34;Â«beginModel([^Â»]+)Â».*?Â«endModel\1Â»&#34;, re.S)
    slotKeepRe = re.compile(rf&#34;Â«(?:begin|end)Slot{slot}Â»&#34;)
    slotRemoveRe = re.compile(r&#34;Â«beginSlot([^Â»]+)Â».*?Â«endSlot\1Â»&#34;, re.S)
    tokenKeepRe = re.compile(rf&#34;Â«(?:begin|end)Token{hasToken}Â»&#34;)
    tokenRemoveRe = re.compile(r&#34;Â«beginToken([^Â»]+)Â».*?Â«endToken\1Â»&#34;, re.S)

    skipVars = re.compile(r&#34;Â«[^Â»]+Â»&#34;)

    text = (
        template.replace(&#34;Â«slotÂ»&#34;, slot)
        .replace(&#34;Â«SlotÂ»&#34;, slotc)
        .replace(&#34;Â«slotfÂ»&#34;, slotf)
        .replace(&#34;Â«char and wordÂ»&#34;, xslot)
        .replace(&#34;Â«tokenWordÂ»&#34;, tokenWord)
        .replace(&#34;Â«token generationÂ»&#34;, tokenGen)
        .replace(&#34;Â«nLevelsÂ»&#34;, nLevels)
        .replace(&#34;Â«sectionModelÂ»&#34;, sectionModel)
        .replace(&#34;Â«rendDescÂ»&#34;, rendDesc)
    )
    if sectionModel == &#34;II&#34;:
        text = (
            text.replace(&#34;Â«headÂ»&#34;, head)
            .replace(&#34;Â«propertiesÂ»&#34;, properties)
            .replace(&#34;Â«propertiesRawÂ»&#34;, propertiesRaw)
            .replace(&#34;Â«chapterÂ»&#34;, chapterSection)
            .replace(&#34;Â«chunkÂ»&#34;, chunkSection)
        )
    else:
        text = (
            text.replace(&#34;Â«folderÂ»&#34;, folderSection)
            .replace(&#34;Â«fileÂ»&#34;, fileSection)
            .replace(&#34;Â«chunkÂ»&#34;, chunkSection)
        )

    text = tokenKeepRe.sub(&#34;&#34;, text)
    text = tokenRemoveRe.sub(&#34;&#34;, text)
    text = modelKeepRe.sub(&#34;&#34;, text)
    text = modelRemoveRe.sub(&#34;&#34;, text)
    text = slotKeepRe.sub(&#34;&#34;, text)
    text = slotRemoveRe.sub(&#34;&#34;, text)

    text = skipVars.sub(&#34;&#34;, text)
    return text</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.convert.tei.TEI"><code class="flex name class">
<span>class <span class="ident">TEI</span></span>
<span>(</span><span>sourceVersion='0.1', schema=None, testSet=set(), wordAsSlot=True, sectionModel=None, generic={}, transform=None, tfVersion='0.1', appConfig={}, docMaterial={}, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts TEI to TF.</p>
<p>For documentation of the resulting encoding, read the
<a href="https://github.com/annotation/text-fabric/blob/master/tf/convert/app/transcription.md">transcription template</a>.</p>
<p>Below we describe how to control the conversion machinery.</p>
<p>We adopt a fair bit of "convention over configuration" here, in order to lessen
the burden for the user of specifying so many details.</p>
<p>Based on current directory from where the script is called,
it defines all the ingredients to carry out
a <code><a title="tf.convert.walker" href="walker.html">tf.convert.walker</a></code> conversion of the TEI input.</p>
<p>This function is assumed to work in the context of a repository,
i.e. a directory on your computer relative to which the input directory exists,
and various output directories: <code><a title="tf" href="../index.html">tf</a></code>, <code>app</code>, <code>docs</code>.</p>
<p>Your current directory must be at</p>
<pre><code>~/backend/org/repo/relative
</code></pre>
<p>where</p>
<ul>
<li><code>~</code> is your home directory;</li>
<li><code>backend</code> is an online <em>backend</em> name,
like <code>github</code>, <code>gitlab</code>, <code>git.huc.knaw.nl</code>;</li>
<li><code>org</code> is an organisation, person, or group in the backend;</li>
<li><code>repo</code> is a repository in the <code>org</code>.</li>
<li><code>relative</code> is a directory path within the repo (0 or more components)</li>
</ul>
<p>This is only about the directory structure on your local computer;
it is not required that you have online incarnations of your repository
in that backend.
Even your local repository does not have to be a git repository.</p>
<p>The only thing that matters is that the full path to your repo can be parsed
as a sequence of <em>home</em>/<em>backend</em>/<em>org</em>/<em>repo</em>/<em>relative</em>.</p>
<p>Relative to this directory the program expects and creates
input/output directories.</p>
<h2 id="input-directories">Input directories</h2>
<h3 id="tei"><code>tei</code></h3>
<p><em>Location of the TEI-XML sources.</em></p>
<p><strong>If it does not exist, the program aborts with an error.</strong></p>
<p>Several levels of subfolders are assumed:</p>
<ol>
<li>the version of the source (this could be a date string).</li>
<li>volumes/collections of documents. The subfolder <code>__ignore__</code> is ignored.</li>
<li>the TEI documents themselves, conforming to the TEI schema or some
customisation of it.</li>
</ol>
<h3 id="schema"><code>schema</code></h3>
<p><em>Location of the TEI-XML schemas against which the sources can be validated.</em></p>
<p>It should be an <code>.xsd</code> file, and the parameter <code>schema</code> may specify
its name (without extension).</p>
<div class="admonition note">
<p class="admonition-title">Multiple <code>.xsd</code> files</p>
<p>When you started with a <code>.rng</code> file and used <code><a title="tf.tools.xmlschema" href="../tools/xmlschema.html">tf.tools.xmlschema</a></code> to
convert it to <code>xsd</code>, you may have got multiple <code>.xsd</code> files.
One of them has the same base name as the original <code>.rng</code> file,
and you should pass that name. It will import the remaining <code>.xsd</code> files,
so do not throw them away.</p>
</div>
<p>We use this file as custom TEI schema,
but to be sure, we still analyse the full TEI schema and
use the schema passed here as a set of overriding element definitions.</p>
<p>If no schema is specified, we use the <em>full</em> TEI schema.</p>
<h2 id="output-directories">Output directories</h2>
<h3 id="report"><code>report</code></h3>
<p>Directory to write the results of the <code>check</code> task to: an inventory
of elements/attributes encountered, and possible validation errors.
If the directory does not exist, it will be created.
The default value is <code>.</code> (i.e. the current directory in which
the script is invoked).</p>
<h3 id="tf"><code><a title="tf" href="../index.html">tf</a></code></h3>
<p>The directory under which the text-fabric output file (with extension <code>.<a title="tf" href="../index.html">tf</a></code>)
are placed.
If it does not exist, it will be created.
The tf files will be generated in a folder named by a version number,
passed as <code>tfVersion</code>.</p>
<h3 id="app-and-docs"><code>app</code> and <code>docs</code></h3>
<p>Location of additional TF-app configuration and documentation files.
If they do not exist, they will be created with some sensible default
settings and generated documentation.
These settings can be overriden by the parameter <code>appConfig</code>.
Also a default <code>display.css</code> file and a logo are added.</p>
<p>If such a file already exists, it will be left untouched and a generated file
is put next to the item, with <code>_generated</code> in the file name.</p>
<p>This behaviour can be modified by passing <code>force=True</code> to the initialization
of the TEI object.</p>
<h3 id="docs"><code>docs</code></h3>
<p>Location of additional documentation.
This can be generated or had-written material, or a mixture of the two.</p>
<p>!!! caution "Dataloss by overwriting app and docs files.
When <code>force</code> is <code>False</code>, the app docs files will not be overwritten by
generated files. Instead, the generated files are produced
alongside them, with <code>_generated</code> in their names.
These <code>_generated</code> files will be overwritten by successive runs
of the <code>app</code> task.</p>
<pre><code>When you have generated your files, and they cannot be improved anymore,
be sure to set &lt;code&gt;force&lt;/code&gt; to &lt;code&gt;False&lt;/code&gt;.

Then you can edit the apps and docs files by hand, and they will not be
overwritten inadvertently.
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sourceVersion</code></strong> :&ensp;<code>string</code>, optional <code>"0.1"</code></dt>
<dd>Version of the source files. This is the name of a top-level
subfolder of the <code>tei</code> input folder.</dd>
<dt><strong><code>schema</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>Which XML schema to be used, if not specified we fall back on full TEI.
If specified, leave out the <code>.xsd</code> extension. The file is relative to the
<code>schema</code> directory.</dd>
<dt><strong><code>testSet</code></strong> :&ensp;<code>set</code>, optional <code>empty</code></dt>
<dd>A set of file names. If you run the conversion in test mode
(pass <code>test</code> as argument to the <code><a title="tf.convert.tei.TEI.task" href="#tf.convert.tei.TEI.task">TEI.task()</a></code> method),
only the files in the test set are converted.</dd>
<dt><strong><code>wordAsSlot</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to take words as the basic entities (slots).
If not, the characters are taken as basic entities.</dd>
<dt><strong><code>sectionModel</code></strong> :&ensp;<code>dict</code>, optional <code>{}</code></dt>
<dd>
<p>If not passed, or an empty dict, section model I is assumed.
A section model must be specified with the parameters relevant for the
model:</p>
<p><code>dict(
model="II",
levels=["chapter", "chunk"],
element="head",
attributes=dict(rend="h3"),
)</code></p>
<p>or</p>
<p><code>dict(
model="I",
levels=["folder", "file", "chunk"],
)</code></p>
<p>because model I does not require the <em>attribute</em> parameter.</p>
<p>For model II, the default parameters are:</p>
<p><code>element="head"
levels=["chapter", "chunk"],
attributes={}</code></p>
</dd>
<dt><strong><code>generic</code></strong> :&ensp;<code>dict</code>, optional <code>{}</code></dt>
<dd>Metadata for all generated TF feature.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>function</code>, optional <code>None</code></dt>
<dd>If not None, a function that transforms text to text, used
as a preprocessing step for each input xml file.</dd>
<dt><strong><code>tfVersion</code></strong> :&ensp;<code>string</code>, optional <code>"0.1"</code></dt>
<dd>Version of the generated tf files. This is the name of a top-level
subfolder of the <code><a title="tf" href="../index.html">tf</a></code> output folder.</dd>
<dt><strong><code>appConfig</code></strong> :&ensp;<code>dict</code>, optional <code>{}</code></dt>
<dd>Additional configuration settings, which will override the initial
settings.</dd>
<dt><strong><code>docMaterial</code></strong> :&ensp;<code>dict</code>, optional <code>{}</code></dt>
<dd>
<p>Additional documentation:</p>
<ul>
<li>under key <code>about</code>: colofon-like information;</li>
<li>under key <code>trans</code>: additional information about the
transcription and encoding details.</li>
</ul>
</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, the <code>app</code> task will overwrite existing files with generated
files, and remove any files with <code>_generated</code> in the name.
Except for the logo, which will not be overwritten.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L485-L2733" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TEI:
    def __init__(
        self,
        sourceVersion=&#34;0.1&#34;,
        schema=None,
        testSet=set(),
        wordAsSlot=True,
        sectionModel=None,
        generic={},
        transform=None,
        tfVersion=&#34;0.1&#34;,
        appConfig={},
        docMaterial={},
        force=False,
    ):
        &#34;&#34;&#34;Converts TEI to TF.

        For documentation of the resulting encoding, read the
        [transcription template](https://github.com/annotation/text-fabric/blob/master/tf/convert/app/transcription.md).

        Below we describe how to control the conversion machinery.

        We adopt a fair bit of &#34;convention over configuration&#34; here, in order to lessen
        the burden for the user of specifying so many details.

        Based on current directory from where the script is called,
        it defines all the ingredients to carry out
        a `tf.convert.walker` conversion of the TEI input.

        This function is assumed to work in the context of a repository,
        i.e. a directory on your computer relative to which the input directory exists,
        and various output directories: `tf`, `app`, `docs`.

        Your current directory must be at

        ```
        ~/backend/org/repo/relative
        ```

        where

        *   `~` is your home directory;
        *   `backend` is an online *backend* name,
            like `github`, `gitlab`, `git.huc.knaw.nl`;
        *   `org` is an organisation, person, or group in the backend;
        *   `repo` is a repository in the `org`.
        *   `relative` is a directory path within the repo (0 or more components)

        This is only about the directory structure on your local computer;
        it is not required that you have online incarnations of your repository
        in that backend.
        Even your local repository does not have to be a git repository.

        The only thing that matters is that the full path to your repo can be parsed
        as a sequence of *home*/*backend*/*org*/*repo*/*relative*.

        Relative to this directory the program expects and creates
        input/output directories.

        ## Input directories

        ### `tei`

        *Location of the TEI-XML sources.*

        **If it does not exist, the program aborts with an error.**

        Several levels of subfolders are assumed:

        1.  the version of the source (this could be a date string).
        2.  volumes/collections of documents. The subfolder `__ignore__` is ignored.
        3.  the TEI documents themselves, conforming to the TEI schema or some
            customisation of it.

        ### `schema`

        *Location of the TEI-XML schemas against which the sources can be validated.*

        It should be an `.xsd` file, and the parameter `schema` may specify
        its name (without extension).

        !!! note &#34;Multiple `.xsd` files&#34;
            When you started with a `.rng` file and used `tf.tools.xmlschema` to
            convert it to `xsd`, you may have got multiple `.xsd` files.
            One of them has the same base name as the original `.rng` file,
            and you should pass that name. It will import the remaining `.xsd` files,
            so do not throw them away.

        We use this file as custom TEI schema,
        but to be sure, we still analyse the full TEI schema and
        use the schema passed here as a set of overriding element definitions.

        If no schema is specified, we use the *full* TEI schema.

        ## Output directories

        ### `report`

        Directory to write the results of the `check` task to: an inventory
        of elements/attributes encountered, and possible validation errors.
        If the directory does not exist, it will be created.
        The default value is `.` (i.e. the current directory in which
        the script is invoked).

        ### `tf`

        The directory under which the text-fabric output file (with extension `.tf`)
        are placed.
        If it does not exist, it will be created.
        The tf files will be generated in a folder named by a version number,
        passed as `tfVersion`.

        ### `app` and `docs`

        Location of additional TF-app configuration and documentation files.
        If they do not exist, they will be created with some sensible default
        settings and generated documentation.
        These settings can be overriden by the parameter `appConfig`.
        Also a default `display.css` file and a logo are added.

        If such a file already exists, it will be left untouched and a generated file
        is put next to the item, with `_generated` in the file name.

        This behaviour can be modified by passing `force=True` to the initialization
        of the TEI object.

        ### `docs`

        Location of additional documentation.
        This can be generated or had-written material, or a mixture of the two.

        !!! caution &#34;Dataloss by overwriting app and docs files.
            When `force` is `False`, the app docs files will not be overwritten by
            generated files. Instead, the generated files are produced
            alongside them, with `_generated` in their names.
            These `_generated` files will be overwritten by successive runs
            of the `app` task.

            When you have generated your files, and they cannot be improved anymore,
            be sure to set `force` to `False`.

            Then you can edit the apps and docs files by hand, and they will not be
            overwritten inadvertently.

        Parameters
        ----------

        sourceVersion: string, optional &#34;0.1&#34;
            Version of the source files. This is the name of a top-level
            subfolder of the `tei` input folder.

        schema: string, optional None
            Which XML schema to be used, if not specified we fall back on full TEI.
            If specified, leave out the `.xsd` extension. The file is relative to the
            `schema` directory.

        testSet: set, optional empty
            A set of file names. If you run the conversion in test mode
            (pass `test` as argument to the `TEI.task()` method),
            only the files in the test set are converted.

        wordAsSlot: boolean, optional False
            Whether to take words as the basic entities (slots).
            If not, the characters are taken as basic entities.
        sectionModel: dict, optional {}
            If not passed, or an empty dict, section model I is assumed.
            A section model must be specified with the parameters relevant for the
            model:

            ```
            dict(
                model=&#34;II&#34;,
                levels=[&#34;chapter&#34;, &#34;chunk&#34;],
                element=&#34;head&#34;,
                attributes=dict(rend=&#34;h3&#34;),
            )
            ```

            or

            ```
            dict(
                model=&#34;I&#34;,
                levels=[&#34;folder&#34;, &#34;file&#34;, &#34;chunk&#34;],
            )
            ```

            because model I does not require the *attribute* parameter.

            For model II, the default parameters are:

            ```
            element=&#34;head&#34;
            levels=[&#34;chapter&#34;, &#34;chunk&#34;],
            attributes={}
            ```

        generic: dict, optional {}
            Metadata for all generated TF feature.

        transform: function, optional None
            If not None, a function that transforms text to text, used
            as a preprocessing step for each input xml file.

        tfVersion: string, optional &#34;0.1&#34;
            Version of the generated tf files. This is the name of a top-level
            subfolder of the `tf` output folder.

        appConfig: dict, optional {}
            Additional configuration settings, which will override the initial
            settings.

        docMaterial: dict, optional {}
            Additional documentation:

            *   under key `about`: colofon-like information;
            *   under key `trans`: additional information about the
                transcription and encoding details.

        force: boolean, optional False
            If True, the `app` task will overwrite existing files with generated
            files, and remove any files with `_generated` in the name.
            Except for the logo, which will not be overwritten.
        &#34;&#34;&#34;
        (backend, org, repo, relative) = getLocation()
        if any(s is None for s in (backend, org, repo, relative)):
            console(
                &#34;Not working in a repo: &#34;
                f&#34;backend={backend} org={org} repo={repo} relative={relative}&#34;
            )
            quit()

        console(f&#34;Working in repository {org}/{repo}{relative} in backend {backend}&#34;)

        base = ex(f&#34;~/{backend}&#34;)
        repoDir = f&#34;{base}/{org}/{repo}&#34;
        refDir = f&#34;{repoDir}{relative}&#34;
        sourceDir = f&#34;{refDir}/tei/{sourceVersion}&#34;
        reportDir = f&#34;{refDir}/report&#34;
        tfDir = f&#34;{refDir}/tf&#34;
        appDir = f&#34;{refDir}/app&#34;
        docsDir = f&#34;{refDir}/docs&#34;

        self.refDir = refDir
        self.sourceDir = sourceDir
        self.reportDir = reportDir
        self.tfDir = tfDir
        self.appDir = appDir
        self.docsDir = docsDir
        self.backend = backend
        self.org = org
        self.repo = repo
        self.relative = relative

        self.good = True

        if sourceDir is None or not dirExists(sourceDir):
            console(f&#34;Source location does not exist: {sourceDir}&#34;)
            self.good = False
            return

        self.schema = schema
        self.schemaFile = None if schema is None else f&#34;{refDir}/schema/{schema}.xsd&#34;
        self.sourceVersion = sourceVersion
        self.testMode = False
        self.testSet = testSet
        self.wordAsSlot = wordAsSlot
        sectionModel = checkSectionModel(sectionModel)
        if not sectionModel:
            self.good = False
            return

        self.sectionModel = sectionModel[&#34;model&#34;]
        sectionProperties = sectionModel.get(&#34;properties&#34;, None)
        self.sectionProperties = sectionProperties
        levelNames = sectionProperties[&#34;levels&#34;]
        self.levelNames = levelNames
        self.chunkLevel = levelNames[-1]

        if self.sectionModel == &#34;II&#34;:
            self.chapterSection = levelNames[0]
            self.chunkSection = levelNames[1]
        else:
            self.folderSection = levelNames[0]
            self.fileSection = levelNames[1]
            self.chunkSection = levelNames[2]

        self.generic = generic
        self.transform = transform
        self.tfVersion = tfVersion
        self.tfPath = f&#34;{tfDir}/{tfVersion}&#34;
        if (
            &#34;provenanceSpec&#34; not in appConfig
            or &#34;branch&#34; not in appConfig[&#34;provenanceSpec&#34;]
        ):
            appConfig.setdefault(&#34;provenanceSpec&#34;, {})[&#34;branch&#34;] = BRANCH_DEFAULT_NEW
        self.appConfig = appConfig
        self.docMaterial = docMaterial
        self.force = force
        myDir = dirNm(abspath(__file__))
        self.myDir = myDir

    @staticmethod
    def help(program):
        &#34;&#34;&#34;Print a help text to the console.

        The intended use of this module is that it is included by a conversion
        script.
        In order to give help on the command line, here is a pre-baked help text.
        Only the name of the conversion script needs to be merged in.

        Parameters
        ----------
        program: string
            The name of the program that you want to display
            in the help string.
        &#34;&#34;&#34;

        console(
            f&#34;&#34;&#34;

        Convert TEI to TF.
        There are also commands to check the TEI and to load the TF.

        python3 {program} [tasks/flags] [--help]

        --help: show this text and exit

        tasks:
            a sequence of tasks:
            check:
                just reports on the elements in the source.
            convert:
                just converts TEI to TF
            load:
                just loads the generated TF;
            app:
                just configures the TF-app for the result;
            apptoken:
                just modifies the TF-app to make it token- instead of character-based;
            browse:
                just starts the text-fabric browser on the result;

        flags:
            test:
                run in test mode
            force:
                when generating app files, overwrite previously existing app files
        &#34;&#34;&#34;
        )

    @staticmethod
    def getParser():
        &#34;&#34;&#34;Configure the lxml parser.

        See [parser options](https://lxml.de/parsing.html#parser-options).

        Returns
        -------
        object
            A configured lxml parse object.
        &#34;&#34;&#34;
        return etree.XMLParser(
            remove_blank_text=False,
            collect_ids=False,
            remove_comments=True,
            remove_pis=True,
        )

    def getValidator(self):
        &#34;&#34;&#34;Parse the schema.

        A parsed schema can be used for XML-validation.
        This will only happen during the `check` task.

        Returns
        -------
        object
            A configured lxml schema validator.
        &#34;&#34;&#34;
        schemaFile = self.schemaFile

        if schemaFile is None:
            return None

        schemaDoc = etree.parse(schemaFile)
        return etree.XMLSchema(schemaDoc)

    def getElementInfo(self):
        &#34;&#34;&#34;Analyse the schema.

        The XML schema has useful information about the XML elements that
        occur in the source. Here we extract that information and make it
        fast-accessible.

        Returns
        -------
        dict
            Keyed by element name (without namespaces), where the value
            for each name is a tuple of booleans: whether the element is simple
            or complex; whether the element allows mixed content or only pure content.
        &#34;&#34;&#34;
        schemaFile = self.schemaFile

        self.elementDefs = {}

        A = Analysis()
        A.configure(override=schemaFile)
        A.interpret()
        if not A.good:
            quit()

        self.elementDefs = {name: (typ, mixed) for (name, typ, mixed) in A.getDefs()}

    def getXML(self):
        &#34;&#34;&#34;Make an inventory of the TEI source files.

        Returns
        -------
        tuple of tuple | string
            If section model I is in force:

            The outer tuple has sorted entries corresponding to folders under the
            TEI input directory.
            Each such entry consists of the folder name and an inner tuple
            that contains the file names in that folder, sorted.

            If section model II is in force:

            It is the name of the single XML file.
        &#34;&#34;&#34;
        sourceDir = self.sourceDir
        sectionModel = self.sectionModel
        console(f&#34;Section model {sectionModel}&#34;)

        if sectionModel == &#34;I&#34;:
            testMode = self.testMode
            testSet = self.testSet

            IGNORE = &#34;__ignore__&#34;

            xmlFilesRaw = collections.defaultdict(list)

            with scanDir(sourceDir) as dh:
                for folder in dh:
                    folderName = folder.name
                    if folderName == IGNORE:
                        continue
                    if not folder.is_dir():
                        continue
                    with scanDir(f&#34;{sourceDir}/{folderName}&#34;) as fh:
                        for file in fh:
                            fileName = file.name
                            if not (
                                fileName.lower().endswith(&#34;.xml&#34;) and file.is_file()
                            ):
                                continue
                            if testMode and fileName not in testSet:
                                continue
                            xmlFilesRaw[folderName].append(fileName)

            xmlFiles = tuple(
                (folderName, tuple(sorted(fileNames)))
                for (folderName, fileNames) in sorted(xmlFilesRaw.items())
            )
            return xmlFiles

        if sectionModel == &#34;II&#34;:
            xmlFile = None
            with scanDir(sourceDir) as fh:
                for file in fh:
                    fileName = file.name
                    if not (fileName.lower().endswith(&#34;.xml&#34;) and file.is_file()):
                        continue
                    xmlFile = fileName
                    break
            return xmlFile

    def checkTask(self):
        &#34;&#34;&#34;Implementation of the &#34;check&#34; task.

        It validates the TEI, but only if a schema file has been passed explicitly
        when constructing the `TEI()` object.

        Then it makes an inventory of all elements and attributes in the TEI files.

        If tags are used in multiple namespaces, it will be reported.

        !!! caution &#34;Conflation of namespaces&#34;
            The TEI to TF conversion does constructs node types and attributes
            without taking namespaces into account.
            However, the parsing process is namespace aware.

        The inventory lists all elements and attributes, and many attribute values.
        But is represents any digit with `n`, and some attributes that contain
        ids or keywords, are reduced to the value `x`.

        This information reduction helps to get a clear overview.

        It writes reports to the `reportDir`:

        *   `errors.txt`: validation errors
        *   `elements.txt`: element/attribute inventory.
        &#34;&#34;&#34;
        if not self.good:
            return

        sourceDir = self.sourceDir
        reportDir = self.reportDir
        docsDir = self.docsDir
        sectionModel = self.sectionModel

        console(f&#34;TEI to TF checking: {ux(sourceDir)} =&gt; {ux(reportDir)}&#34;)

        kindLabels = dict(
            format=&#34;Formatting Attributes&#34;,
            keyword=&#34;Keyword Attributes&#34;,
            rest=&#34;Remaining Attributes and Elements&#34;,
        )
        getStore = lambda: collections.defaultdict(  # noqa: E731
            lambda: collections.defaultdict(collections.Counter)
        )
        analysis = {x: getStore() for x in kindLabels}
        errors = []
        tagByNs = collections.defaultdict(collections.Counter)

        parser = self.getParser()
        validator = self.getValidator()
        self.getElementInfo()
        elementDefs = self.elementDefs

        initTree(reportDir)
        initTree(docsDir)

        def analyse(root, analysis):
            FORMAT_ATTS = set(
                &#34;&#34;&#34;
                dim
                level
                place
                rend
            &#34;&#34;&#34;.strip().split()
            )

            KEYWORD_ATTS = set(
                &#34;&#34;&#34;
                facs
                form
                function
                lang
                reason
                type
                unit
                who
            &#34;&#34;&#34;.strip().split()
            )

            TRIM_ATTS = set(
                &#34;&#34;&#34;
                id
                key
                target
                value
            &#34;&#34;&#34;.strip().split()
            )

            NUM_RE = re.compile(r&#34;&#34;&#34;[0-9]&#34;&#34;&#34;, re.S)

            def nodeInfo(node):
                qName = etree.QName(node.tag)
                tag = qName.localname
                ns = qName.namespace
                atts = node.attrib

                tagByNs[tag][ns] += 1

                if len(atts) == 0:
                    kind = &#34;rest&#34;
                    analysis[kind][tag][&#34;&#34;][&#34;&#34;] += 1
                else:
                    for (kOrig, v) in atts.items():
                        k = etree.QName(kOrig).localname
                        kind = (
                            &#34;format&#34;
                            if k in FORMAT_ATTS
                            else &#34;keyword&#34;
                            if k in KEYWORD_ATTS
                            else &#34;rest&#34;
                        )
                        dest = analysis[kind]

                        if kind == &#34;rest&#34;:
                            vTrim = &#34;X&#34; if k in TRIM_ATTS else NUM_RE.sub(&#34;N&#34;, v)
                            dest[tag][k][vTrim] += 1
                        else:
                            words = v.strip().split()
                            for w in words:
                                dest[tag][k][w.strip()] += 1

                for child in node.iterchildren(tag=etree.Element):
                    nodeInfo(child)

            nodeInfo(root)

        def writeErrors():
            errorFile = f&#34;{reportDir}/errors.txt&#34;

            nErrors = 0

            with open(errorFile, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                for (xmlFile, lines) in errors:
                    fh.write(f&#34;{xmlFile}\n&#34;)
                    for line in lines:
                        fh.write(line)
                        nErrors += 1
                    fh.write(&#34;\n&#34;)

            console(
                f&#34;{nErrors} error(s) in {len(errors)} file(s) written to {errorFile}&#34;
            )

        def writeNamespaces():
            errorFile = f&#34;{reportDir}/namespaces.txt&#34;

            nErrors = 0

            nTags = len(tagByNs)

            with open(errorFile, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                for (tag, nsInfo) in sorted(
                    tagByNs.items(), key=lambda x: (-len(x[1]), x[0])
                ):
                    label = &#34;OK&#34;
                    nNs = len(nsInfo)
                    if nNs &gt; 1:
                        nErrors += 1
                        label = &#34;XX&#34;

                    for (ns, amount) in sorted(
                        nsInfo.items(), key=lambda x: (-x[1], x[0])
                    ):
                        fh.write(
                            f&#34;{label} {nNs:&gt;2} namespace for &#34;
                            f&#34;{tag:&lt;16} : {amount:&gt;5}x {ns}\n&#34;
                        )

            console(
                f&#34;{nTags} tags of which {nErrors} with multiple namespaces &#34;
                f&#34;written to {errorFile}&#34;
            )

        def writeReport():
            reportFile = f&#34;{reportDir}/elements.txt&#34;
            with open(reportFile, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                fh.write(
                    &#34;Inventory of tags and attributes in the source XML file(s).\n&#34;
                    &#34;Contains the following sections:\n&#34;
                )
                for label in kindLabels.values():
                    fh.write(f&#34;\t{label}\n&#34;)
                fh.write(&#34;\n\n&#34;)

                infoLines = 0

                def writeAttInfo(tag, att, attInfo):
                    nonlocal infoLines
                    nl = &#34;&#34; if tag == &#34;&#34; else &#34;\n&#34;
                    tagRep = &#34;&#34; if tag == &#34;&#34; else f&#34;&lt;{tag}&gt;&#34;
                    attRep = &#34;&#34; if att == &#34;&#34; else f&#34;{att}=&#34;
                    atts = sorted(attInfo.items())
                    (val, amount) = atts[0]
                    if tag:
                        (typ, mixed) = elementDefs[tag]
                        extraInfo = f&#34;{&#39;mixed&#39; if mixed else &#39;pure &#39;}: &#34;
                    else:
                        extraInfo = &#34;&#34;
                    fh.write(
                        f&#34;{nl}\t{extraInfo}{tagRep:&lt;18} &#34;
                        f&#34;{attRep:&lt;18} {amount:&gt;5}x {val}\n&#34;
                    )
                    infoLines += 1
                    for (val, amount) in atts[1:]:
                        fh.write(
                            f&#34;&#34;&#34;\t{&#39;&#39;:&lt;7}{&#39;&#39;:&lt;18} {&#39;&#34;&#39;:&lt;18} {amount:&gt;5}x {val}\n&#34;&#34;&#34;
                        )
                        infoLines += 1

                def writeTagInfo(tag, tagInfo):
                    nonlocal infoLines
                    tags = sorted(tagInfo.items())
                    (att, attInfo) = tags[0]
                    writeAttInfo(tag, att, attInfo)
                    infoLines += 1
                    for (att, attInfo) in tags[1:]:
                        writeAttInfo(&#34;&#34;, att, attInfo)

                for (kind, label) in kindLabels.items():
                    fh.write(f&#34;\n{label}\n&#34;)
                    for (tag, tagInfo) in sorted(analysis[kind].items()):
                        writeTagInfo(tag, tagInfo)

            console(f&#34;{infoLines} info line(s) written to {reportFile}&#34;)

        def writeDoc():
            teiUrl = &#34;https://tei-c.org/release/doc/tei-p5-doc/en/html&#34;
            elUrlPrefix = f&#34;{teiUrl}/ref-&#34;
            attUrlPrefix = f&#34;{teiUrl}/REF-ATTS.html#&#34;
            docFile = f&#34;{docsDir}/elements.md&#34;
            with open(docFile, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                fh.write(
                    dedent(
                        &#34;&#34;&#34;
                        # Element and attribute inventory

                        Table of contents

                        &#34;&#34;&#34;
                    )
                )
                for label in kindLabels.values():
                    labelAnchor = label.replace(&#34; &#34;, &#34;-&#34;)
                    fh.write(f&#34;*\t[{label}](#{labelAnchor})\n&#34;)

                fh.write(&#34;\n&#34;)

                tableHeader = dedent(
                    &#34;&#34;&#34;
                    element | attribute | value | amount
                    --- | --- | --- | ---
                    &#34;&#34;&#34;
                )

                def writeAttInfo(tag, att, attInfo):
                    tagRep = &#34; &#34; if tag == &#34;&#34; else f&#34;[{tag}]({elUrlPrefix}{tag}.html)&#34;
                    attRep = &#34; &#34; if att == &#34;&#34; else f&#34;[{att}]({attUrlPrefix}{att})&#34;
                    atts = sorted(attInfo.items())
                    (val, amount) = atts[0]
                    valRep = f&#34;`{val}`&#34; if val else &#34;&#34;
                    fh.write(f&#34;{tagRep} | {attRep} | {valRep} | {amount}\n&#34;)
                    for (val, amount) in atts[1:]:
                        valRep = f&#34;`{val}`&#34; if val else &#34;&#34;
                        fh.write(f&#34;&#34;&#34;\u00a0| | {valRep} | {amount}\n&#34;&#34;&#34;)

                def writeTagInfo(tag, tagInfo):
                    tags = sorted(tagInfo.items())
                    (att, attInfo) = tags[0]
                    writeAttInfo(tag, att, attInfo)
                    for (att, attInfo) in tags[1:]:
                        writeAttInfo(&#34;&#34;, att, attInfo)

                for (kind, label) in kindLabels.items():
                    fh.write(f&#34;## {label}\n{tableHeader}&#34;)
                    for (tag, tagInfo) in sorted(analysis[kind].items()):
                        writeTagInfo(tag, tagInfo)
                    fh.write(&#34;\n&#34;)

        def filterError(msg):
            return msg == (
                &#34;Element &#39;graphic&#39;, attribute &#39;url&#39;: [facet &#39;pattern&#39;] &#34;
                &#34;The value &#39;&#39; is not accepted by the pattern &#39;\\S+&#39;.&#34;
            )

        NS_RE = re.compile(r&#34;&#34;&#34;\{[^}]+}&#34;&#34;&#34;)

        def doXMLFile(xmlPath):
            tree = etree.parse(xmlPath, parser)
            if validator is not None and not validator.validate(tree):
                theseErrors = []
                for entry in validator.error_log:
                    msg = entry.message
                    msg = NS_RE.sub(&#34;&#34;, msg)
                    if filterError(msg):
                        continue
                    # domain = entry.domain_name
                    # typ = entry.type_name
                    level = entry.level_name
                    line = entry.line
                    col = entry.column
                    address = f&#34;{line}:{col}&#34;
                    theseErrors.append(f&#34;{address:&lt;6} {level:} {msg}\n&#34;)
                if len(theseErrors):
                    console(&#34;ERROR\n&#34;)
                    errors.append((xmlFile, theseErrors))
                return

            root = tree.getroot()
            analyse(root, analysis)

        if sectionModel == &#34;I&#34;:
            i = 0
            for (xmlFolder, xmlFiles) in self.getXML():
                console(f&#34;Start folder {xmlFolder}:&#34;)
                for xmlFile in xmlFiles:
                    i += 1
                    console(f&#34;\r{i:&gt;4} {xmlFile:&lt;50}&#34;, newline=False)
                    xmlPath = f&#34;{sourceDir}/{xmlFolder}/{xmlFile}&#34;
                    doXMLFile(xmlPath)
                console(&#34;&#34;)
                console(f&#34;End   folder {xmlFolder}&#34;)

        elif sectionModel == &#34;II&#34;:
            xmlFile = self.getXML()
            if xmlFile is None:
                console(&#34;No XML files found!&#34;)
                return False

            xmlPath = f&#34;{sourceDir}/{xmlFile}&#34;
            doXMLFile(xmlPath)

        console(&#34;&#34;)
        writeReport()
        writeDoc()
        writeErrors()
        writeNamespaces()

    # SET UP CONVERSION

    def getConverter(self):
        &#34;&#34;&#34;Initializes a converter.

        Returns
        -------
        object
            The `tf.convert.walker.CV` converter object, initialized.
        &#34;&#34;&#34;
        tfPath = self.tfPath

        TF = Fabric(locations=tfPath)
        return CV(TF)

    # DIRECTOR

    def getDirector(self):
        &#34;&#34;&#34;Factory for the director function.

        The `tf.convert.walker` relies on a corpus dependent `director` function
        that walks through the source data and spits out actions that
        produces the TF dataset.

        The director function that walks through the TEI input must be conditioned
        by the properties defined in the TEI schema and the customised schema, if any,
        that describes the source.

        Also some special additions need to be programmed, such as an extra section
        level, word boundaries, etc.

        We collect all needed data, store it, and define a local director function
        that has access to this data.

        Returns
        -------
        function
            The local director function that has been constructed.
        &#34;&#34;&#34;
        TEI_HEADER = &#34;teiHeader&#34;

        TEXT_ANCESTOR = &#34;text&#34;
        TEXT_ANCESTORS = set(
            &#34;&#34;&#34;
            front
            body
            back
            group
            &#34;&#34;&#34;.strip().split()
        )
        CHUNK_PARENTS = TEXT_ANCESTORS | {TEI_HEADER}

        CHUNK_ELEMS = set(
            &#34;&#34;&#34;
            facsimile
            fsdDecl
            sourceDoc
            standOff
            &#34;&#34;&#34;.strip().split()
        )

        PASS_THROUGH = set(
            &#34;&#34;&#34;
            TEI
            &#34;&#34;&#34;.strip().split()
        )

        # CHECKING

        HY = &#34;\u2010&#34;  # hyphen

        IN_WORD_HYPHENS = {HY, &#34;-&#34;}

        ZWSP = &#34;\u200b&#34;  # zero-width space

        sourceDir = self.sourceDir
        wordAsSlot = self.wordAsSlot
        featureMeta = self.featureMeta
        intFeatures = self.intFeatures
        transform = self.transform
        chunkLevel = self.chunkLevel

        transformFunc = (
            (lambda x: x)
            if transform is None
            else (lambda x: BytesIO(transform(x).encode(&#34;utf-8&#34;)))
        )

        parser = self.getParser()
        self.getElementInfo()

        # WALKERS

        WHITE_TRIM_RE = re.compile(r&#34;\s+&#34;, re.S)
        NON_NAME_RE = re.compile(r&#34;[^a-zA-Z0-9_]+&#34;, re.S)

        NOTE_LIKE = set(
            &#34;&#34;&#34;
            note
            &#34;&#34;&#34;.strip().split()
        )
        EMPTY_ELEMENTS = set(
            &#34;&#34;&#34;
            addSpan
            alt
            anchor
            anyElement
            attRef
            binary
            caesura
            catRef
            cb
            citeData
            classRef
            conversion
            damageSpan
            dataFacet
            default
            delSpan
            elementRef
            empty
            equiv
            fsdLink
            gb
            handShift
            iff
            lacunaEnd
            lacunaStart
            lb
            link
            localProp
            macroRef
            milestone
            move
            numeric
            param
            path
            pause
            pb
            ptr
            redo
            refState
            specDesc
            specGrpRef
            symbol
            textNode
            then
            undo
            unicodeProp
            unihanProp
            variantEncoding
            when
            witEnd
            witStart
            &#34;&#34;&#34;.strip().split()
        )
        # N.B. We will alway generate newlines at the closing tags of
        # elements that occur in pure elements
        NEWLINE_ELEMENTS = set(
            &#34;&#34;&#34;
            ab
            cb
            l
            lb
            lg
            list
            p
            pb
            seg
            table
            u
            &#34;&#34;&#34;.strip().split()
        )

        def makeNameLike(x):
            return NON_NAME_RE.sub(&#34;_&#34;, x).strip(&#34;_&#34;)

        def walkNode(cv, cur, node):
            &#34;&#34;&#34;Internal function to deal with a single element.

            Will be called recursively.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            node: object
                An lxml element node.
            &#34;&#34;&#34;
            tag = etree.QName(node.tag).localname
            cur[NEST].append(tag)

            beforeChildren(cv, cur, node, tag)

            for child in node.iterchildren(tag=etree.Element):
                walkNode(cv, cur, child)

            afterChildren(cv, cur, node, tag)
            cur[NEST].pop()
            afterTag(cv, cur, node, tag)

        def isChapter(cur):
            &#34;&#34;&#34;Whether the current element counts as a chapter node.

            ## Model I

            Not relevant: there are no chapter nodes inside an XML file.

            ## Model II

            Chapters are the highest section level (the only lower level is chunks).

            Chapters come in two kinds:

            *   the TEI header;
            *   the immediate children of `&lt;text&gt;`
                except `&lt;front&gt;`, `&lt;body&gt;`, `&lt;back&gt;`, `&lt;group&gt;`;
            *   the immediate children of
                `&lt;front&gt;`, `&lt;body&gt;`, `&lt;back&gt;`, `&lt;group&gt;`.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            sectionModel = self.sectionModel

            if sectionModel == &#34;II&#34;:
                nest = cur[NEST]
                nNest = len(nest)

                if nNest &gt; 0 and nest[-1] in EMPTY_ELEMENTS:
                    return False

                return nNest &gt; 0 and (
                    nest[-1] == TEI_HEADER
                    or (
                        nNest &gt; 1
                        and (
                            nest[-2] in TEXT_ANCESTORS
                            or nest[-2] == TEXT_ANCESTOR
                            and nest[-1] not in TEXT_ANCESTORS
                        )
                    )
                )

            return False

        def isChunk(cur):
            &#34;&#34;&#34;Whether the current element counts as a chunk node.

            ## Model I

            Chunks are the lowest section level (the higher levels are folders
            and then files)

            Chunks are the immediate children of the `&lt;teiHeader&gt;` and the `&lt;body&gt;`
            elements, and a few other elements also count as chunks.

            ## Model II

            Chunks are the lowest section level (the only higher level is chapters).

            Chunks are the immediate children of the chapters, and they come in two
            kinds: the ones that are `&lt;p&gt;` elements, and the rest.

            Deviation from this rule:

            *   If a chapter is a mixed content node, then it is also a chunk.
                and its subelements are not chunks

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            sectionModel = self.sectionModel

            nest = cur[NEST]
            nNest = len(nest)

            if sectionModel == &#34;II&#34;:
                meChptChnk = isChapter(cur) and cur[NEST][-1] not in cur[&#34;pureElems&#34;]
                return nNest &gt; 1 and (
                    meChptChnk
                    or (
                        nest[-2] == TEI_HEADER
                        or (
                            nNest &gt; 2
                            and (
                                nest[-3] in TEXT_ANCESTORS
                                and nest[-1] not in EMPTY_ELEMENTS
                                or nest[-3] == TEXT_ANCESTOR
                                and nest[-2] not in TEXT_ANCESTORS
                            )
                            and cur[NEST][-2] in cur[&#34;pureElems&#34;]
                        )
                    )
                )

            return nNest &gt; 0 and (
                nest[-1] in CHUNK_ELEMS
                or (
                    nNest &gt; 1
                    and (
                        nest[-2] in CHUNK_PARENTS
                        and nest[-1] not in EMPTY_ELEMENTS
                        or nest[-2] == TEXT_ANCESTOR
                        and nest[-1] not in TEXT_ANCESTORS
                    )
                )
            )

        def isPure(cur):
            &#34;&#34;&#34;Whether the current tag has pure content.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            nest = cur[NEST]
            return len(nest) == 0 or len(nest) &gt; 0 and nest[-1] in cur[&#34;pureElems&#34;]

        def isEndInPure(cur):
            &#34;&#34;&#34;Whether the current end tag occurs in an element with pure content.

            If that is the case, then it is very likely that the end tag also
            marks the end of the current word.

            And we should not strip spaces after it.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            nest = cur[NEST]
            return len(nest) &gt; 1 and nest[-2] in cur[&#34;pureElems&#34;]

        def startWord(cv, cur, ch):
            &#34;&#34;&#34;Start a word node if necessary.

            Whenever we encounter a character, we determine
            whether it starts or ends a word, and if it starts
            one, this function takes care of the necessary actions.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            ch: string
                A single character, the next slot in the result data.
            &#34;&#34;&#34;
            curWord = cur[WORD]
            if not curWord:
                prevWord = cur[&#34;prevWord&#34;]
                if prevWord is not None:
                    cv.feature(prevWord, after=cur[&#34;afterStr&#34;])
                if ch is not None:
                    if wordAsSlot:
                        curWord = cv.slot()
                    else:
                        curWord = cv.node(WORD)
                    cur[WORD] = curWord
                    addSlotFeatures(cv, cur, curWord)

            if ch is not None:
                cur[&#34;wordStr&#34;] += ch

        def finishWord(cv, cur, ch, withNewline):
            &#34;&#34;&#34;Terminate a word node if necessary.

            Whenever we encounter a character, we determine
            whether it starts or ends a word, and if it ends
            one, this function takes care of the necessary actions.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            ch: string
                A single character, the next slot in the result data.
            withNewline:
                Whether to add a newline after the word.
            &#34;&#34;&#34;
            curWord = cur[WORD]
            if curWord:
                cv.feature(curWord, str=cur[&#34;wordStr&#34;])
                if not wordAsSlot:
                    cv.terminate(curWord)
                cur[WORD] = None
                cur[&#34;wordStr&#34;] = &#34;&#34;
                cur[&#34;prevWord&#34;] = curWord
                cur[&#34;afterStr&#34;] = &#34;&#34;

            if ch is not None:
                cur[&#34;afterStr&#34;] += ch
            if withNewline:
                cur[&#34;afterStr&#34;] = cur[&#34;afterStr&#34;].rstrip() + &#34;\n&#34;
                if not wordAsSlot:
                    addNewline(cv, cur)

        def addEmpty(cv, cur):
            &#34;&#34;&#34;Add an empty slot.

            We also terminate the current word.
            If words are slots, the empty slot is a word on its own.

            Returns
            -------
            node
                The empty slot
            &#34;&#34;&#34;
            finishWord(cv, cur, None, False)
            startWord(cv, cur, ZWSP)
            emptyNode = cur[WORD]
            cv.feature(emptyNode, empty=1)

            if not wordAsSlot:
                emptyNode = cv.slot()
                cv.feature(emptyNode, ch=ZWSP, empty=1)

            finishWord(cv, cur, None, False)

            return emptyNode

        def addSlotFeatures(cv, cur, s):
            &#34;&#34;&#34;Add generic features to a slot.

            Whenever we encounter a character, we add it as a new slot, unless
            `wordAsSlot` is in force. In that case we suppress the triggering of a
            slot node.
            If needed, we start/terminate word nodes as well.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            s: slot
                A previously added (slot) node
            &#34;&#34;&#34;
            if cur[&#34;inHeader&#34;]:
                cv.feature(s, is_meta=1)
            if cur[&#34;inNote&#34;]:
                cv.feature(s, is_note=1)
            for (r, stack) in cur.get(&#34;rend&#34;, {}).items():
                if len(stack) &gt; 0:
                    cv.feature(s, **{f&#34;rend_{r}&#34;: 1})

        def addSlot(cv, cur, ch):
            &#34;&#34;&#34;Add a slot.

            Whenever we encounter a character, we add it as a new slot, unless
            `wordAsSlot` is in force. In that case we suppress the triggering of a
            slot node.
            If needed, we start/terminate word nodes as well.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            ch: string
                A single character, the next slot in the result data.
            &#34;&#34;&#34;
            if ch is None or ch.isalnum() or ch in IN_WORD_HYPHENS:
                startWord(cv, cur, ch)
            else:
                finishWord(cv, cur, ch, False)

            if wordAsSlot:
                s = cur[WORD]
            elif ch is None:
                s = None
            else:
                s = cv.slot()
                cv.feature(s, ch=ch)
            if s is not None:
                addSlotFeatures(cv, cur, s)

        def addNewline(cv, cur):
            &#34;&#34;&#34;Adds a new line.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Only meant for the case where slots are characters.

            Suppressed when not in a lowest-level section.
            &#34;&#34;&#34;
            if chunkLevel in cv.activeTypes():
                s = cv.slot()
                cv.feature(s, ch=&#34;\n&#34;)
                addSlotFeatures(cv, cur, s)

        def beforeChildren(cv, cur, node, tag):
            &#34;&#34;&#34;Actions before dealing with the element&#39;s children.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            node: object
                An lxml element node.
            tag: string
                The tag of the lxml node.
            &#34;&#34;&#34;
            sectionModel = self.sectionModel
            sectionProperties = self.sectionProperties

            atts = {etree.QName(k).localname: v for (k, v) in node.attrib.items()}

            if sectionModel == &#34;II&#34;:
                chapterSection = self.chapterSection
                chunkSection = self.chunkSection

                if isChapter(cur):
                    cur[&#34;chapterNum&#34;] += 1
                    cur[&#34;prevChapter&#34;] = cur.get(CHAPTER, None)
                    cur[CHAPTER] = cv.node(chapterSection)
                    for danglingSlot in cur[&#34;danglingSlots&#34;]:
                        cv.link(cur[CHAPTER], danglingSlot)

                    value = {chapterSection: f&#34;{cur[&#39;chapterNum&#39;]} {tag}&#34;}
                    cv.feature(cur[CHAPTER], **value)
                    cur[&#34;chunkPNum&#34;] = 0
                    cur[&#34;chunkONum&#34;] = 0
                    cur[&#34;prevChunk&#34;] = cur.get(CHUNK, None)
                    cur[CHUNK] = cv.node(chunkSection)
                    for danglingSlot in cur[&#34;danglingSlots&#34;]:
                        cv.link(cur[CHUNK], danglingSlot)
                    cur[&#34;danglingSlots&#34;] = set()
                    cur[&#34;infirstChunk&#34;] = True

                # N.B. A node can count both as chapter and as chunk,
                # e.g. a &lt;trailer&gt; sibling of the chapter &lt;div&gt;s
                # A trailer has mixed content, so its subelements aren&#39;t typical chunks.
                if isChunk(cur):
                    if cur[&#34;infirstChunk&#34;]:
                        cur[&#34;infirstChunk&#34;] = False
                    else:
                        cur[CHUNK] = cv.node(chunkSection)
                        for danglingSlot in cur[&#34;danglingSlots&#34;]:
                            cv.link(cur[CHUNK], danglingSlot)
                        cur[&#34;danglingSlots&#34;] = set()
                    if tag == &#34;p&#34;:
                        cur[&#34;chunkPNum&#34;] += 1
                        cn = cur[&#34;chunkPNum&#34;]
                    else:
                        cur[&#34;chunkONum&#34;] -= 1
                        cn = cur[&#34;chunkONum&#34;]
                    value = {chunkSection: cn}
                    cv.feature(cur[CHUNK], **value)

                if tag == sectionProperties[&#34;element&#34;]:
                    criticalAtts = sectionProperties[&#34;attributes&#34;]
                    match = True
                    for (k, v) in criticalAtts.items():
                        if atts.get(k, None) != v:
                            match = False
                            break
                    if match:
                        heading = etree.tostring(
                            node, encoding=&#34;unicode&#34;, method=&#34;text&#34;, with_tail=False
                        ).replace(&#34;\n&#34;, &#34; &#34;)
                        value = {chapterSection: heading}
                        cv.feature(cur[CHAPTER], **value)
                        chapterNum = cur[&#34;chapterNum&#34;]
                        console(
                            f&#34;\rchapter {chapterNum:&gt;4} {heading:&lt;50}&#34;, newline=False
                        )
            else:
                chunkSection = self.chunkSection

                if isChunk(cur):
                    cur[&#34;chunkNum&#34;] += 1
                    cur[&#34;prevChunk&#34;] = cur.get(CHUNK, None)
                    cur[CHUNK] = cv.node(chunkSection)
                    for danglingSlot in cur[&#34;danglingSlots&#34;]:
                        cv.link(cur[CHUNK], danglingSlot)
                    cur[&#34;danglingSlots&#34;] = set()
                    value = {chunkSection: cur[&#34;chunkNum&#34;]}
                    cv.feature(cur[CHUNK], **value)

            if tag == TEI_HEADER:
                cur[&#34;inHeader&#34;] = True
                if sectionModel == &#34;II&#34;:
                    value = {chapterSection: &#34;TEI header&#34;}
                    cv.feature(cur[CHAPTER], **value)
            if tag in NOTE_LIKE:
                cur[&#34;inNote&#34;] = True
                finishWord(cv, cur, None, False)

            if tag not in PASS_THROUGH:
                curNode = cv.node(tag)
                if wordAsSlot:
                    if cur[WORD]:
                        cv.link(curNode, [cur[WORD][1]])
                cur[&#34;elems&#34;].append(curNode)
                if len(atts):
                    cv.feature(curNode, **atts)
                    if &#34;rend&#34; in atts:
                        rValue = atts[&#34;rend&#34;]
                        r = makeNameLike(rValue)
                        if r:
                            cur.setdefault(&#34;rend&#34;, {}).setdefault(r, []).append(True)
            if node.text:
                textMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, node.text)
                if isPure(cur):
                    if textMaterial and textMaterial != &#34; &#34;:
                        console(
                            &#34;WARNING: Text material at the start of &#34;
                            f&#34;pure-content element &lt;{tag}&gt;&#34;
                        )
                        stack = &#34;-&#34;.join(cur[NEST])
                        console(f&#34;\tElement stack: {stack}&#34;)
                        console(f&#34;\tMaterial: `{textMaterial}`&#34;)
                else:
                    for ch in textMaterial:
                        addSlot(cv, cur, ch)

        def afterChildren(cv, cur, node, tag):
            &#34;&#34;&#34;Node actions after dealing with the children, but before the end tag.

            Here we make sure that the newline elements will get their last slot
            having a newline at the end of their `after` feature.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            node: object
                An lxml element node.
            tag: string
                The tag of the lxml node.
            &#34;&#34;&#34;
            sectionModel = self.sectionModel
            isChap = isChapter(cur)
            isChnk = isChunk(cur)

            hasFinishedWord = False

            if tag not in PASS_THROUGH:
                if isEndInPure(cur) or tag in NEWLINE_ELEMENTS:
                    finishWord(cv, cur, None, True)
                    hasFinishedWord = True

                curNode = cur[&#34;elems&#34;].pop()

                slots = cv.linked(curNode)

                if not len(slots):
                    lastSlot = addEmpty(cv, cur)
                    if cur[&#34;inHeader&#34;]:
                        cv.feature(lastSlot, is_meta=1)
                    if cur[&#34;inNote&#34;]:
                        cv.feature(lastSlot, is_note=1)
                    # take care that this empty slot falls under all sections
                    # for folders and files this is already guaranteed
                    # We need only to watch out for chapters and chunks
                    if cur.get(CHUNK, None) is None:
                        prevChunk = cur.get(&#34;prevChunk&#34;, None)
                        if prevChunk is None:
                            cur[&#34;danglingSlots&#34;].add(lastSlot)
                        else:
                            cv.link(prevChunk, lastSlot)
                    if sectionModel == &#34;II&#34;:
                        if cur.get(CHAPTER, None) is None:
                            prevChapter = cur.get(&#34;prevChapter&#34;, None)
                            if prevChapter is None:
                                cur[&#34;danglingSlots&#34;].add(lastSlot)
                            else:
                                cv.link(prevChapter, lastSlot)

                cv.terminate(curNode)

            if isChnk:
                if not hasFinishedWord:
                    finishWord(cv, cur, None, True)
                cv.terminate(cur[CHUNK])
            if sectionModel == &#34;II&#34;:
                if isChap:
                    if not hasFinishedWord:
                        finishWord(cv, cur, None, True)
                    cv.terminate(cur[CHAPTER])

        def afterTag(cv, cur, node, tag):
            &#34;&#34;&#34;Node actions after dealing with the children and after the end tag.

            This is the place where we proces the `tail` of an lxml node: the
            text material after the element and before the next open/close
            tag of any element.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            node: object
                An lxml element node.
            tag: string
                The tag of the lxml node.
            &#34;&#34;&#34;
            if tag == TEI_HEADER:
                cur[&#34;inHeader&#34;] = False
            elif tag in NOTE_LIKE:
                cur[&#34;inNote&#34;] = False

            if tag not in PASS_THROUGH:
                atts = {etree.QName(k).localname: v for (k, v) in node.attrib.items()}
                if &#34;rend&#34; in atts:
                    rValue = atts[&#34;rend&#34;]
                    r = makeNameLike(rValue)
                    if r:
                        cur[&#34;rend&#34;][r].pop()

            if node.tail:
                tailMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, node.tail)
                if isPure(cur):
                    if tailMaterial and tailMaterial != &#34; &#34;:
                        elem = cur[NEST][-1]
                        console(
                            &#34;WARNING: Text material after &#34;
                            f&#34;&lt;{tag}&gt; in pure-content element &lt;{elem}&gt;&#34;
                        )
                        stack = &#34;-&#34;.join(cur[NEST])
                        console(f&#34;\tElement stack: {stack}-{tag}&#34;)
                        console(f&#34;\tMaterial: `{tailMaterial}`&#34;)
                else:
                    for ch in tailMaterial:
                        addSlot(cv, cur, ch)

        def director(cv):
            &#34;&#34;&#34;Director function.

            Here we program a walk through the TEI sources.
            At every step of the walk we fire some actions that build TF nodes
            and assign features for them.

            Because everything is rather dynamic, we generate fairly standard
            metadata for the features, namely a link to the tei website.

            Parameters
            ----------
            cv: object
                The convertor object, needed to issue actions.
            &#34;&#34;&#34;
            sectionModel = self.sectionModel
            elementDefs = self.elementDefs

            cur = {}
            cur[&#34;pureElems&#34;] = {
                x for (x, (typ, mixed)) in elementDefs.items() if not mixed
            }

            if sectionModel == &#34;I&#34;:
                folderSection = self.folderSection
                fileSection = self.fileSection

                i = 0
                for (xmlFolder, xmlFiles) in self.getXML():
                    console(f&#34;Start folder {xmlFolder}:&#34;)

                    cur[FOLDER] = cv.node(folderSection)
                    value = {folderSection: xmlFolder}
                    cv.feature(cur[FOLDER], **value)

                    for xmlFile in xmlFiles:
                        i += 1
                        console(f&#34;\r{i:&gt;4} {xmlFile:&lt;50}&#34;, newline=False)

                        cur[FILE] = cv.node(fileSection)
                        value = {fileSection: xmlFile.removesuffix(&#34;.xml&#34;)}
                        cv.feature(cur[FILE], **value)

                        with open(
                            f&#34;{sourceDir}/{xmlFolder}/{xmlFile}&#34;, encoding=&#34;utf8&#34;
                        ) as fh:
                            text = fh.read()
                            text = transformFunc(text)
                            tree = etree.parse(text, parser)
                            root = tree.getroot()
                            cur[&#34;inHeader&#34;] = False
                            cur[&#34;inNote&#34;] = False
                            cur[NEST] = []
                            cur[&#34;elems&#34;] = []
                            cur[&#34;chunkNum&#34;] = 0
                            cur[&#34;prevChunk&#34;] = None
                            cur[&#34;danglingSlots&#34;] = set()
                            cur[WORD] = None
                            cur[&#34;prevWord&#34;] = None
                            cur[&#34;wordStr&#34;] = &#34;&#34;
                            cur[&#34;afterStr&#34;] = &#34;&#34;
                            walkNode(cv, cur, root)

                        addSlot(cv, cur, None)
                        cv.terminate(cur[FILE])

                    console(&#34;&#34;)
                    console(f&#34;End   folder {xmlFolder}&#34;)
                    cv.terminate(cur[FOLDER])

            elif sectionModel == &#34;II&#34;:
                xmlFile = self.getXML()
                if xmlFile is None:
                    console(&#34;No XML files found!&#34;)
                    return False

                with open(f&#34;{sourceDir}/{xmlFile}&#34;, encoding=&#34;utf8&#34;) as fh:
                    text = fh.read()
                    text = transformFunc(text)
                    tree = etree.parse(text, parser)
                    root = tree.getroot()
                    cur[&#34;inHeader&#34;] = False
                    cur[&#34;inNote&#34;] = False
                    cur[NEST] = []
                    cur[&#34;elems&#34;] = []
                    cur[&#34;chapterNum&#34;] = 0
                    cur[&#34;chunkPNum&#34;] = 0
                    cur[&#34;chunkONum&#34;] = 0
                    cur[&#34;prevChunk&#34;] = None
                    cur[&#34;prevChapter&#34;] = None
                    cur[&#34;danglingSlots&#34;] = set()
                    cur[WORD] = None
                    cur[&#34;prevWord&#34;] = None
                    cur[&#34;wordStr&#34;] = &#34;&#34;
                    cur[&#34;afterStr&#34;] = &#34;&#34;
                    for child in root.iterchildren(tag=etree.Element):
                        walkNode(cv, cur, child)

                addSlot(cv, cur, None)

            console(&#34;&#34;)

            for fName in featureMeta:
                if not cv.occurs(fName):
                    cv.meta(fName)
            for fName in cv.features():
                if fName not in featureMeta:
                    if fName.startswith(&#34;rend_&#34;):
                        r = fName[5:]
                        cv.meta(
                            fName,
                            description=f&#34;whether text is to be rendered as {r}&#34;,
                            valueType=&#34;int&#34;,
                        )
                        intFeatures.add(fName)
                    else:
                        cv.meta(
                            fName,
                            description=f&#34;this is TEI attribute {fName}&#34;,
                            valueType=&#34;str&#34;,
                        )
            console(&#34;source reading done&#34;)
            return True

        return director

    def convertTask(self):
        &#34;&#34;&#34;Implementation of the &#34;convert&#34; task.

        It sets up the `tf.convert.walker` machinery and runs it.

        Returns
        -------
        boolean
            Whether the conversion was successful.
        &#34;&#34;&#34;
        if not self.good:
            return

        wordAsSlot = self.wordAsSlot
        sectionModel = self.sectionModel
        tfPath = self.tfPath
        sourceDir = self.sourceDir
        chunkSection = self.chunkSection
        levelNames = self.levelNames

        console(f&#34;TEI to TF converting: {ux(sourceDir)} =&gt; {ux(tfPath)}&#34;)

        slotType = WORD if wordAsSlot else CHAR

        sectionFeatures = &#34;,&#34;.join(levelNames)
        sectionTypes = &#34;,&#34;.join(levelNames)

        textFeatures = &#34;{str}{after}&#34; if wordAsSlot else &#34;{ch}&#34;
        otext = {
            &#34;fmt:text-orig-full&#34;: textFeatures,
            &#34;sectionFeatures&#34;: sectionFeatures,
            &#34;sectionTypes&#34;: sectionTypes,
            &#34;levelConstraints&#34;: &#34;note &lt; chunk, p&#34;,
        }
        intFeatures = {&#34;empty&#34;, chunkSection}
        featureMeta = dict(
            str=dict(description=&#34;the text of a word&#34;),
            after=dict(description=&#34;the text after a word till the next word&#34;),
            empty=dict(
                description=&#34;whether a slot has been inserted in an empty element&#34;
            ),
            is_meta=dict(
                description=&#34;whether a slot or word is in the teiHeader element&#34;
            ),
            is_note=dict(description=&#34;whether a slot or word is in the note element&#34;),
        )
        featureMeta[chunkSection] = dict(
            description=f&#34;number of a {chunkSection} within a document&#34;
        )

        if not wordAsSlot:
            featureMeta[&#34;ch&#34;] = dict(description=&#34;the unicode character of a slot&#34;)
        if sectionModel == &#34;II&#34;:
            chapterSection = self.chapterSection
            featureMeta[chapterSection] = dict(description=f&#34;name of {chapterSection}&#34;)
        else:
            folderSection = self.folderSection
            fileSection = self.fileSection
            featureMeta[folderSection] = dict(
                description=f&#34;name of source {folderSection}&#34;
            )
            featureMeta[fileSection] = dict(description=f&#34;name of source {fileSection}&#34;)

        self.intFeatures = intFeatures
        self.featureMeta = featureMeta

        schema = self.schema
        tfVersion = self.tfVersion
        generic = self.generic
        generic[&#34;sourceFormat&#34;] = &#34;TEI&#34;
        generic[&#34;version&#34;] = tfVersion
        if schema:
            generic[&#34;schema&#34;] = schema

        initTree(tfPath, fresh=True, gentle=True)

        cv = self.getConverter()

        self.good = cv.walk(
            self.getDirector(),
            slotType,
            otext=otext,
            generic=generic,
            intFeatures=intFeatures,
            featureMeta=featureMeta,
            generateTf=True,
        )

    def loadTask(self):
        &#34;&#34;&#34;Implementation of the &#34;load&#34; task.

        It loads the tf data that resides in the directory where the &#34;convert&#34; task
        deliver its results.

        During loading there are additional checks. If they succeed, we have evidence
        that we have a valid TF dataset.

        Also, during the first load intensive precomputation of TF data takes place,
        the results of which will be cached in the invisible `.tf` directory there.

        That makes the TF data ready to be loaded fast, next time it is needed.

        Returns
        -------
        boolean
            Whether the loading was successful.
        &#34;&#34;&#34;
        if not self.good:
            return

        tfPath = self.tfPath

        if not dirExists(tfPath):
            console(f&#34;Directory {ux(tfPath)} does not exist.&#34;)
            console(&#34;No tf found, nothing to load&#34;)
            self.good = False
            return

        TF = Fabric(locations=[tfPath])
        allFeatures = TF.explore(silent=True, show=True)
        loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
        api = TF.load(loadableFeatures, silent=False)
        if api:
            console(f&#34;max node = {api.F.otype.maxNode}&#34;)
            self.good = True
            return

        self.good = False

    # APP CREATION/UPDATING

    def appTask(self, tokenBased=False):
        &#34;&#34;&#34;Implementation of the &#34;app&#34; task.

        It creates/updates a corpus-specific app.
        There should be a valid TF dataset in place, because some
        settings in the app derive from it.

        Returns
        -------
        boolean
            Whether the operation was successful.
        &#34;&#34;&#34;
        if not self.good:
            return

        refDir = self.refDir
        myDir = self.myDir
        appConfig = self.appConfig
        force = self.force
        wordAsSlot = self.wordAsSlot
        sectionModel = self.sectionModel
        sectionProperties = self.sectionProperties
        docsDir = self.docsDir

        initTree(docsDir)

        itemSpecs = (
            (&#34;about&#34;, &#34;docs&#34;, &#34;about.md&#34;, False),
            (&#34;trans&#34;, (&#34;app&#34;, &#34;docs&#34;), &#34;transcription.md&#34;, True),
            (&#34;logo&#34;, &#34;app/static&#34;, &#34;logo.png&#34;, True),
            (&#34;display&#34;, &#34;app/static&#34;, &#34;display.css&#34;, True),
            (&#34;config&#34;, &#34;app&#34;, &#34;config.yaml&#34;, True),
            (&#34;app&#34;, &#34;app&#34;, &#34;app.py&#34;, True),
        )
        items = {
            s[0]: dict(parent=s[1], file=s[2], hasTemplate=s[3]) for s in itemSpecs
        }
        cssInfo = makeCssInfo()

        def createConfig(itemSource, itemTarget):
            tfVersion = self.tfVersion

            with open(itemSource, encoding=&#34;utf8&#34;) as fh:
                text = fh.read()

            version = tfVersion.removesuffix(&#34;pre&#34;) if tokenBased else tfVersion
            text = text.replace(&#34;Â«versionÂ»&#34;, f&#39;&#34;{version}&#34;&#39;)

            settings = yaml.load(text, Loader=yaml.FullLoader)
            mergeDict(settings, appConfig)

            if tokenBased:
                if &#34;typeDisplay&#34; in settings and &#34;word&#34; in settings[&#34;typeDisplay&#34;]:
                    del settings[&#34;typeDisplay&#34;][&#34;word&#34;]
            text = yaml.dump(settings, allow_unicode=True)

            with open(itemTarget, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                fh.write(text)

        def createDisplay(itemSource, itemTarget):
            &#34;&#34;&#34;Copies and tweaks the display.css file of an TF app.

            We generate css code for a certain text formatting styles,
            triggered by `rend` attributes in the source.
            &#34;&#34;&#34;

            with open(itemSource, encoding=&#34;utf8&#34;) as fh:
                css = fh.read()

            css = css.replace(&#34;Â«rendsÂ»&#34;, cssInfo)

            with open(itemTarget, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                fh.write(css)

        def createApp(itemSource, itemTarget):
            &#34;&#34;&#34;Copies and tweaks the app.py file of an TF app.

            The template app.py provides text formatting functions.
            It retrieves text from features, but that is dependent on
            the settings of the conversion, in particular whether we have words as
            slots or characters.

            Depending on that we insert some code in the template.

            The template contains the string `F.matÃ©rial`, and it will be replaced
            by something like

            ```
            F.ch.v(n)
            ```

            or

            ```
            f&#34;{F.str.v(n)}{F.after.v(n)}&#34;
            ```

            That&#39;s why the variable `materialCode` in the body gets a rather
            unusual value: it is interpreted later on as code.
            &#34;&#34;&#34;

            materialCode = (
                &#34;&#34;&#34;f&#39;{F.str.v(n) or &#34;&#34;}{F.after.v(n) or &#34;&#34;}&#39;&#34;&#34;&#34;
                if wordAsSlot or tokenBased
                else &#39;&#39;&#39;F.ch.v(n) or &#34;&#34;&#39;&#39;&#39;
            )
            rendValues = repr(KNOWN_RENDS)

            with open(itemSource, encoding=&#34;utf8&#34;) as fh:
                code = fh.read()

            code = code.replace(&#34;F.matÃ©rial&#34;, materialCode)
            code = code.replace(&#39;&#34;rÃ¨ndValues&#34;&#39;, rendValues)

            with open(itemTarget, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                fh.write(code)

        def createTranscription(itemSource, itemTarget):
            &#34;&#34;&#34;Copies and tweaks the transcription.md file for a TF corpus.&#34;&#34;&#34;
            org = self.org
            repo = self.repo
            relative = self.relative
            generic = self.generic

            generic = &#34;\n\n&#34;.join(
                f&#34;## {key}\n\n{value}\n&#34; for (key, value) in generic.items()
            )

            with open(itemSource, encoding=&#34;utf8&#34;) as fh:
                template = fh.read()

            result = (
                dedent(
                    f&#34;&#34;&#34;
                # Corpus {org} - {repo}{relative}

                &#34;&#34;&#34;
                )
                + tweakTrans(
                    template, wordAsSlot, tokenBased, sectionModel, sectionProperties
                )
                + dedent(
                    &#34;&#34;&#34;

                    ## See also

                    *   [about](about.md)
                    &#34;&#34;&#34;
                )
            )
            with open(itemTarget, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                fh.write(result)

        def createAbout():
            org = self.org
            repo = self.repo
            relative = self.relative
            generic = self.generic

            generic = &#34;\n\n&#34;.join(
                f&#34;## {key}\n\n{value}\n&#34; for (key, value) in generic.items()
            )

            return (
                dedent(
                    f&#34;&#34;&#34;
                # Corpus {org} - {repo}{relative}

                &#34;&#34;&#34;
                )
                + generic
                + dedent(
                    &#34;&#34;&#34;

                    ## Conversion

                    Converted from TEI to Text-Fabric

                    ## See also

                    *   [transcription](transcription.md)
                    &#34;&#34;&#34;
                )
            )

        console(&#34;App updating ...&#34;)

        for (name, info) in items.items():
            parent = info[&#34;parent&#34;]
            (sourceBit, targetBit) = (
                parent if type(parent) is tuple else (parent, parent)
            )
            file = info[FILE]
            hasTemplate = info[&#34;hasTemplate&#34;]

            targetDir = f&#34;{refDir}/{targetBit}&#34;
            itemTarget = f&#34;{targetDir}/{file}&#34;
            fileParts = file.rsplit(&#34;.&#34;, 1)
            if len(fileParts) == 1:
                fileParts = [file, &#34;&#34;]
            (fileBase, fileExt) = fileParts
            itemTargetGen = f&#34;{targetDir}/{fileBase}_generated.{fileExt}&#34;
            itemExists = fileExists(itemTarget)
            itemGenExists = fileExists(itemTargetGen)

            existRep = &#34;exists &#34; if itemExists else &#34;missing&#34;
            changeRep = &#34;generated&#34; if itemExists else &#34;added   &#34;

            initTree(targetDir, fresh=False)

            target = itemTarget

            if force:
                if itemGenExists:
                    fileRemove(itemTargetGen)
            else:
                if itemExists:
                    target = itemTargetGen

            if force and itemExists and name == &#34;logo&#34;:
                continue

            if hasTemplate:
                sourceDir = f&#34;{myDir}/{sourceBit}&#34;
                itemSource = f&#34;{sourceDir}/{file}&#34;
                (
                    createConfig
                    if name == &#34;config&#34;
                    else createApp
                    if name == &#34;app&#34;
                    else createDisplay
                    if name == &#34;display&#34;
                    else createTranscription
                    if name == &#34;trans&#34;
                    else fileCopy
                )(itemSource, target)

            else:
                with open(target, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                    fh.write(createAbout())
            console(f&#34;\t{name:&lt;7}: {existRep}, {changeRep} {ux(target)}&#34;)

    # START the TEXT-FABRIC BROWSER on this CORPUS

    def browseTask(self):
        &#34;&#34;&#34;Implementation of the &#34;browse&#34; task.

        It gives a shell command to start the text-fabric browser on
        the newly created corpus.
        There should be a valid TF dataset and app configuraiton in place

        Returns
        -------
        boolean
            Whether the operation was successful.
        &#34;&#34;&#34;
        if not self.good:
            return

        org = self.org
        repo = self.repo
        relative = self.relative
        backend = self.backend
        tfVersion = self.tfVersion

        backendOpt = &#34;&#34; if backend == &#34;github&#34; else f&#34;--backend={backend}&#34;
        versionOpt = f&#34;--version={tfVersion}&#34;
        try:
            run(
                (
                    f&#34;text-fabric {org}/{repo}{relative}:clone --checkout=clone &#34;
                    f&#34;{versionOpt} {backendOpt}&#34;
                ),
                shell=True,
            )
        except KeyboardInterrupt:
            pass

    def task(
        self,
        check=False,
        convert=False,
        load=False,
        app=False,
        apptoken=False,
        browse=False,
        test=None,
        force=False,
    ):
        &#34;&#34;&#34;Carry out any task, possibly modified by any flag.

        This is a higher level function that can execute a selection of tasks.

        The tasks will be executed in a fixed order: check, convert load.
        But you can select which one(s) must be executed.

        If multiple tasks must be executed and one fails, the subsequent tasks
        will not be executed.

        Parameters
        ----------
        check: boolean, optional False
            Whether to carry out the &#34;check&#34; task.
        convert: boolean, optional False
            Whether to carry out the &#34;convert&#34; task.
        load: boolean, optional False
            Whether to carry out the &#34;load&#34; task.
        app: boolean, optional False
            Whether to carry out the &#34;app&#34; task.
        apptoken: boolean, optional False
            Whether to carry out the &#34;apptoken&#34; task.
        browse: boolean, optional False
            Whether to carry out the &#34;browse&#34; task&#34;
        test: boolean, optional None
            Whether to run in test mode.
            In test mode only the files in the test set are converted.
        force: boolean, optional False
            Whether the app task should overwrite previously generated files

            If None, it will read its value from the attribute `testMode` of the
            `TEI` object.

        Returns
        -------
        boolean
            Whether all tasks have executed successfully.
        &#34;&#34;&#34;
        if test is not None:
            self.testMode = test

        self.force = force

        if not self.good:
            return

        for (condition, method, kwargs) in (
            (check, self.checkTask, {}),
            (convert, self.convertTask, {}),
            (load, self.loadTask, {}),
            (app, self.appTask, {}),
            (apptoken, self.appTask, dict(tokenBased=True)),
            (browse, self.browseTask, {}),
        ):
            if condition:
                method(**kwargs)

    def run(self, program=None):
        &#34;&#34;&#34;Carry out tasks specified by arguments on the command line.

        The intended use of this module is that it is included by a conversion
        script.
        When that script is invoked, you can pass arguments to specify tasks
        and flags.

        This function inspects those arguments, and runs the specified tasks,
        with the specified flags enabled.

        Parameters
        ----------
        program: string
            The name of the program that you want to display
            in the help string, in case a help text must be displayed.

        Returns
        -------
        integer
            In fact, this function will terminate the conversion program
            an return a status code: 0 for succes, 1 for failure.
        &#34;&#34;&#34;
        programRep = &#34;TEI-converter&#34; if program is None else program
        possibleTasks = {&#34;check&#34;, &#34;convert&#34;, &#34;load&#34;, &#34;app&#34;, &#34;apptoken&#34;, &#34;browse&#34;}
        possibleFlags = {&#34;test&#34;, &#34;force&#34;}
        possibleArgs = possibleTasks | possibleFlags

        args = sys.argv[1:]

        if not len(args) or &#34;--help&#34; in args or &#34;-h&#34; in args:
            self.help(programRep)
            console(&#34;No task specified&#34;)
            sys.exit(-1)

        illegalArgs = {arg for arg in args if arg not in possibleArgs}

        if len(illegalArgs):
            self.help(programRep)
            for arg in illegalArgs:
                console(f&#34;Illegal argument `{arg}`&#34;)
            sys.exit(-1)

        tasks = {arg: True for arg in args if arg in possibleTasks}
        flags = {arg: True for arg in args if arg in possibleFlags}

        self.task(**tasks, **flags)
        if self.good:
            sys.exit(0)
        else:
            sys.exit(1)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="tf.convert.tei.TEI.getParser"><code class="name flex">
<span>def <span class="ident">getParser</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure the lxml parser.</p>
<p>See <a href="https://lxml.de/parsing.html#parser-options">parser options</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>A configured lxml parse object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L836-L852" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def getParser():
    &#34;&#34;&#34;Configure the lxml parser.

    See [parser options](https://lxml.de/parsing.html#parser-options).

    Returns
    -------
    object
        A configured lxml parse object.
    &#34;&#34;&#34;
    return etree.XMLParser(
        remove_blank_text=False,
        collect_ids=False,
        remove_comments=True,
        remove_pis=True,
    )</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.help"><code class="name flex">
<span>def <span class="ident">help</span></span>(<span>program)</span>
</code></dt>
<dd>
<div class="desc"><p>Print a help text to the console.</p>
<p>The intended use of this module is that it is included by a conversion
script.
In order to give help on the command line, here is a pre-baked help text.
Only the name of the conversion script needs to be merged in.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>program</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the program that you want to display
in the help string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L787-L834" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def help(program):
    &#34;&#34;&#34;Print a help text to the console.

    The intended use of this module is that it is included by a conversion
    script.
    In order to give help on the command line, here is a pre-baked help text.
    Only the name of the conversion script needs to be merged in.

    Parameters
    ----------
    program: string
        The name of the program that you want to display
        in the help string.
    &#34;&#34;&#34;

    console(
        f&#34;&#34;&#34;

    Convert TEI to TF.
    There are also commands to check the TEI and to load the TF.

    python3 {program} [tasks/flags] [--help]

    --help: show this text and exit

    tasks:
        a sequence of tasks:
        check:
            just reports on the elements in the source.
        convert:
            just converts TEI to TF
        load:
            just loads the generated TF;
        app:
            just configures the TF-app for the result;
        apptoken:
            just modifies the TF-app to make it token- instead of character-based;
        browse:
            just starts the text-fabric browser on the result;

    flags:
        test:
            run in test mode
        force:
            when generating app files, overwrite previously existing app files
    &#34;&#34;&#34;
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tf.convert.tei.TEI.appTask"><code class="name flex">
<span>def <span class="ident">appTask</span></span>(<span>self, tokenBased=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of the "app" task.</p>
<p>It creates/updates a corpus-specific app.
There should be a valid TF dataset in place, because some
settings in the app derive from it.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether the operation was successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L2337-L2577" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def appTask(self, tokenBased=False):
    &#34;&#34;&#34;Implementation of the &#34;app&#34; task.

    It creates/updates a corpus-specific app.
    There should be a valid TF dataset in place, because some
    settings in the app derive from it.

    Returns
    -------
    boolean
        Whether the operation was successful.
    &#34;&#34;&#34;
    if not self.good:
        return

    refDir = self.refDir
    myDir = self.myDir
    appConfig = self.appConfig
    force = self.force
    wordAsSlot = self.wordAsSlot
    sectionModel = self.sectionModel
    sectionProperties = self.sectionProperties
    docsDir = self.docsDir

    initTree(docsDir)

    itemSpecs = (
        (&#34;about&#34;, &#34;docs&#34;, &#34;about.md&#34;, False),
        (&#34;trans&#34;, (&#34;app&#34;, &#34;docs&#34;), &#34;transcription.md&#34;, True),
        (&#34;logo&#34;, &#34;app/static&#34;, &#34;logo.png&#34;, True),
        (&#34;display&#34;, &#34;app/static&#34;, &#34;display.css&#34;, True),
        (&#34;config&#34;, &#34;app&#34;, &#34;config.yaml&#34;, True),
        (&#34;app&#34;, &#34;app&#34;, &#34;app.py&#34;, True),
    )
    items = {
        s[0]: dict(parent=s[1], file=s[2], hasTemplate=s[3]) for s in itemSpecs
    }
    cssInfo = makeCssInfo()

    def createConfig(itemSource, itemTarget):
        tfVersion = self.tfVersion

        with open(itemSource, encoding=&#34;utf8&#34;) as fh:
            text = fh.read()

        version = tfVersion.removesuffix(&#34;pre&#34;) if tokenBased else tfVersion
        text = text.replace(&#34;Â«versionÂ»&#34;, f&#39;&#34;{version}&#34;&#39;)

        settings = yaml.load(text, Loader=yaml.FullLoader)
        mergeDict(settings, appConfig)

        if tokenBased:
            if &#34;typeDisplay&#34; in settings and &#34;word&#34; in settings[&#34;typeDisplay&#34;]:
                del settings[&#34;typeDisplay&#34;][&#34;word&#34;]
        text = yaml.dump(settings, allow_unicode=True)

        with open(itemTarget, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
            fh.write(text)

    def createDisplay(itemSource, itemTarget):
        &#34;&#34;&#34;Copies and tweaks the display.css file of an TF app.

        We generate css code for a certain text formatting styles,
        triggered by `rend` attributes in the source.
        &#34;&#34;&#34;

        with open(itemSource, encoding=&#34;utf8&#34;) as fh:
            css = fh.read()

        css = css.replace(&#34;Â«rendsÂ»&#34;, cssInfo)

        with open(itemTarget, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
            fh.write(css)

    def createApp(itemSource, itemTarget):
        &#34;&#34;&#34;Copies and tweaks the app.py file of an TF app.

        The template app.py provides text formatting functions.
        It retrieves text from features, but that is dependent on
        the settings of the conversion, in particular whether we have words as
        slots or characters.

        Depending on that we insert some code in the template.

        The template contains the string `F.matÃ©rial`, and it will be replaced
        by something like

        ```
        F.ch.v(n)
        ```

        or

        ```
        f&#34;{F.str.v(n)}{F.after.v(n)}&#34;
        ```

        That&#39;s why the variable `materialCode` in the body gets a rather
        unusual value: it is interpreted later on as code.
        &#34;&#34;&#34;

        materialCode = (
            &#34;&#34;&#34;f&#39;{F.str.v(n) or &#34;&#34;}{F.after.v(n) or &#34;&#34;}&#39;&#34;&#34;&#34;
            if wordAsSlot or tokenBased
            else &#39;&#39;&#39;F.ch.v(n) or &#34;&#34;&#39;&#39;&#39;
        )
        rendValues = repr(KNOWN_RENDS)

        with open(itemSource, encoding=&#34;utf8&#34;) as fh:
            code = fh.read()

        code = code.replace(&#34;F.matÃ©rial&#34;, materialCode)
        code = code.replace(&#39;&#34;rÃ¨ndValues&#34;&#39;, rendValues)

        with open(itemTarget, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
            fh.write(code)

    def createTranscription(itemSource, itemTarget):
        &#34;&#34;&#34;Copies and tweaks the transcription.md file for a TF corpus.&#34;&#34;&#34;
        org = self.org
        repo = self.repo
        relative = self.relative
        generic = self.generic

        generic = &#34;\n\n&#34;.join(
            f&#34;## {key}\n\n{value}\n&#34; for (key, value) in generic.items()
        )

        with open(itemSource, encoding=&#34;utf8&#34;) as fh:
            template = fh.read()

        result = (
            dedent(
                f&#34;&#34;&#34;
            # Corpus {org} - {repo}{relative}

            &#34;&#34;&#34;
            )
            + tweakTrans(
                template, wordAsSlot, tokenBased, sectionModel, sectionProperties
            )
            + dedent(
                &#34;&#34;&#34;

                ## See also

                *   [about](about.md)
                &#34;&#34;&#34;
            )
        )
        with open(itemTarget, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
            fh.write(result)

    def createAbout():
        org = self.org
        repo = self.repo
        relative = self.relative
        generic = self.generic

        generic = &#34;\n\n&#34;.join(
            f&#34;## {key}\n\n{value}\n&#34; for (key, value) in generic.items()
        )

        return (
            dedent(
                f&#34;&#34;&#34;
            # Corpus {org} - {repo}{relative}

            &#34;&#34;&#34;
            )
            + generic
            + dedent(
                &#34;&#34;&#34;

                ## Conversion

                Converted from TEI to Text-Fabric

                ## See also

                *   [transcription](transcription.md)
                &#34;&#34;&#34;
            )
        )

    console(&#34;App updating ...&#34;)

    for (name, info) in items.items():
        parent = info[&#34;parent&#34;]
        (sourceBit, targetBit) = (
            parent if type(parent) is tuple else (parent, parent)
        )
        file = info[FILE]
        hasTemplate = info[&#34;hasTemplate&#34;]

        targetDir = f&#34;{refDir}/{targetBit}&#34;
        itemTarget = f&#34;{targetDir}/{file}&#34;
        fileParts = file.rsplit(&#34;.&#34;, 1)
        if len(fileParts) == 1:
            fileParts = [file, &#34;&#34;]
        (fileBase, fileExt) = fileParts
        itemTargetGen = f&#34;{targetDir}/{fileBase}_generated.{fileExt}&#34;
        itemExists = fileExists(itemTarget)
        itemGenExists = fileExists(itemTargetGen)

        existRep = &#34;exists &#34; if itemExists else &#34;missing&#34;
        changeRep = &#34;generated&#34; if itemExists else &#34;added   &#34;

        initTree(targetDir, fresh=False)

        target = itemTarget

        if force:
            if itemGenExists:
                fileRemove(itemTargetGen)
        else:
            if itemExists:
                target = itemTargetGen

        if force and itemExists and name == &#34;logo&#34;:
            continue

        if hasTemplate:
            sourceDir = f&#34;{myDir}/{sourceBit}&#34;
            itemSource = f&#34;{sourceDir}/{file}&#34;
            (
                createConfig
                if name == &#34;config&#34;
                else createApp
                if name == &#34;app&#34;
                else createDisplay
                if name == &#34;display&#34;
                else createTranscription
                if name == &#34;trans&#34;
                else fileCopy
            )(itemSource, target)

        else:
            with open(target, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
                fh.write(createAbout())
        console(f&#34;\t{name:&lt;7}: {existRep}, {changeRep} {ux(target)}&#34;)</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.browseTask"><code class="name flex">
<span>def <span class="ident">browseTask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of the "browse" task.</p>
<p>It gives a shell command to start the text-fabric browser on
the newly created corpus.
There should be a valid TF dataset and app configuraiton in place</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether the operation was successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L2581-L2613" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def browseTask(self):
    &#34;&#34;&#34;Implementation of the &#34;browse&#34; task.

    It gives a shell command to start the text-fabric browser on
    the newly created corpus.
    There should be a valid TF dataset and app configuraiton in place

    Returns
    -------
    boolean
        Whether the operation was successful.
    &#34;&#34;&#34;
    if not self.good:
        return

    org = self.org
    repo = self.repo
    relative = self.relative
    backend = self.backend
    tfVersion = self.tfVersion

    backendOpt = &#34;&#34; if backend == &#34;github&#34; else f&#34;--backend={backend}&#34;
    versionOpt = f&#34;--version={tfVersion}&#34;
    try:
        run(
            (
                f&#34;text-fabric {org}/{repo}{relative}:clone --checkout=clone &#34;
                f&#34;{versionOpt} {backendOpt}&#34;
            ),
            shell=True,
        )
    except KeyboardInterrupt:
        pass</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.checkTask"><code class="name flex">
<span>def <span class="ident">checkTask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of the "check" task.</p>
<p>It validates the TEI, but only if a schema file has been passed explicitly
when constructing the <code><a title="tf.convert.tei.TEI" href="#tf.convert.tei.TEI">TEI</a></code> object.</p>
<p>Then it makes an inventory of all elements and attributes in the TEI files.</p>
<p>If tags are used in multiple namespaces, it will be reported.</p>
<div class="admonition caution">
<p class="admonition-title">Conflation of namespaces</p>
<p>The TEI to TF conversion does constructs node types and attributes
without taking namespaces into account.
However, the parsing process is namespace aware.</p>
</div>
<p>The inventory lists all elements and attributes, and many attribute values.
But is represents any digit with <code>n</code>, and some attributes that contain
ids or keywords, are reduced to the value <code>x</code>.</p>
<p>This information reduction helps to get a clear overview.</p>
<p>It writes reports to the <code>reportDir</code>:</p>
<ul>
<li><code>errors.txt</code>: validation errors</li>
<li><code>elements.txt</code>: element/attribute inventory.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L963-L1298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkTask(self):
    &#34;&#34;&#34;Implementation of the &#34;check&#34; task.

    It validates the TEI, but only if a schema file has been passed explicitly
    when constructing the `TEI()` object.

    Then it makes an inventory of all elements and attributes in the TEI files.

    If tags are used in multiple namespaces, it will be reported.

    !!! caution &#34;Conflation of namespaces&#34;
        The TEI to TF conversion does constructs node types and attributes
        without taking namespaces into account.
        However, the parsing process is namespace aware.

    The inventory lists all elements and attributes, and many attribute values.
    But is represents any digit with `n`, and some attributes that contain
    ids or keywords, are reduced to the value `x`.

    This information reduction helps to get a clear overview.

    It writes reports to the `reportDir`:

    *   `errors.txt`: validation errors
    *   `elements.txt`: element/attribute inventory.
    &#34;&#34;&#34;
    if not self.good:
        return

    sourceDir = self.sourceDir
    reportDir = self.reportDir
    docsDir = self.docsDir
    sectionModel = self.sectionModel

    console(f&#34;TEI to TF checking: {ux(sourceDir)} =&gt; {ux(reportDir)}&#34;)

    kindLabels = dict(
        format=&#34;Formatting Attributes&#34;,
        keyword=&#34;Keyword Attributes&#34;,
        rest=&#34;Remaining Attributes and Elements&#34;,
    )
    getStore = lambda: collections.defaultdict(  # noqa: E731
        lambda: collections.defaultdict(collections.Counter)
    )
    analysis = {x: getStore() for x in kindLabels}
    errors = []
    tagByNs = collections.defaultdict(collections.Counter)

    parser = self.getParser()
    validator = self.getValidator()
    self.getElementInfo()
    elementDefs = self.elementDefs

    initTree(reportDir)
    initTree(docsDir)

    def analyse(root, analysis):
        FORMAT_ATTS = set(
            &#34;&#34;&#34;
            dim
            level
            place
            rend
        &#34;&#34;&#34;.strip().split()
        )

        KEYWORD_ATTS = set(
            &#34;&#34;&#34;
            facs
            form
            function
            lang
            reason
            type
            unit
            who
        &#34;&#34;&#34;.strip().split()
        )

        TRIM_ATTS = set(
            &#34;&#34;&#34;
            id
            key
            target
            value
        &#34;&#34;&#34;.strip().split()
        )

        NUM_RE = re.compile(r&#34;&#34;&#34;[0-9]&#34;&#34;&#34;, re.S)

        def nodeInfo(node):
            qName = etree.QName(node.tag)
            tag = qName.localname
            ns = qName.namespace
            atts = node.attrib

            tagByNs[tag][ns] += 1

            if len(atts) == 0:
                kind = &#34;rest&#34;
                analysis[kind][tag][&#34;&#34;][&#34;&#34;] += 1
            else:
                for (kOrig, v) in atts.items():
                    k = etree.QName(kOrig).localname
                    kind = (
                        &#34;format&#34;
                        if k in FORMAT_ATTS
                        else &#34;keyword&#34;
                        if k in KEYWORD_ATTS
                        else &#34;rest&#34;
                    )
                    dest = analysis[kind]

                    if kind == &#34;rest&#34;:
                        vTrim = &#34;X&#34; if k in TRIM_ATTS else NUM_RE.sub(&#34;N&#34;, v)
                        dest[tag][k][vTrim] += 1
                    else:
                        words = v.strip().split()
                        for w in words:
                            dest[tag][k][w.strip()] += 1

            for child in node.iterchildren(tag=etree.Element):
                nodeInfo(child)

        nodeInfo(root)

    def writeErrors():
        errorFile = f&#34;{reportDir}/errors.txt&#34;

        nErrors = 0

        with open(errorFile, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
            for (xmlFile, lines) in errors:
                fh.write(f&#34;{xmlFile}\n&#34;)
                for line in lines:
                    fh.write(line)
                    nErrors += 1
                fh.write(&#34;\n&#34;)

        console(
            f&#34;{nErrors} error(s) in {len(errors)} file(s) written to {errorFile}&#34;
        )

    def writeNamespaces():
        errorFile = f&#34;{reportDir}/namespaces.txt&#34;

        nErrors = 0

        nTags = len(tagByNs)

        with open(errorFile, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
            for (tag, nsInfo) in sorted(
                tagByNs.items(), key=lambda x: (-len(x[1]), x[0])
            ):
                label = &#34;OK&#34;
                nNs = len(nsInfo)
                if nNs &gt; 1:
                    nErrors += 1
                    label = &#34;XX&#34;

                for (ns, amount) in sorted(
                    nsInfo.items(), key=lambda x: (-x[1], x[0])
                ):
                    fh.write(
                        f&#34;{label} {nNs:&gt;2} namespace for &#34;
                        f&#34;{tag:&lt;16} : {amount:&gt;5}x {ns}\n&#34;
                    )

        console(
            f&#34;{nTags} tags of which {nErrors} with multiple namespaces &#34;
            f&#34;written to {errorFile}&#34;
        )

    def writeReport():
        reportFile = f&#34;{reportDir}/elements.txt&#34;
        with open(reportFile, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
            fh.write(
                &#34;Inventory of tags and attributes in the source XML file(s).\n&#34;
                &#34;Contains the following sections:\n&#34;
            )
            for label in kindLabels.values():
                fh.write(f&#34;\t{label}\n&#34;)
            fh.write(&#34;\n\n&#34;)

            infoLines = 0

            def writeAttInfo(tag, att, attInfo):
                nonlocal infoLines
                nl = &#34;&#34; if tag == &#34;&#34; else &#34;\n&#34;
                tagRep = &#34;&#34; if tag == &#34;&#34; else f&#34;&lt;{tag}&gt;&#34;
                attRep = &#34;&#34; if att == &#34;&#34; else f&#34;{att}=&#34;
                atts = sorted(attInfo.items())
                (val, amount) = atts[0]
                if tag:
                    (typ, mixed) = elementDefs[tag]
                    extraInfo = f&#34;{&#39;mixed&#39; if mixed else &#39;pure &#39;}: &#34;
                else:
                    extraInfo = &#34;&#34;
                fh.write(
                    f&#34;{nl}\t{extraInfo}{tagRep:&lt;18} &#34;
                    f&#34;{attRep:&lt;18} {amount:&gt;5}x {val}\n&#34;
                )
                infoLines += 1
                for (val, amount) in atts[1:]:
                    fh.write(
                        f&#34;&#34;&#34;\t{&#39;&#39;:&lt;7}{&#39;&#39;:&lt;18} {&#39;&#34;&#39;:&lt;18} {amount:&gt;5}x {val}\n&#34;&#34;&#34;
                    )
                    infoLines += 1

            def writeTagInfo(tag, tagInfo):
                nonlocal infoLines
                tags = sorted(tagInfo.items())
                (att, attInfo) = tags[0]
                writeAttInfo(tag, att, attInfo)
                infoLines += 1
                for (att, attInfo) in tags[1:]:
                    writeAttInfo(&#34;&#34;, att, attInfo)

            for (kind, label) in kindLabels.items():
                fh.write(f&#34;\n{label}\n&#34;)
                for (tag, tagInfo) in sorted(analysis[kind].items()):
                    writeTagInfo(tag, tagInfo)

        console(f&#34;{infoLines} info line(s) written to {reportFile}&#34;)

    def writeDoc():
        teiUrl = &#34;https://tei-c.org/release/doc/tei-p5-doc/en/html&#34;
        elUrlPrefix = f&#34;{teiUrl}/ref-&#34;
        attUrlPrefix = f&#34;{teiUrl}/REF-ATTS.html#&#34;
        docFile = f&#34;{docsDir}/elements.md&#34;
        with open(docFile, &#34;w&#34;, encoding=&#34;utf8&#34;) as fh:
            fh.write(
                dedent(
                    &#34;&#34;&#34;
                    # Element and attribute inventory

                    Table of contents

                    &#34;&#34;&#34;
                )
            )
            for label in kindLabels.values():
                labelAnchor = label.replace(&#34; &#34;, &#34;-&#34;)
                fh.write(f&#34;*\t[{label}](#{labelAnchor})\n&#34;)

            fh.write(&#34;\n&#34;)

            tableHeader = dedent(
                &#34;&#34;&#34;
                element | attribute | value | amount
                --- | --- | --- | ---
                &#34;&#34;&#34;
            )

            def writeAttInfo(tag, att, attInfo):
                tagRep = &#34; &#34; if tag == &#34;&#34; else f&#34;[{tag}]({elUrlPrefix}{tag}.html)&#34;
                attRep = &#34; &#34; if att == &#34;&#34; else f&#34;[{att}]({attUrlPrefix}{att})&#34;
                atts = sorted(attInfo.items())
                (val, amount) = atts[0]
                valRep = f&#34;`{val}`&#34; if val else &#34;&#34;
                fh.write(f&#34;{tagRep} | {attRep} | {valRep} | {amount}\n&#34;)
                for (val, amount) in atts[1:]:
                    valRep = f&#34;`{val}`&#34; if val else &#34;&#34;
                    fh.write(f&#34;&#34;&#34;\u00a0| | {valRep} | {amount}\n&#34;&#34;&#34;)

            def writeTagInfo(tag, tagInfo):
                tags = sorted(tagInfo.items())
                (att, attInfo) = tags[0]
                writeAttInfo(tag, att, attInfo)
                for (att, attInfo) in tags[1:]:
                    writeAttInfo(&#34;&#34;, att, attInfo)

            for (kind, label) in kindLabels.items():
                fh.write(f&#34;## {label}\n{tableHeader}&#34;)
                for (tag, tagInfo) in sorted(analysis[kind].items()):
                    writeTagInfo(tag, tagInfo)
                fh.write(&#34;\n&#34;)

    def filterError(msg):
        return msg == (
            &#34;Element &#39;graphic&#39;, attribute &#39;url&#39;: [facet &#39;pattern&#39;] &#34;
            &#34;The value &#39;&#39; is not accepted by the pattern &#39;\\S+&#39;.&#34;
        )

    NS_RE = re.compile(r&#34;&#34;&#34;\{[^}]+}&#34;&#34;&#34;)

    def doXMLFile(xmlPath):
        tree = etree.parse(xmlPath, parser)
        if validator is not None and not validator.validate(tree):
            theseErrors = []
            for entry in validator.error_log:
                msg = entry.message
                msg = NS_RE.sub(&#34;&#34;, msg)
                if filterError(msg):
                    continue
                # domain = entry.domain_name
                # typ = entry.type_name
                level = entry.level_name
                line = entry.line
                col = entry.column
                address = f&#34;{line}:{col}&#34;
                theseErrors.append(f&#34;{address:&lt;6} {level:} {msg}\n&#34;)
            if len(theseErrors):
                console(&#34;ERROR\n&#34;)
                errors.append((xmlFile, theseErrors))
            return

        root = tree.getroot()
        analyse(root, analysis)

    if sectionModel == &#34;I&#34;:
        i = 0
        for (xmlFolder, xmlFiles) in self.getXML():
            console(f&#34;Start folder {xmlFolder}:&#34;)
            for xmlFile in xmlFiles:
                i += 1
                console(f&#34;\r{i:&gt;4} {xmlFile:&lt;50}&#34;, newline=False)
                xmlPath = f&#34;{sourceDir}/{xmlFolder}/{xmlFile}&#34;
                doXMLFile(xmlPath)
            console(&#34;&#34;)
            console(f&#34;End   folder {xmlFolder}&#34;)

    elif sectionModel == &#34;II&#34;:
        xmlFile = self.getXML()
        if xmlFile is None:
            console(&#34;No XML files found!&#34;)
            return False

        xmlPath = f&#34;{sourceDir}/{xmlFile}&#34;
        doXMLFile(xmlPath)

    console(&#34;&#34;)
    writeReport()
    writeDoc()
    writeErrors()
    writeNamespaces()</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.convertTask"><code class="name flex">
<span>def <span class="ident">convertTask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of the "convert" task.</p>
<p>It sets up the <code><a title="tf.convert.walker" href="walker.html">tf.convert.walker</a></code> machinery and runs it.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether the conversion was successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L2206-L2292" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def convertTask(self):
    &#34;&#34;&#34;Implementation of the &#34;convert&#34; task.

    It sets up the `tf.convert.walker` machinery and runs it.

    Returns
    -------
    boolean
        Whether the conversion was successful.
    &#34;&#34;&#34;
    if not self.good:
        return

    wordAsSlot = self.wordAsSlot
    sectionModel = self.sectionModel
    tfPath = self.tfPath
    sourceDir = self.sourceDir
    chunkSection = self.chunkSection
    levelNames = self.levelNames

    console(f&#34;TEI to TF converting: {ux(sourceDir)} =&gt; {ux(tfPath)}&#34;)

    slotType = WORD if wordAsSlot else CHAR

    sectionFeatures = &#34;,&#34;.join(levelNames)
    sectionTypes = &#34;,&#34;.join(levelNames)

    textFeatures = &#34;{str}{after}&#34; if wordAsSlot else &#34;{ch}&#34;
    otext = {
        &#34;fmt:text-orig-full&#34;: textFeatures,
        &#34;sectionFeatures&#34;: sectionFeatures,
        &#34;sectionTypes&#34;: sectionTypes,
        &#34;levelConstraints&#34;: &#34;note &lt; chunk, p&#34;,
    }
    intFeatures = {&#34;empty&#34;, chunkSection}
    featureMeta = dict(
        str=dict(description=&#34;the text of a word&#34;),
        after=dict(description=&#34;the text after a word till the next word&#34;),
        empty=dict(
            description=&#34;whether a slot has been inserted in an empty element&#34;
        ),
        is_meta=dict(
            description=&#34;whether a slot or word is in the teiHeader element&#34;
        ),
        is_note=dict(description=&#34;whether a slot or word is in the note element&#34;),
    )
    featureMeta[chunkSection] = dict(
        description=f&#34;number of a {chunkSection} within a document&#34;
    )

    if not wordAsSlot:
        featureMeta[&#34;ch&#34;] = dict(description=&#34;the unicode character of a slot&#34;)
    if sectionModel == &#34;II&#34;:
        chapterSection = self.chapterSection
        featureMeta[chapterSection] = dict(description=f&#34;name of {chapterSection}&#34;)
    else:
        folderSection = self.folderSection
        fileSection = self.fileSection
        featureMeta[folderSection] = dict(
            description=f&#34;name of source {folderSection}&#34;
        )
        featureMeta[fileSection] = dict(description=f&#34;name of source {fileSection}&#34;)

    self.intFeatures = intFeatures
    self.featureMeta = featureMeta

    schema = self.schema
    tfVersion = self.tfVersion
    generic = self.generic
    generic[&#34;sourceFormat&#34;] = &#34;TEI&#34;
    generic[&#34;version&#34;] = tfVersion
    if schema:
        generic[&#34;schema&#34;] = schema

    initTree(tfPath, fresh=True, gentle=True)

    cv = self.getConverter()

    self.good = cv.walk(
        self.getDirector(),
        slotType,
        otext=otext,
        generic=generic,
        intFeatures=intFeatures,
        featureMeta=featureMeta,
        generateTf=True,
    )</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.getConverter"><code class="name flex">
<span>def <span class="ident">getConverter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a converter.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>The <code><a title="tf.convert.walker.CV" href="walker.html#tf.convert.walker.CV">CV</a></code> converter object, initialized.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L1302-L1313" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getConverter(self):
    &#34;&#34;&#34;Initializes a converter.

    Returns
    -------
    object
        The `tf.convert.walker.CV` converter object, initialized.
    &#34;&#34;&#34;
    tfPath = self.tfPath

    TF = Fabric(locations=tfPath)
    return CV(TF)</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.getDirector"><code class="name flex">
<span>def <span class="ident">getDirector</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Factory for the director function.</p>
<p>The <code><a title="tf.convert.walker" href="walker.html">tf.convert.walker</a></code> relies on a corpus dependent <code>director</code> function
that walks through the source data and spits out actions that
produces the TF dataset.</p>
<p>The director function that walks through the TEI input must be conditioned
by the properties defined in the TEI schema and the customised schema, if any,
that describes the source.</p>
<p>Also some special additions need to be programmed, such as an extra section
level, word boundaries, etc.</p>
<p>We collect all needed data, store it, and define a local director function
that has access to this data.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>function</code></dt>
<dd>The local director function that has been constructed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L1317-L2204" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getDirector(self):
    &#34;&#34;&#34;Factory for the director function.

    The `tf.convert.walker` relies on a corpus dependent `director` function
    that walks through the source data and spits out actions that
    produces the TF dataset.

    The director function that walks through the TEI input must be conditioned
    by the properties defined in the TEI schema and the customised schema, if any,
    that describes the source.

    Also some special additions need to be programmed, such as an extra section
    level, word boundaries, etc.

    We collect all needed data, store it, and define a local director function
    that has access to this data.

    Returns
    -------
    function
        The local director function that has been constructed.
    &#34;&#34;&#34;
    TEI_HEADER = &#34;teiHeader&#34;

    TEXT_ANCESTOR = &#34;text&#34;
    TEXT_ANCESTORS = set(
        &#34;&#34;&#34;
        front
        body
        back
        group
        &#34;&#34;&#34;.strip().split()
    )
    CHUNK_PARENTS = TEXT_ANCESTORS | {TEI_HEADER}

    CHUNK_ELEMS = set(
        &#34;&#34;&#34;
        facsimile
        fsdDecl
        sourceDoc
        standOff
        &#34;&#34;&#34;.strip().split()
    )

    PASS_THROUGH = set(
        &#34;&#34;&#34;
        TEI
        &#34;&#34;&#34;.strip().split()
    )

    # CHECKING

    HY = &#34;\u2010&#34;  # hyphen

    IN_WORD_HYPHENS = {HY, &#34;-&#34;}

    ZWSP = &#34;\u200b&#34;  # zero-width space

    sourceDir = self.sourceDir
    wordAsSlot = self.wordAsSlot
    featureMeta = self.featureMeta
    intFeatures = self.intFeatures
    transform = self.transform
    chunkLevel = self.chunkLevel

    transformFunc = (
        (lambda x: x)
        if transform is None
        else (lambda x: BytesIO(transform(x).encode(&#34;utf-8&#34;)))
    )

    parser = self.getParser()
    self.getElementInfo()

    # WALKERS

    WHITE_TRIM_RE = re.compile(r&#34;\s+&#34;, re.S)
    NON_NAME_RE = re.compile(r&#34;[^a-zA-Z0-9_]+&#34;, re.S)

    NOTE_LIKE = set(
        &#34;&#34;&#34;
        note
        &#34;&#34;&#34;.strip().split()
    )
    EMPTY_ELEMENTS = set(
        &#34;&#34;&#34;
        addSpan
        alt
        anchor
        anyElement
        attRef
        binary
        caesura
        catRef
        cb
        citeData
        classRef
        conversion
        damageSpan
        dataFacet
        default
        delSpan
        elementRef
        empty
        equiv
        fsdLink
        gb
        handShift
        iff
        lacunaEnd
        lacunaStart
        lb
        link
        localProp
        macroRef
        milestone
        move
        numeric
        param
        path
        pause
        pb
        ptr
        redo
        refState
        specDesc
        specGrpRef
        symbol
        textNode
        then
        undo
        unicodeProp
        unihanProp
        variantEncoding
        when
        witEnd
        witStart
        &#34;&#34;&#34;.strip().split()
    )
    # N.B. We will alway generate newlines at the closing tags of
    # elements that occur in pure elements
    NEWLINE_ELEMENTS = set(
        &#34;&#34;&#34;
        ab
        cb
        l
        lb
        lg
        list
        p
        pb
        seg
        table
        u
        &#34;&#34;&#34;.strip().split()
    )

    def makeNameLike(x):
        return NON_NAME_RE.sub(&#34;_&#34;, x).strip(&#34;_&#34;)

    def walkNode(cv, cur, node):
        &#34;&#34;&#34;Internal function to deal with a single element.

        Will be called recursively.

        Parameters
        ----------
        cv: object
            The convertor object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        node: object
            An lxml element node.
        &#34;&#34;&#34;
        tag = etree.QName(node.tag).localname
        cur[NEST].append(tag)

        beforeChildren(cv, cur, node, tag)

        for child in node.iterchildren(tag=etree.Element):
            walkNode(cv, cur, child)

        afterChildren(cv, cur, node, tag)
        cur[NEST].pop()
        afterTag(cv, cur, node, tag)

    def isChapter(cur):
        &#34;&#34;&#34;Whether the current element counts as a chapter node.

        ## Model I

        Not relevant: there are no chapter nodes inside an XML file.

        ## Model II

        Chapters are the highest section level (the only lower level is chunks).

        Chapters come in two kinds:

        *   the TEI header;
        *   the immediate children of `&lt;text&gt;`
            except `&lt;front&gt;`, `&lt;body&gt;`, `&lt;back&gt;`, `&lt;group&gt;`;
        *   the immediate children of
            `&lt;front&gt;`, `&lt;body&gt;`, `&lt;back&gt;`, `&lt;group&gt;`.

        Parameters
        ----------
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        sectionModel = self.sectionModel

        if sectionModel == &#34;II&#34;:
            nest = cur[NEST]
            nNest = len(nest)

            if nNest &gt; 0 and nest[-1] in EMPTY_ELEMENTS:
                return False

            return nNest &gt; 0 and (
                nest[-1] == TEI_HEADER
                or (
                    nNest &gt; 1
                    and (
                        nest[-2] in TEXT_ANCESTORS
                        or nest[-2] == TEXT_ANCESTOR
                        and nest[-1] not in TEXT_ANCESTORS
                    )
                )
            )

        return False

    def isChunk(cur):
        &#34;&#34;&#34;Whether the current element counts as a chunk node.

        ## Model I

        Chunks are the lowest section level (the higher levels are folders
        and then files)

        Chunks are the immediate children of the `&lt;teiHeader&gt;` and the `&lt;body&gt;`
        elements, and a few other elements also count as chunks.

        ## Model II

        Chunks are the lowest section level (the only higher level is chapters).

        Chunks are the immediate children of the chapters, and they come in two
        kinds: the ones that are `&lt;p&gt;` elements, and the rest.

        Deviation from this rule:

        *   If a chapter is a mixed content node, then it is also a chunk.
            and its subelements are not chunks

        Parameters
        ----------
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        sectionModel = self.sectionModel

        nest = cur[NEST]
        nNest = len(nest)

        if sectionModel == &#34;II&#34;:
            meChptChnk = isChapter(cur) and cur[NEST][-1] not in cur[&#34;pureElems&#34;]
            return nNest &gt; 1 and (
                meChptChnk
                or (
                    nest[-2] == TEI_HEADER
                    or (
                        nNest &gt; 2
                        and (
                            nest[-3] in TEXT_ANCESTORS
                            and nest[-1] not in EMPTY_ELEMENTS
                            or nest[-3] == TEXT_ANCESTOR
                            and nest[-2] not in TEXT_ANCESTORS
                        )
                        and cur[NEST][-2] in cur[&#34;pureElems&#34;]
                    )
                )
            )

        return nNest &gt; 0 and (
            nest[-1] in CHUNK_ELEMS
            or (
                nNest &gt; 1
                and (
                    nest[-2] in CHUNK_PARENTS
                    and nest[-1] not in EMPTY_ELEMENTS
                    or nest[-2] == TEXT_ANCESTOR
                    and nest[-1] not in TEXT_ANCESTORS
                )
            )
        )

    def isPure(cur):
        &#34;&#34;&#34;Whether the current tag has pure content.

        Parameters
        ----------
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        nest = cur[NEST]
        return len(nest) == 0 or len(nest) &gt; 0 and nest[-1] in cur[&#34;pureElems&#34;]

    def isEndInPure(cur):
        &#34;&#34;&#34;Whether the current end tag occurs in an element with pure content.

        If that is the case, then it is very likely that the end tag also
        marks the end of the current word.

        And we should not strip spaces after it.

        Parameters
        ----------
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        nest = cur[NEST]
        return len(nest) &gt; 1 and nest[-2] in cur[&#34;pureElems&#34;]

    def startWord(cv, cur, ch):
        &#34;&#34;&#34;Start a word node if necessary.

        Whenever we encounter a character, we determine
        whether it starts or ends a word, and if it starts
        one, this function takes care of the necessary actions.

        Parameters
        ----------
        cv: object
            The convertor object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        ch: string
            A single character, the next slot in the result data.
        &#34;&#34;&#34;
        curWord = cur[WORD]
        if not curWord:
            prevWord = cur[&#34;prevWord&#34;]
            if prevWord is not None:
                cv.feature(prevWord, after=cur[&#34;afterStr&#34;])
            if ch is not None:
                if wordAsSlot:
                    curWord = cv.slot()
                else:
                    curWord = cv.node(WORD)
                cur[WORD] = curWord
                addSlotFeatures(cv, cur, curWord)

        if ch is not None:
            cur[&#34;wordStr&#34;] += ch

    def finishWord(cv, cur, ch, withNewline):
        &#34;&#34;&#34;Terminate a word node if necessary.

        Whenever we encounter a character, we determine
        whether it starts or ends a word, and if it ends
        one, this function takes care of the necessary actions.

        Parameters
        ----------
        cv: object
            The convertor object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        ch: string
            A single character, the next slot in the result data.
        withNewline:
            Whether to add a newline after the word.
        &#34;&#34;&#34;
        curWord = cur[WORD]
        if curWord:
            cv.feature(curWord, str=cur[&#34;wordStr&#34;])
            if not wordAsSlot:
                cv.terminate(curWord)
            cur[WORD] = None
            cur[&#34;wordStr&#34;] = &#34;&#34;
            cur[&#34;prevWord&#34;] = curWord
            cur[&#34;afterStr&#34;] = &#34;&#34;

        if ch is not None:
            cur[&#34;afterStr&#34;] += ch
        if withNewline:
            cur[&#34;afterStr&#34;] = cur[&#34;afterStr&#34;].rstrip() + &#34;\n&#34;
            if not wordAsSlot:
                addNewline(cv, cur)

    def addEmpty(cv, cur):
        &#34;&#34;&#34;Add an empty slot.

        We also terminate the current word.
        If words are slots, the empty slot is a word on its own.

        Returns
        -------
        node
            The empty slot
        &#34;&#34;&#34;
        finishWord(cv, cur, None, False)
        startWord(cv, cur, ZWSP)
        emptyNode = cur[WORD]
        cv.feature(emptyNode, empty=1)

        if not wordAsSlot:
            emptyNode = cv.slot()
            cv.feature(emptyNode, ch=ZWSP, empty=1)

        finishWord(cv, cur, None, False)

        return emptyNode

    def addSlotFeatures(cv, cur, s):
        &#34;&#34;&#34;Add generic features to a slot.

        Whenever we encounter a character, we add it as a new slot, unless
        `wordAsSlot` is in force. In that case we suppress the triggering of a
        slot node.
        If needed, we start/terminate word nodes as well.

        Parameters
        ----------
        cv: object
            The convertor object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        s: slot
            A previously added (slot) node
        &#34;&#34;&#34;
        if cur[&#34;inHeader&#34;]:
            cv.feature(s, is_meta=1)
        if cur[&#34;inNote&#34;]:
            cv.feature(s, is_note=1)
        for (r, stack) in cur.get(&#34;rend&#34;, {}).items():
            if len(stack) &gt; 0:
                cv.feature(s, **{f&#34;rend_{r}&#34;: 1})

    def addSlot(cv, cur, ch):
        &#34;&#34;&#34;Add a slot.

        Whenever we encounter a character, we add it as a new slot, unless
        `wordAsSlot` is in force. In that case we suppress the triggering of a
        slot node.
        If needed, we start/terminate word nodes as well.

        Parameters
        ----------
        cv: object
            The convertor object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        ch: string
            A single character, the next slot in the result data.
        &#34;&#34;&#34;
        if ch is None or ch.isalnum() or ch in IN_WORD_HYPHENS:
            startWord(cv, cur, ch)
        else:
            finishWord(cv, cur, ch, False)

        if wordAsSlot:
            s = cur[WORD]
        elif ch is None:
            s = None
        else:
            s = cv.slot()
            cv.feature(s, ch=ch)
        if s is not None:
            addSlotFeatures(cv, cur, s)

    def addNewline(cv, cur):
        &#34;&#34;&#34;Adds a new line.

        Parameters
        ----------
        cv: object
            The convertor object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.

        Only meant for the case where slots are characters.

        Suppressed when not in a lowest-level section.
        &#34;&#34;&#34;
        if chunkLevel in cv.activeTypes():
            s = cv.slot()
            cv.feature(s, ch=&#34;\n&#34;)
            addSlotFeatures(cv, cur, s)

    def beforeChildren(cv, cur, node, tag):
        &#34;&#34;&#34;Actions before dealing with the element&#39;s children.

        Parameters
        ----------
        cv: object
            The convertor object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        node: object
            An lxml element node.
        tag: string
            The tag of the lxml node.
        &#34;&#34;&#34;
        sectionModel = self.sectionModel
        sectionProperties = self.sectionProperties

        atts = {etree.QName(k).localname: v for (k, v) in node.attrib.items()}

        if sectionModel == &#34;II&#34;:
            chapterSection = self.chapterSection
            chunkSection = self.chunkSection

            if isChapter(cur):
                cur[&#34;chapterNum&#34;] += 1
                cur[&#34;prevChapter&#34;] = cur.get(CHAPTER, None)
                cur[CHAPTER] = cv.node(chapterSection)
                for danglingSlot in cur[&#34;danglingSlots&#34;]:
                    cv.link(cur[CHAPTER], danglingSlot)

                value = {chapterSection: f&#34;{cur[&#39;chapterNum&#39;]} {tag}&#34;}
                cv.feature(cur[CHAPTER], **value)
                cur[&#34;chunkPNum&#34;] = 0
                cur[&#34;chunkONum&#34;] = 0
                cur[&#34;prevChunk&#34;] = cur.get(CHUNK, None)
                cur[CHUNK] = cv.node(chunkSection)
                for danglingSlot in cur[&#34;danglingSlots&#34;]:
                    cv.link(cur[CHUNK], danglingSlot)
                cur[&#34;danglingSlots&#34;] = set()
                cur[&#34;infirstChunk&#34;] = True

            # N.B. A node can count both as chapter and as chunk,
            # e.g. a &lt;trailer&gt; sibling of the chapter &lt;div&gt;s
            # A trailer has mixed content, so its subelements aren&#39;t typical chunks.
            if isChunk(cur):
                if cur[&#34;infirstChunk&#34;]:
                    cur[&#34;infirstChunk&#34;] = False
                else:
                    cur[CHUNK] = cv.node(chunkSection)
                    for danglingSlot in cur[&#34;danglingSlots&#34;]:
                        cv.link(cur[CHUNK], danglingSlot)
                    cur[&#34;danglingSlots&#34;] = set()
                if tag == &#34;p&#34;:
                    cur[&#34;chunkPNum&#34;] += 1
                    cn = cur[&#34;chunkPNum&#34;]
                else:
                    cur[&#34;chunkONum&#34;] -= 1
                    cn = cur[&#34;chunkONum&#34;]
                value = {chunkSection: cn}
                cv.feature(cur[CHUNK], **value)

            if tag == sectionProperties[&#34;element&#34;]:
                criticalAtts = sectionProperties[&#34;attributes&#34;]
                match = True
                for (k, v) in criticalAtts.items():
                    if atts.get(k, None) != v:
                        match = False
                        break
                if match:
                    heading = etree.tostring(
                        node, encoding=&#34;unicode&#34;, method=&#34;text&#34;, with_tail=False
                    ).replace(&#34;\n&#34;, &#34; &#34;)
                    value = {chapterSection: heading}
                    cv.feature(cur[CHAPTER], **value)
                    chapterNum = cur[&#34;chapterNum&#34;]
                    console(
                        f&#34;\rchapter {chapterNum:&gt;4} {heading:&lt;50}&#34;, newline=False
                    )
        else:
            chunkSection = self.chunkSection

            if isChunk(cur):
                cur[&#34;chunkNum&#34;] += 1
                cur[&#34;prevChunk&#34;] = cur.get(CHUNK, None)
                cur[CHUNK] = cv.node(chunkSection)
                for danglingSlot in cur[&#34;danglingSlots&#34;]:
                    cv.link(cur[CHUNK], danglingSlot)
                cur[&#34;danglingSlots&#34;] = set()
                value = {chunkSection: cur[&#34;chunkNum&#34;]}
                cv.feature(cur[CHUNK], **value)

        if tag == TEI_HEADER:
            cur[&#34;inHeader&#34;] = True
            if sectionModel == &#34;II&#34;:
                value = {chapterSection: &#34;TEI header&#34;}
                cv.feature(cur[CHAPTER], **value)
        if tag in NOTE_LIKE:
            cur[&#34;inNote&#34;] = True
            finishWord(cv, cur, None, False)

        if tag not in PASS_THROUGH:
            curNode = cv.node(tag)
            if wordAsSlot:
                if cur[WORD]:
                    cv.link(curNode, [cur[WORD][1]])
            cur[&#34;elems&#34;].append(curNode)
            if len(atts):
                cv.feature(curNode, **atts)
                if &#34;rend&#34; in atts:
                    rValue = atts[&#34;rend&#34;]
                    r = makeNameLike(rValue)
                    if r:
                        cur.setdefault(&#34;rend&#34;, {}).setdefault(r, []).append(True)
        if node.text:
            textMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, node.text)
            if isPure(cur):
                if textMaterial and textMaterial != &#34; &#34;:
                    console(
                        &#34;WARNING: Text material at the start of &#34;
                        f&#34;pure-content element &lt;{tag}&gt;&#34;
                    )
                    stack = &#34;-&#34;.join(cur[NEST])
                    console(f&#34;\tElement stack: {stack}&#34;)
                    console(f&#34;\tMaterial: `{textMaterial}`&#34;)
            else:
                for ch in textMaterial:
                    addSlot(cv, cur, ch)

    def afterChildren(cv, cur, node, tag):
        &#34;&#34;&#34;Node actions after dealing with the children, but before the end tag.

        Here we make sure that the newline elements will get their last slot
        having a newline at the end of their `after` feature.

        Parameters
        ----------
        cv: object
            The convertor object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        node: object
            An lxml element node.
        tag: string
            The tag of the lxml node.
        &#34;&#34;&#34;
        sectionModel = self.sectionModel
        isChap = isChapter(cur)
        isChnk = isChunk(cur)

        hasFinishedWord = False

        if tag not in PASS_THROUGH:
            if isEndInPure(cur) or tag in NEWLINE_ELEMENTS:
                finishWord(cv, cur, None, True)
                hasFinishedWord = True

            curNode = cur[&#34;elems&#34;].pop()

            slots = cv.linked(curNode)

            if not len(slots):
                lastSlot = addEmpty(cv, cur)
                if cur[&#34;inHeader&#34;]:
                    cv.feature(lastSlot, is_meta=1)
                if cur[&#34;inNote&#34;]:
                    cv.feature(lastSlot, is_note=1)
                # take care that this empty slot falls under all sections
                # for folders and files this is already guaranteed
                # We need only to watch out for chapters and chunks
                if cur.get(CHUNK, None) is None:
                    prevChunk = cur.get(&#34;prevChunk&#34;, None)
                    if prevChunk is None:
                        cur[&#34;danglingSlots&#34;].add(lastSlot)
                    else:
                        cv.link(prevChunk, lastSlot)
                if sectionModel == &#34;II&#34;:
                    if cur.get(CHAPTER, None) is None:
                        prevChapter = cur.get(&#34;prevChapter&#34;, None)
                        if prevChapter is None:
                            cur[&#34;danglingSlots&#34;].add(lastSlot)
                        else:
                            cv.link(prevChapter, lastSlot)

            cv.terminate(curNode)

        if isChnk:
            if not hasFinishedWord:
                finishWord(cv, cur, None, True)
            cv.terminate(cur[CHUNK])
        if sectionModel == &#34;II&#34;:
            if isChap:
                if not hasFinishedWord:
                    finishWord(cv, cur, None, True)
                cv.terminate(cur[CHAPTER])

    def afterTag(cv, cur, node, tag):
        &#34;&#34;&#34;Node actions after dealing with the children and after the end tag.

        This is the place where we proces the `tail` of an lxml node: the
        text material after the element and before the next open/close
        tag of any element.

        Parameters
        ----------
        cv: object
            The convertor object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        node: object
            An lxml element node.
        tag: string
            The tag of the lxml node.
        &#34;&#34;&#34;
        if tag == TEI_HEADER:
            cur[&#34;inHeader&#34;] = False
        elif tag in NOTE_LIKE:
            cur[&#34;inNote&#34;] = False

        if tag not in PASS_THROUGH:
            atts = {etree.QName(k).localname: v for (k, v) in node.attrib.items()}
            if &#34;rend&#34; in atts:
                rValue = atts[&#34;rend&#34;]
                r = makeNameLike(rValue)
                if r:
                    cur[&#34;rend&#34;][r].pop()

        if node.tail:
            tailMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, node.tail)
            if isPure(cur):
                if tailMaterial and tailMaterial != &#34; &#34;:
                    elem = cur[NEST][-1]
                    console(
                        &#34;WARNING: Text material after &#34;
                        f&#34;&lt;{tag}&gt; in pure-content element &lt;{elem}&gt;&#34;
                    )
                    stack = &#34;-&#34;.join(cur[NEST])
                    console(f&#34;\tElement stack: {stack}-{tag}&#34;)
                    console(f&#34;\tMaterial: `{tailMaterial}`&#34;)
            else:
                for ch in tailMaterial:
                    addSlot(cv, cur, ch)

    def director(cv):
        &#34;&#34;&#34;Director function.

        Here we program a walk through the TEI sources.
        At every step of the walk we fire some actions that build TF nodes
        and assign features for them.

        Because everything is rather dynamic, we generate fairly standard
        metadata for the features, namely a link to the tei website.

        Parameters
        ----------
        cv: object
            The convertor object, needed to issue actions.
        &#34;&#34;&#34;
        sectionModel = self.sectionModel
        elementDefs = self.elementDefs

        cur = {}
        cur[&#34;pureElems&#34;] = {
            x for (x, (typ, mixed)) in elementDefs.items() if not mixed
        }

        if sectionModel == &#34;I&#34;:
            folderSection = self.folderSection
            fileSection = self.fileSection

            i = 0
            for (xmlFolder, xmlFiles) in self.getXML():
                console(f&#34;Start folder {xmlFolder}:&#34;)

                cur[FOLDER] = cv.node(folderSection)
                value = {folderSection: xmlFolder}
                cv.feature(cur[FOLDER], **value)

                for xmlFile in xmlFiles:
                    i += 1
                    console(f&#34;\r{i:&gt;4} {xmlFile:&lt;50}&#34;, newline=False)

                    cur[FILE] = cv.node(fileSection)
                    value = {fileSection: xmlFile.removesuffix(&#34;.xml&#34;)}
                    cv.feature(cur[FILE], **value)

                    with open(
                        f&#34;{sourceDir}/{xmlFolder}/{xmlFile}&#34;, encoding=&#34;utf8&#34;
                    ) as fh:
                        text = fh.read()
                        text = transformFunc(text)
                        tree = etree.parse(text, parser)
                        root = tree.getroot()
                        cur[&#34;inHeader&#34;] = False
                        cur[&#34;inNote&#34;] = False
                        cur[NEST] = []
                        cur[&#34;elems&#34;] = []
                        cur[&#34;chunkNum&#34;] = 0
                        cur[&#34;prevChunk&#34;] = None
                        cur[&#34;danglingSlots&#34;] = set()
                        cur[WORD] = None
                        cur[&#34;prevWord&#34;] = None
                        cur[&#34;wordStr&#34;] = &#34;&#34;
                        cur[&#34;afterStr&#34;] = &#34;&#34;
                        walkNode(cv, cur, root)

                    addSlot(cv, cur, None)
                    cv.terminate(cur[FILE])

                console(&#34;&#34;)
                console(f&#34;End   folder {xmlFolder}&#34;)
                cv.terminate(cur[FOLDER])

        elif sectionModel == &#34;II&#34;:
            xmlFile = self.getXML()
            if xmlFile is None:
                console(&#34;No XML files found!&#34;)
                return False

            with open(f&#34;{sourceDir}/{xmlFile}&#34;, encoding=&#34;utf8&#34;) as fh:
                text = fh.read()
                text = transformFunc(text)
                tree = etree.parse(text, parser)
                root = tree.getroot()
                cur[&#34;inHeader&#34;] = False
                cur[&#34;inNote&#34;] = False
                cur[NEST] = []
                cur[&#34;elems&#34;] = []
                cur[&#34;chapterNum&#34;] = 0
                cur[&#34;chunkPNum&#34;] = 0
                cur[&#34;chunkONum&#34;] = 0
                cur[&#34;prevChunk&#34;] = None
                cur[&#34;prevChapter&#34;] = None
                cur[&#34;danglingSlots&#34;] = set()
                cur[WORD] = None
                cur[&#34;prevWord&#34;] = None
                cur[&#34;wordStr&#34;] = &#34;&#34;
                cur[&#34;afterStr&#34;] = &#34;&#34;
                for child in root.iterchildren(tag=etree.Element):
                    walkNode(cv, cur, child)

            addSlot(cv, cur, None)

        console(&#34;&#34;)

        for fName in featureMeta:
            if not cv.occurs(fName):
                cv.meta(fName)
        for fName in cv.features():
            if fName not in featureMeta:
                if fName.startswith(&#34;rend_&#34;):
                    r = fName[5:]
                    cv.meta(
                        fName,
                        description=f&#34;whether text is to be rendered as {r}&#34;,
                        valueType=&#34;int&#34;,
                    )
                    intFeatures.add(fName)
                else:
                    cv.meta(
                        fName,
                        description=f&#34;this is TEI attribute {fName}&#34;,
                        valueType=&#34;str&#34;,
                    )
        console(&#34;source reading done&#34;)
        return True

    return director</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.getElementInfo"><code class="name flex">
<span>def <span class="ident">getElementInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Analyse the schema.</p>
<p>The XML schema has useful information about the XML elements that
occur in the source. Here we extract that information and make it
fast-accessible.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Keyed by element name (without namespaces), where the value
for each name is a tuple of booleans: whether the element is simple
or complex; whether the element allows mixed content or only pure content.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L873-L897" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getElementInfo(self):
    &#34;&#34;&#34;Analyse the schema.

    The XML schema has useful information about the XML elements that
    occur in the source. Here we extract that information and make it
    fast-accessible.

    Returns
    -------
    dict
        Keyed by element name (without namespaces), where the value
        for each name is a tuple of booleans: whether the element is simple
        or complex; whether the element allows mixed content or only pure content.
    &#34;&#34;&#34;
    schemaFile = self.schemaFile

    self.elementDefs = {}

    A = Analysis()
    A.configure(override=schemaFile)
    A.interpret()
    if not A.good:
        quit()

    self.elementDefs = {name: (typ, mixed) for (name, typ, mixed) in A.getDefs()}</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.getValidator"><code class="name flex">
<span>def <span class="ident">getValidator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the schema.</p>
<p>A parsed schema can be used for XML-validation.
This will only happen during the <code>check</code> task.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>A configured lxml schema validator.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L854-L871" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getValidator(self):
    &#34;&#34;&#34;Parse the schema.

    A parsed schema can be used for XML-validation.
    This will only happen during the `check` task.

    Returns
    -------
    object
        A configured lxml schema validator.
    &#34;&#34;&#34;
    schemaFile = self.schemaFile

    if schemaFile is None:
        return None

    schemaDoc = etree.parse(schemaFile)
    return etree.XMLSchema(schemaDoc)</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.getXML"><code class="name flex">
<span>def <span class="ident">getXML</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Make an inventory of the TEI source files.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>tuple | string</code></dt>
<dd>
<p>If section model I is in force:</p>
<p>The outer tuple has sorted entries corresponding to folders under the
TEI input directory.
Each such entry consists of the folder name and an inner tuple
that contains the file names in that folder, sorted.</p>
<p>If section model II is in force:</p>
<p>It is the name of the single XML file.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L899-L961" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getXML(self):
    &#34;&#34;&#34;Make an inventory of the TEI source files.

    Returns
    -------
    tuple of tuple | string
        If section model I is in force:

        The outer tuple has sorted entries corresponding to folders under the
        TEI input directory.
        Each such entry consists of the folder name and an inner tuple
        that contains the file names in that folder, sorted.

        If section model II is in force:

        It is the name of the single XML file.
    &#34;&#34;&#34;
    sourceDir = self.sourceDir
    sectionModel = self.sectionModel
    console(f&#34;Section model {sectionModel}&#34;)

    if sectionModel == &#34;I&#34;:
        testMode = self.testMode
        testSet = self.testSet

        IGNORE = &#34;__ignore__&#34;

        xmlFilesRaw = collections.defaultdict(list)

        with scanDir(sourceDir) as dh:
            for folder in dh:
                folderName = folder.name
                if folderName == IGNORE:
                    continue
                if not folder.is_dir():
                    continue
                with scanDir(f&#34;{sourceDir}/{folderName}&#34;) as fh:
                    for file in fh:
                        fileName = file.name
                        if not (
                            fileName.lower().endswith(&#34;.xml&#34;) and file.is_file()
                        ):
                            continue
                        if testMode and fileName not in testSet:
                            continue
                        xmlFilesRaw[folderName].append(fileName)

        xmlFiles = tuple(
            (folderName, tuple(sorted(fileNames)))
            for (folderName, fileNames) in sorted(xmlFilesRaw.items())
        )
        return xmlFiles

    if sectionModel == &#34;II&#34;:
        xmlFile = None
        with scanDir(sourceDir) as fh:
            for file in fh:
                fileName = file.name
                if not (fileName.lower().endswith(&#34;.xml&#34;) and file.is_file()):
                    continue
                xmlFile = fileName
                break
        return xmlFile</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.loadTask"><code class="name flex">
<span>def <span class="ident">loadTask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of the "load" task.</p>
<p>It loads the tf data that resides in the directory where the "convert" task
deliver its results.</p>
<p>During loading there are additional checks. If they succeed, we have evidence
that we have a valid TF dataset.</p>
<p>Also, during the first load intensive precomputation of TF data takes place,
the results of which will be cached in the invisible <code>.<a title="tf" href="../index.html">tf</a></code> directory there.</p>
<p>That makes the TF data ready to be loaded fast, next time it is needed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether the loading was successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L2294-L2333" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loadTask(self):
    &#34;&#34;&#34;Implementation of the &#34;load&#34; task.

    It loads the tf data that resides in the directory where the &#34;convert&#34; task
    deliver its results.

    During loading there are additional checks. If they succeed, we have evidence
    that we have a valid TF dataset.

    Also, during the first load intensive precomputation of TF data takes place,
    the results of which will be cached in the invisible `.tf` directory there.

    That makes the TF data ready to be loaded fast, next time it is needed.

    Returns
    -------
    boolean
        Whether the loading was successful.
    &#34;&#34;&#34;
    if not self.good:
        return

    tfPath = self.tfPath

    if not dirExists(tfPath):
        console(f&#34;Directory {ux(tfPath)} does not exist.&#34;)
        console(&#34;No tf found, nothing to load&#34;)
        self.good = False
        return

    TF = Fabric(locations=[tfPath])
    allFeatures = TF.explore(silent=True, show=True)
    loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
    api = TF.load(loadableFeatures, silent=False)
    if api:
        console(f&#34;max node = {api.F.otype.maxNode}&#34;)
        self.good = True
        return

    self.good = False</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, program=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Carry out tasks specified by arguments on the command line.</p>
<p>The intended use of this module is that it is included by a conversion
script.
When that script is invoked, you can pass arguments to specify tasks
and flags.</p>
<p>This function inspects those arguments, and runs the specified tasks,
with the specified flags enabled.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>program</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the program that you want to display
in the help string, in case a help text must be displayed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>integer</code></dt>
<dd>In fact, this function will terminate the conversion program
an return a status code: 0 for succes, 1 for failure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L2683-L2733" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def run(self, program=None):
    &#34;&#34;&#34;Carry out tasks specified by arguments on the command line.

    The intended use of this module is that it is included by a conversion
    script.
    When that script is invoked, you can pass arguments to specify tasks
    and flags.

    This function inspects those arguments, and runs the specified tasks,
    with the specified flags enabled.

    Parameters
    ----------
    program: string
        The name of the program that you want to display
        in the help string, in case a help text must be displayed.

    Returns
    -------
    integer
        In fact, this function will terminate the conversion program
        an return a status code: 0 for succes, 1 for failure.
    &#34;&#34;&#34;
    programRep = &#34;TEI-converter&#34; if program is None else program
    possibleTasks = {&#34;check&#34;, &#34;convert&#34;, &#34;load&#34;, &#34;app&#34;, &#34;apptoken&#34;, &#34;browse&#34;}
    possibleFlags = {&#34;test&#34;, &#34;force&#34;}
    possibleArgs = possibleTasks | possibleFlags

    args = sys.argv[1:]

    if not len(args) or &#34;--help&#34; in args or &#34;-h&#34; in args:
        self.help(programRep)
        console(&#34;No task specified&#34;)
        sys.exit(-1)

    illegalArgs = {arg for arg in args if arg not in possibleArgs}

    if len(illegalArgs):
        self.help(programRep)
        for arg in illegalArgs:
            console(f&#34;Illegal argument `{arg}`&#34;)
        sys.exit(-1)

    tasks = {arg: True for arg in args if arg in possibleTasks}
    flags = {arg: True for arg in args if arg in possibleFlags}

    self.task(**tasks, **flags)
    if self.good:
        sys.exit(0)
    else:
        sys.exit(1)</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.task"><code class="name flex">
<span>def <span class="ident">task</span></span>(<span>self, check=False, convert=False, load=False, app=False, apptoken=False, browse=False, test=None, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Carry out any task, possibly modified by any flag.</p>
<p>This is a higher level function that can execute a selection of tasks.</p>
<p>The tasks will be executed in a fixed order: check, convert load.
But you can select which one(s) must be executed.</p>
<p>If multiple tasks must be executed and one fails, the subsequent tasks
will not be executed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>check</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to carry out the "check" task.</dd>
<dt><strong><code>convert</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to carry out the "convert" task.</dd>
<dt><strong><code>load</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to carry out the "load" task.</dd>
<dt><strong><code>app</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to carry out the "app" task.</dd>
<dt><strong><code>apptoken</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to carry out the "apptoken" task.</dd>
<dt><strong><code>browse</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to carry out the "browse" task"</dd>
<dt><strong><code>test</code></strong> :&ensp;<code>boolean</code>, optional <code>None</code></dt>
<dd>Whether to run in test mode.
In test mode only the files in the test set are converted.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>
<p>Whether the app task should overwrite previously generated files</p>
<p>If None, it will read its value from the attribute <code>testMode</code> of the
<code><a title="tf.convert.tei.TEI" href="#tf.convert.tei.TEI">TEI</a></code> object.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether all tasks have executed successfully.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/edb70b11b4cd1dbaa580a1d8a62302657f358c19/tf/convert/tei.py#L2615-L2681" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def task(
    self,
    check=False,
    convert=False,
    load=False,
    app=False,
    apptoken=False,
    browse=False,
    test=None,
    force=False,
):
    &#34;&#34;&#34;Carry out any task, possibly modified by any flag.

    This is a higher level function that can execute a selection of tasks.

    The tasks will be executed in a fixed order: check, convert load.
    But you can select which one(s) must be executed.

    If multiple tasks must be executed and one fails, the subsequent tasks
    will not be executed.

    Parameters
    ----------
    check: boolean, optional False
        Whether to carry out the &#34;check&#34; task.
    convert: boolean, optional False
        Whether to carry out the &#34;convert&#34; task.
    load: boolean, optional False
        Whether to carry out the &#34;load&#34; task.
    app: boolean, optional False
        Whether to carry out the &#34;app&#34; task.
    apptoken: boolean, optional False
        Whether to carry out the &#34;apptoken&#34; task.
    browse: boolean, optional False
        Whether to carry out the &#34;browse&#34; task&#34;
    test: boolean, optional None
        Whether to run in test mode.
        In test mode only the files in the test set are converted.
    force: boolean, optional False
        Whether the app task should overwrite previously generated files

        If None, it will read its value from the attribute `testMode` of the
        `TEI` object.

    Returns
    -------
    boolean
        Whether all tasks have executed successfully.
    &#34;&#34;&#34;
    if test is not None:
        self.testMode = test

    self.force = force

    if not self.good:
        return

    for (condition, method, kwargs) in (
        (check, self.checkTask, {}),
        (convert, self.convertTask, {}),
        (load, self.loadTask, {}),
        (app, self.appTask, {}),
        (apptoken, self.appTask, dict(tokenBased=True)),
        (browse, self.browseTask, {}),
    ):
        if condition:
            method(**kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#tei-import">TEI import</a><ul>
<li><a href="#tasks">Tasks</a></li>
<li><a href="#flags">Flags</a></li>
<li><a href="#usage">Usage</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.convert" href="index.html">tf.convert</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.convert.tei.checkSectionModel" href="#tf.convert.tei.checkSectionModel">checkSectionModel</a></code></li>
<li><code><a title="tf.convert.tei.makeCssInfo" href="#tf.convert.tei.makeCssInfo">makeCssInfo</a></code></li>
<li><code><a title="tf.convert.tei.tweakTrans" href="#tf.convert.tei.tweakTrans">tweakTrans</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.convert.tei.TEI" href="#tf.convert.tei.TEI">TEI</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.convert.tei.TEI.appTask" href="#tf.convert.tei.TEI.appTask">appTask</a></code></li>
<li><code><a title="tf.convert.tei.TEI.browseTask" href="#tf.convert.tei.TEI.browseTask">browseTask</a></code></li>
<li><code><a title="tf.convert.tei.TEI.checkTask" href="#tf.convert.tei.TEI.checkTask">checkTask</a></code></li>
<li><code><a title="tf.convert.tei.TEI.convertTask" href="#tf.convert.tei.TEI.convertTask">convertTask</a></code></li>
<li><code><a title="tf.convert.tei.TEI.getConverter" href="#tf.convert.tei.TEI.getConverter">getConverter</a></code></li>
<li><code><a title="tf.convert.tei.TEI.getDirector" href="#tf.convert.tei.TEI.getDirector">getDirector</a></code></li>
<li><code><a title="tf.convert.tei.TEI.getElementInfo" href="#tf.convert.tei.TEI.getElementInfo">getElementInfo</a></code></li>
<li><code><a title="tf.convert.tei.TEI.getParser" href="#tf.convert.tei.TEI.getParser">getParser</a></code></li>
<li><code><a title="tf.convert.tei.TEI.getValidator" href="#tf.convert.tei.TEI.getValidator">getValidator</a></code></li>
<li><code><a title="tf.convert.tei.TEI.getXML" href="#tf.convert.tei.TEI.getXML">getXML</a></code></li>
<li><code><a title="tf.convert.tei.TEI.help" href="#tf.convert.tei.TEI.help">help</a></code></li>
<li><code><a title="tf.convert.tei.TEI.loadTask" href="#tf.convert.tei.TEI.loadTask">loadTask</a></code></li>
<li><code><a title="tf.convert.tei.TEI.run" href="#tf.convert.tei.TEI.run">run</a></code></li>
<li><code><a title="tf.convert.tei.TEI.task" href="#tf.convert.tei.TEI.task">task</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>