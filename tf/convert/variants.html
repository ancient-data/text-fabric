<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.convert.variants API documentation</title>
<meta name="description" content="Variants â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.convert.variants</code></h1>
</header>
<section id="section-intro">
<h1 id="variants">Variants</h1>
<p>This module contains functions to help you constructing nodes
when you convert TEI material and encounter elements from
the
<a href="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/examples-lem.html#TC">Critical Apparatus Module</a>.</p>
<p>An extensive description of the problems and solutions is in
<code><a title="tf.about.variants" href="../about/variants.html">tf.about.variants</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L1-L348" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Variants

This module contains functions to help you constructing nodes
when you convert TEI material and encounter elements from
the
[Critical Apparatus Module](https://www.tei-c.org/release/doc/tei-p5-doc/en/html/examples-lem.html#TC).

An extensive description of the problems and solutions is in
`tf.about.variants`.
&#34;&#34;&#34;


APP = &#34;app&#34;
APPS = &#34;apps&#34;
APP_STACK = &#34;appstack&#34;
BASE = &#34;base&#34;
LEM = &#34;lem&#34;
N_APP = &#34;nApp&#34;
N_SENT = &#34;nSent&#34;
PARENT = &#34;parent&#34;
RDG = &#34;rdg&#34;
RDGS = &#34;rdgs&#34;
SLOTS = &#34;slots&#34;
TRANS_LAST = &#34;translast&#34;
TRANS_NEXT = &#34;transnext&#34;
VARIANTS = &#34;variants&#34;
WIT = &#34;wit&#34;
WITNESSES = &#34;witnesses&#34;
WITS = &#34;wits&#34;
X_WITS = &#34;xwits&#34;


class Variants:
    def __init__(self, cv, cur, sentType, addWarning, addError):
        self.cv = cv
        self.cur = cur
        self.sentType = sentType
        self.addWarning = addWarning
        self.addError = addError
        self.nSent = f&#34;n{sentType}&#34;
        self.stackSent = f&#34;stack{sentType}&#34;
        self.varSent = f&#34;variants{sentType}&#34;
        cur[WITNESSES] = set()

    def initApps(self):
        cur = self.cur

        cur[APPS] = dict()
        cur[APP_STACK] = []
        cur[TRANS_NEXT] = []
        cur[N_APP] = 0

    def collectWitnesses(self, node):
        &#34;&#34;&#34;Collect all witnesses.

        first collect witnesses from all rdg elements
        and store information for each lemma what witnesses occur in sibling rdgs
        we number the lem elements globally as we encounter them,
        and store info for that lem under that number,
        so that we can refer to that info when we encounter the lem during
        the second pass.

        The info per lem is
        - the set of all witnesses mentioned in the wit attribute of all its
          sibling rdgs
        The number of its parent lem or None if there is no parent lem

        We also check whether there are multiple direct rdg children of the same
        app that share witnesses (which would be strange: conflicting information)
        &#34;&#34;&#34;

        cur = self.cur
        addWarning = self.addWarning

        tag = node.tag.lower()
        atts = node.attrib

        appStack = cur[APP_STACK]
        apps = cur[APPS]

        if tag == APP:
            parentApp = appStack[-1] if len(appStack) else None
            nApp = cur[N_APP]
            cur[N_APP] = nApp + 1
            appStack.append(nApp + 1)
            apps[nApp + 1] = dict(parent=parentApp, xwits=set(), rdgs=[])

        elif tag == RDG:
            att = WIT

            if att in atts:
                ws = {w.strip(&#34;.&#34;).lower() for w in atts[att].split()}
                cur[WITNESSES] |= ws
                apps[appStack[-1]][X_WITS] |= ws
                rdgSeen = apps[appStack[-1]][RDGS]
                for rdg in rdgSeen:
                    if rdg &amp; ws:
                        addWarning(
                            &#34;witnesses of rdg not disjoint from sibling rdgs&#34;, cur
                        )
                apps[appStack[-1]][RDGS].append(ws)

        for child in node:
            self.collectWitnesses(child)

        if tag == APP:
            appStack.pop()

    def resetApps(self):
        cur = self.cur

        cur[N_APP] = 0
        cur[WITS] = []
        cur[X_WITS] = []

    def initSent(self):
        cur = self.cur
        nSent = self.nSent
        stackSent = self.stackSent
        varSent = self.varSent

        cur[TRANS_LAST] = None
        cur[nSent] = 0
        cur[stackSent] = []
        cur[varSent] = {BASE: None}

    def startApp(self, node):
        cv = self.cv
        cur = self.cur
        curVarSent = cur[self.varSent]
        curStackSent = cur[self.stackSent]

        tag = node.tag
        atts = node.attrib

        if tag == APP:
            nApp = cur[N_APP]
            cur[N_APP] = nApp + 1
            appInfo = cur[APPS][nApp + 1]
            parentApp = appInfo[PARENT]
            xwits = appInfo[X_WITS]

            curSent = curVarSent.get(BASE, None)
            cur[TRANS_NEXT].append(&#34;&#34;)

            if curSent is None:
                slots = None
            else:
                slots = cv.linked(curSent)
                cv.feature(curSent, wit=BASE)

            curStackSent.append(
                dict(
                    translast=cur[TRANS_LAST],
                    slots=slots,
                )
            )

            while parentApp is not None:
                appInfo = cur[APPS][parentApp]

                # keep xwits immutable, don&#39;t say xwits |= blabla
                # because that will change xwits in place
                xwits = xwits | appInfo[X_WITS]
                parentApp = appInfo[PARENT]

            cur[X_WITS].append(xwits)

        elif tag == LEM:
            pass

        elif tag == RDG:
            wits = set()
            if WIT in atts:
                wits = {w.strip(&#34;.&#34;).lower() for w in atts[WIT].split()}
                atts[WIT] = &#34; &#34;.join(wits)

            cur[WITS].append(wits)

    def endApp(self, node):
        cv = self.cv
        cur = self.cur
        curVarSent = cur[self.varSent]
        curStackSent = cur[self.stackSent]

        tag = node.tag

        if tag == APP:
            cur[X_WITS].pop()

            for variantSent in curVarSent.values():
                if variantSent is not None:
                    cv.resume(variantSent)

            curStackSent.pop()
            cur[TRANS_LAST] = cur[TRANS_NEXT].pop()

        elif tag == LEM:
            cur[TRANS_NEXT][-1] = cur[TRANS_LAST]

            curBaseSent = curVarSent[BASE]
            if curBaseSent is not None:
                cv.terminate(curBaseSent)

        elif tag == RDG:
            wits = cur[WITS][-1]

            for wit in wits:
                curWitSent = curVarSent.get(wit, None)
                if curWitSent is not None:
                    cv.terminate(curWitSent)

            cur[WITS].pop()

    def startSentLem(self):
        cur = self.cur
        curVarSent = cur[self.varSent]

        if curVarSent.get(BASE, None) is None:
            cv = self.cv
            sentType = self.sentType
            nSent = self.nSent

            curSent = cv.node(sentType)
            cur[nSent] += 1
            curVarSent[BASE] = curSent
            cv.feature(curSent, wit=BASE, n=cur[nSent])

    def endSentLem(self):
        cv = self.cv
        cur = self.cur
        curVarSent = cur[self.varSent]

        toDelete = []

        for (wit, sent) in curVarSent.items():
            isBase = wit == BASE
            isXwit = wit in cur[X_WITS][-1]
            if isBase or not isXwit:
                cv.terminate(sent)
                if isBase:
                    curVarSent[wit] = None
                else:
                    toDelete.append(wit)

        for wit in toDelete:
            del curVarSent[wit]

    def startSentRdg(self):
        cv = self.cv
        sentType = self.sentType
        cur = self.cur
        curStackSent = cur[self.stackSent]
        curVarSent = cur[self.varSent]
        nSent = self.nSent

        wits = cur[WITS][-1]
        topStack = curStackSent[-1]
        cur[TRANS_LAST] = topStack[TRANS_LAST]

        for wit in wits:
            curSent = curVarSent.get(wit, None)
            if curSent is None:
                curSent = cv.node(sentType)
                cur[nSent] += 1
                curVarSent[wit] = curSent
                cv.feature(curSent, wit=wit, n=cur[nSent])
                slots = topStack[SLOTS]
                if slots is not None:
                    cv.link(curSent, topStack[SLOTS])

    def endSentRdg(self):
        cv = self.cv
        cur = self.cur
        curVarSent = cur[self.varSent]

        wits = cur[WITS][-1]

        for wit in wits:
            curSent = curVarSent.get(wit, None)
            if curSent is not None:
                cv.terminate(curSent)
                curVarSent[wit] = None

    def checkSent(self, trans, punc, checkPunc):
        cur = self.cur

        lastTrans = trans or cur[TRANS_LAST] or &#34;&#34;
        if checkPunc(lastTrans, trans, punc):
            self.endSent()
        else:
            cur[TRANS_LAST] = trans

    def startSent(self):
        cur = self.cur

        inRdg = &#34;rdg&#34; in cur and len(cur[&#34;rdg&#34;]) &gt; 0
        inLem = &#34;lem&#34; in cur and len(cur[&#34;lem&#34;]) &gt; 0

        if inLem:
            self.startSentLem()
        elif inRdg:
            self.startSentRdg()
        else:
            curVarSent = cur[self.varSent]

            if curVarSent[BASE] is None:
                cv = self.cv
                sentType = self.sentType
                nSent = self.nSent

                curSent = cv.node(sentType)
                cur[nSent] += 1
                cv.feature(curSent, n=cur[nSent])
                curVarSent[BASE] = curSent

    def endSent(self):
        cv = self.cv
        cur = self.cur
        curVarSent = cur[self.varSent]

        inRdg = &#34;rdg&#34; in cur and len(cur[&#34;rdg&#34;]) &gt; 0
        inLem = &#34;lem&#34; in cur and len(cur[&#34;lem&#34;]) &gt; 0

        if inLem:
            self.endSentLem()
        elif inRdg:
            self.endSentRdg()
        else:
            if curVarSent[BASE] is not None:
                cv.terminate(curVarSent[BASE])
                curVarSent[BASE] = None

            toDelete = []

            for (wit, sent) in curVarSent.items():
                isBase = wit == BASE

                if sent is not None:
                    cv.terminate(sent)
                    if isBase:
                        curVarSent[wit] = None
                    else:
                        toDelete.append(wit)

            for wit in toDelete:
                del curVarSent[wit]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.convert.variants.Variants"><code class="flex name class">
<span>class <span class="ident">Variants</span></span>
<span>(</span><span>cv, cur, sentType, addWarning, addError)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L34-L348" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Variants:
    def __init__(self, cv, cur, sentType, addWarning, addError):
        self.cv = cv
        self.cur = cur
        self.sentType = sentType
        self.addWarning = addWarning
        self.addError = addError
        self.nSent = f&#34;n{sentType}&#34;
        self.stackSent = f&#34;stack{sentType}&#34;
        self.varSent = f&#34;variants{sentType}&#34;
        cur[WITNESSES] = set()

    def initApps(self):
        cur = self.cur

        cur[APPS] = dict()
        cur[APP_STACK] = []
        cur[TRANS_NEXT] = []
        cur[N_APP] = 0

    def collectWitnesses(self, node):
        &#34;&#34;&#34;Collect all witnesses.

        first collect witnesses from all rdg elements
        and store information for each lemma what witnesses occur in sibling rdgs
        we number the lem elements globally as we encounter them,
        and store info for that lem under that number,
        so that we can refer to that info when we encounter the lem during
        the second pass.

        The info per lem is
        - the set of all witnesses mentioned in the wit attribute of all its
          sibling rdgs
        The number of its parent lem or None if there is no parent lem

        We also check whether there are multiple direct rdg children of the same
        app that share witnesses (which would be strange: conflicting information)
        &#34;&#34;&#34;

        cur = self.cur
        addWarning = self.addWarning

        tag = node.tag.lower()
        atts = node.attrib

        appStack = cur[APP_STACK]
        apps = cur[APPS]

        if tag == APP:
            parentApp = appStack[-1] if len(appStack) else None
            nApp = cur[N_APP]
            cur[N_APP] = nApp + 1
            appStack.append(nApp + 1)
            apps[nApp + 1] = dict(parent=parentApp, xwits=set(), rdgs=[])

        elif tag == RDG:
            att = WIT

            if att in atts:
                ws = {w.strip(&#34;.&#34;).lower() for w in atts[att].split()}
                cur[WITNESSES] |= ws
                apps[appStack[-1]][X_WITS] |= ws
                rdgSeen = apps[appStack[-1]][RDGS]
                for rdg in rdgSeen:
                    if rdg &amp; ws:
                        addWarning(
                            &#34;witnesses of rdg not disjoint from sibling rdgs&#34;, cur
                        )
                apps[appStack[-1]][RDGS].append(ws)

        for child in node:
            self.collectWitnesses(child)

        if tag == APP:
            appStack.pop()

    def resetApps(self):
        cur = self.cur

        cur[N_APP] = 0
        cur[WITS] = []
        cur[X_WITS] = []

    def initSent(self):
        cur = self.cur
        nSent = self.nSent
        stackSent = self.stackSent
        varSent = self.varSent

        cur[TRANS_LAST] = None
        cur[nSent] = 0
        cur[stackSent] = []
        cur[varSent] = {BASE: None}

    def startApp(self, node):
        cv = self.cv
        cur = self.cur
        curVarSent = cur[self.varSent]
        curStackSent = cur[self.stackSent]

        tag = node.tag
        atts = node.attrib

        if tag == APP:
            nApp = cur[N_APP]
            cur[N_APP] = nApp + 1
            appInfo = cur[APPS][nApp + 1]
            parentApp = appInfo[PARENT]
            xwits = appInfo[X_WITS]

            curSent = curVarSent.get(BASE, None)
            cur[TRANS_NEXT].append(&#34;&#34;)

            if curSent is None:
                slots = None
            else:
                slots = cv.linked(curSent)
                cv.feature(curSent, wit=BASE)

            curStackSent.append(
                dict(
                    translast=cur[TRANS_LAST],
                    slots=slots,
                )
            )

            while parentApp is not None:
                appInfo = cur[APPS][parentApp]

                # keep xwits immutable, don&#39;t say xwits |= blabla
                # because that will change xwits in place
                xwits = xwits | appInfo[X_WITS]
                parentApp = appInfo[PARENT]

            cur[X_WITS].append(xwits)

        elif tag == LEM:
            pass

        elif tag == RDG:
            wits = set()
            if WIT in atts:
                wits = {w.strip(&#34;.&#34;).lower() for w in atts[WIT].split()}
                atts[WIT] = &#34; &#34;.join(wits)

            cur[WITS].append(wits)

    def endApp(self, node):
        cv = self.cv
        cur = self.cur
        curVarSent = cur[self.varSent]
        curStackSent = cur[self.stackSent]

        tag = node.tag

        if tag == APP:
            cur[X_WITS].pop()

            for variantSent in curVarSent.values():
                if variantSent is not None:
                    cv.resume(variantSent)

            curStackSent.pop()
            cur[TRANS_LAST] = cur[TRANS_NEXT].pop()

        elif tag == LEM:
            cur[TRANS_NEXT][-1] = cur[TRANS_LAST]

            curBaseSent = curVarSent[BASE]
            if curBaseSent is not None:
                cv.terminate(curBaseSent)

        elif tag == RDG:
            wits = cur[WITS][-1]

            for wit in wits:
                curWitSent = curVarSent.get(wit, None)
                if curWitSent is not None:
                    cv.terminate(curWitSent)

            cur[WITS].pop()

    def startSentLem(self):
        cur = self.cur
        curVarSent = cur[self.varSent]

        if curVarSent.get(BASE, None) is None:
            cv = self.cv
            sentType = self.sentType
            nSent = self.nSent

            curSent = cv.node(sentType)
            cur[nSent] += 1
            curVarSent[BASE] = curSent
            cv.feature(curSent, wit=BASE, n=cur[nSent])

    def endSentLem(self):
        cv = self.cv
        cur = self.cur
        curVarSent = cur[self.varSent]

        toDelete = []

        for (wit, sent) in curVarSent.items():
            isBase = wit == BASE
            isXwit = wit in cur[X_WITS][-1]
            if isBase or not isXwit:
                cv.terminate(sent)
                if isBase:
                    curVarSent[wit] = None
                else:
                    toDelete.append(wit)

        for wit in toDelete:
            del curVarSent[wit]

    def startSentRdg(self):
        cv = self.cv
        sentType = self.sentType
        cur = self.cur
        curStackSent = cur[self.stackSent]
        curVarSent = cur[self.varSent]
        nSent = self.nSent

        wits = cur[WITS][-1]
        topStack = curStackSent[-1]
        cur[TRANS_LAST] = topStack[TRANS_LAST]

        for wit in wits:
            curSent = curVarSent.get(wit, None)
            if curSent is None:
                curSent = cv.node(sentType)
                cur[nSent] += 1
                curVarSent[wit] = curSent
                cv.feature(curSent, wit=wit, n=cur[nSent])
                slots = topStack[SLOTS]
                if slots is not None:
                    cv.link(curSent, topStack[SLOTS])

    def endSentRdg(self):
        cv = self.cv
        cur = self.cur
        curVarSent = cur[self.varSent]

        wits = cur[WITS][-1]

        for wit in wits:
            curSent = curVarSent.get(wit, None)
            if curSent is not None:
                cv.terminate(curSent)
                curVarSent[wit] = None

    def checkSent(self, trans, punc, checkPunc):
        cur = self.cur

        lastTrans = trans or cur[TRANS_LAST] or &#34;&#34;
        if checkPunc(lastTrans, trans, punc):
            self.endSent()
        else:
            cur[TRANS_LAST] = trans

    def startSent(self):
        cur = self.cur

        inRdg = &#34;rdg&#34; in cur and len(cur[&#34;rdg&#34;]) &gt; 0
        inLem = &#34;lem&#34; in cur and len(cur[&#34;lem&#34;]) &gt; 0

        if inLem:
            self.startSentLem()
        elif inRdg:
            self.startSentRdg()
        else:
            curVarSent = cur[self.varSent]

            if curVarSent[BASE] is None:
                cv = self.cv
                sentType = self.sentType
                nSent = self.nSent

                curSent = cv.node(sentType)
                cur[nSent] += 1
                cv.feature(curSent, n=cur[nSent])
                curVarSent[BASE] = curSent

    def endSent(self):
        cv = self.cv
        cur = self.cur
        curVarSent = cur[self.varSent]

        inRdg = &#34;rdg&#34; in cur and len(cur[&#34;rdg&#34;]) &gt; 0
        inLem = &#34;lem&#34; in cur and len(cur[&#34;lem&#34;]) &gt; 0

        if inLem:
            self.endSentLem()
        elif inRdg:
            self.endSentRdg()
        else:
            if curVarSent[BASE] is not None:
                cv.terminate(curVarSent[BASE])
                curVarSent[BASE] = None

            toDelete = []

            for (wit, sent) in curVarSent.items():
                isBase = wit == BASE

                if sent is not None:
                    cv.terminate(sent)
                    if isBase:
                        curVarSent[wit] = None
                    else:
                        toDelete.append(wit)

            for wit in toDelete:
                del curVarSent[wit]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.convert.variants.Variants.checkSent"><code class="name flex">
<span>def <span class="ident">checkSent</span></span>(<span>self, trans, punc, checkPunc)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L286-L293" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkSent(self, trans, punc, checkPunc):
    cur = self.cur

    lastTrans = trans or cur[TRANS_LAST] or &#34;&#34;
    if checkPunc(lastTrans, trans, punc):
        self.endSent()
    else:
        cur[TRANS_LAST] = trans</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.collectWitnesses"><code class="name flex">
<span>def <span class="ident">collectWitnesses</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Collect all witnesses.</p>
<p>first collect witnesses from all rdg elements
and store information for each lemma what witnesses occur in sibling rdgs
we number the lem elements globally as we encounter them,
and store info for that lem under that number,
so that we can refer to that info when we encounter the lem during
the second pass.</p>
<p>The info per lem is
- the set of all witnesses mentioned in the wit attribute of all its
sibling rdgs
The number of its parent lem or None if there is no parent lem</p>
<p>We also check whether there are multiple direct rdg children of the same
app that share witnesses (which would be strange: conflicting information)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L54-L108" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def collectWitnesses(self, node):
    &#34;&#34;&#34;Collect all witnesses.

    first collect witnesses from all rdg elements
    and store information for each lemma what witnesses occur in sibling rdgs
    we number the lem elements globally as we encounter them,
    and store info for that lem under that number,
    so that we can refer to that info when we encounter the lem during
    the second pass.

    The info per lem is
    - the set of all witnesses mentioned in the wit attribute of all its
      sibling rdgs
    The number of its parent lem or None if there is no parent lem

    We also check whether there are multiple direct rdg children of the same
    app that share witnesses (which would be strange: conflicting information)
    &#34;&#34;&#34;

    cur = self.cur
    addWarning = self.addWarning

    tag = node.tag.lower()
    atts = node.attrib

    appStack = cur[APP_STACK]
    apps = cur[APPS]

    if tag == APP:
        parentApp = appStack[-1] if len(appStack) else None
        nApp = cur[N_APP]
        cur[N_APP] = nApp + 1
        appStack.append(nApp + 1)
        apps[nApp + 1] = dict(parent=parentApp, xwits=set(), rdgs=[])

    elif tag == RDG:
        att = WIT

        if att in atts:
            ws = {w.strip(&#34;.&#34;).lower() for w in atts[att].split()}
            cur[WITNESSES] |= ws
            apps[appStack[-1]][X_WITS] |= ws
            rdgSeen = apps[appStack[-1]][RDGS]
            for rdg in rdgSeen:
                if rdg &amp; ws:
                    addWarning(
                        &#34;witnesses of rdg not disjoint from sibling rdgs&#34;, cur
                    )
            apps[appStack[-1]][RDGS].append(ws)

    for child in node:
        self.collectWitnesses(child)

    if tag == APP:
        appStack.pop()</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.endApp"><code class="name flex">
<span>def <span class="ident">endApp</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L181-L214" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def endApp(self, node):
    cv = self.cv
    cur = self.cur
    curVarSent = cur[self.varSent]
    curStackSent = cur[self.stackSent]

    tag = node.tag

    if tag == APP:
        cur[X_WITS].pop()

        for variantSent in curVarSent.values():
            if variantSent is not None:
                cv.resume(variantSent)

        curStackSent.pop()
        cur[TRANS_LAST] = cur[TRANS_NEXT].pop()

    elif tag == LEM:
        cur[TRANS_NEXT][-1] = cur[TRANS_LAST]

        curBaseSent = curVarSent[BASE]
        if curBaseSent is not None:
            cv.terminate(curBaseSent)

    elif tag == RDG:
        wits = cur[WITS][-1]

        for wit in wits:
            curWitSent = curVarSent.get(wit, None)
            if curWitSent is not None:
                cv.terminate(curWitSent)

        cur[WITS].pop()</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.endSent"><code class="name flex">
<span>def <span class="ident">endSent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L318-L348" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def endSent(self):
    cv = self.cv
    cur = self.cur
    curVarSent = cur[self.varSent]

    inRdg = &#34;rdg&#34; in cur and len(cur[&#34;rdg&#34;]) &gt; 0
    inLem = &#34;lem&#34; in cur and len(cur[&#34;lem&#34;]) &gt; 0

    if inLem:
        self.endSentLem()
    elif inRdg:
        self.endSentRdg()
    else:
        if curVarSent[BASE] is not None:
            cv.terminate(curVarSent[BASE])
            curVarSent[BASE] = None

        toDelete = []

        for (wit, sent) in curVarSent.items():
            isBase = wit == BASE

            if sent is not None:
                cv.terminate(sent)
                if isBase:
                    curVarSent[wit] = None
                else:
                    toDelete.append(wit)

        for wit in toDelete:
            del curVarSent[wit]</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.endSentLem"><code class="name flex">
<span>def <span class="ident">endSentLem</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L230-L248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def endSentLem(self):
    cv = self.cv
    cur = self.cur
    curVarSent = cur[self.varSent]

    toDelete = []

    for (wit, sent) in curVarSent.items():
        isBase = wit == BASE
        isXwit = wit in cur[X_WITS][-1]
        if isBase or not isXwit:
            cv.terminate(sent)
            if isBase:
                curVarSent[wit] = None
            else:
                toDelete.append(wit)

    for wit in toDelete:
        del curVarSent[wit]</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.endSentRdg"><code class="name flex">
<span>def <span class="ident">endSentRdg</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L273-L284" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def endSentRdg(self):
    cv = self.cv
    cur = self.cur
    curVarSent = cur[self.varSent]

    wits = cur[WITS][-1]

    for wit in wits:
        curSent = curVarSent.get(wit, None)
        if curSent is not None:
            cv.terminate(curSent)
            curVarSent[wit] = None</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.initApps"><code class="name flex">
<span>def <span class="ident">initApps</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L46-L52" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def initApps(self):
    cur = self.cur

    cur[APPS] = dict()
    cur[APP_STACK] = []
    cur[TRANS_NEXT] = []
    cur[N_APP] = 0</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.initSent"><code class="name flex">
<span>def <span class="ident">initSent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L117-L126" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def initSent(self):
    cur = self.cur
    nSent = self.nSent
    stackSent = self.stackSent
    varSent = self.varSent

    cur[TRANS_LAST] = None
    cur[nSent] = 0
    cur[stackSent] = []
    cur[varSent] = {BASE: None}</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.resetApps"><code class="name flex">
<span>def <span class="ident">resetApps</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L110-L115" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resetApps(self):
    cur = self.cur

    cur[N_APP] = 0
    cur[WITS] = []
    cur[X_WITS] = []</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.startApp"><code class="name flex">
<span>def <span class="ident">startApp</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L128-L179" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def startApp(self, node):
    cv = self.cv
    cur = self.cur
    curVarSent = cur[self.varSent]
    curStackSent = cur[self.stackSent]

    tag = node.tag
    atts = node.attrib

    if tag == APP:
        nApp = cur[N_APP]
        cur[N_APP] = nApp + 1
        appInfo = cur[APPS][nApp + 1]
        parentApp = appInfo[PARENT]
        xwits = appInfo[X_WITS]

        curSent = curVarSent.get(BASE, None)
        cur[TRANS_NEXT].append(&#34;&#34;)

        if curSent is None:
            slots = None
        else:
            slots = cv.linked(curSent)
            cv.feature(curSent, wit=BASE)

        curStackSent.append(
            dict(
                translast=cur[TRANS_LAST],
                slots=slots,
            )
        )

        while parentApp is not None:
            appInfo = cur[APPS][parentApp]

            # keep xwits immutable, don&#39;t say xwits |= blabla
            # because that will change xwits in place
            xwits = xwits | appInfo[X_WITS]
            parentApp = appInfo[PARENT]

        cur[X_WITS].append(xwits)

    elif tag == LEM:
        pass

    elif tag == RDG:
        wits = set()
        if WIT in atts:
            wits = {w.strip(&#34;.&#34;).lower() for w in atts[WIT].split()}
            atts[WIT] = &#34; &#34;.join(wits)

        cur[WITS].append(wits)</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.startSent"><code class="name flex">
<span>def <span class="ident">startSent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L295-L316" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def startSent(self):
    cur = self.cur

    inRdg = &#34;rdg&#34; in cur and len(cur[&#34;rdg&#34;]) &gt; 0
    inLem = &#34;lem&#34; in cur and len(cur[&#34;lem&#34;]) &gt; 0

    if inLem:
        self.startSentLem()
    elif inRdg:
        self.startSentRdg()
    else:
        curVarSent = cur[self.varSent]

        if curVarSent[BASE] is None:
            cv = self.cv
            sentType = self.sentType
            nSent = self.nSent

            curSent = cv.node(sentType)
            cur[nSent] += 1
            cv.feature(curSent, n=cur[nSent])
            curVarSent[BASE] = curSent</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.startSentLem"><code class="name flex">
<span>def <span class="ident">startSentLem</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L216-L228" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def startSentLem(self):
    cur = self.cur
    curVarSent = cur[self.varSent]

    if curVarSent.get(BASE, None) is None:
        cv = self.cv
        sentType = self.sentType
        nSent = self.nSent

        curSent = cv.node(sentType)
        cur[nSent] += 1
        curVarSent[BASE] = curSent
        cv.feature(curSent, wit=BASE, n=cur[nSent])</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.startSentRdg"><code class="name flex">
<span>def <span class="ident">startSentRdg</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/c1ccd4a4dc451e94a789f138576576c5d7f13474/tf/convert/variants.py#L250-L271" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def startSentRdg(self):
    cv = self.cv
    sentType = self.sentType
    cur = self.cur
    curStackSent = cur[self.stackSent]
    curVarSent = cur[self.varSent]
    nSent = self.nSent

    wits = cur[WITS][-1]
    topStack = curStackSent[-1]
    cur[TRANS_LAST] = topStack[TRANS_LAST]

    for wit in wits:
        curSent = curVarSent.get(wit, None)
        if curSent is None:
            curSent = cv.node(sentType)
            cur[nSent] += 1
            curVarSent[wit] = curSent
            cv.feature(curSent, wit=wit, n=cur[nSent])
            slots = topStack[SLOTS]
            if slots is not None:
                cv.link(curSent, topStack[SLOTS])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#variants">Variants</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.convert" href="index.html">tf.convert</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.convert.variants.Variants" href="#tf.convert.variants.Variants">Variants</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.convert.variants.Variants.checkSent" href="#tf.convert.variants.Variants.checkSent">checkSent</a></code></li>
<li><code><a title="tf.convert.variants.Variants.collectWitnesses" href="#tf.convert.variants.Variants.collectWitnesses">collectWitnesses</a></code></li>
<li><code><a title="tf.convert.variants.Variants.endApp" href="#tf.convert.variants.Variants.endApp">endApp</a></code></li>
<li><code><a title="tf.convert.variants.Variants.endSent" href="#tf.convert.variants.Variants.endSent">endSent</a></code></li>
<li><code><a title="tf.convert.variants.Variants.endSentLem" href="#tf.convert.variants.Variants.endSentLem">endSentLem</a></code></li>
<li><code><a title="tf.convert.variants.Variants.endSentRdg" href="#tf.convert.variants.Variants.endSentRdg">endSentRdg</a></code></li>
<li><code><a title="tf.convert.variants.Variants.initApps" href="#tf.convert.variants.Variants.initApps">initApps</a></code></li>
<li><code><a title="tf.convert.variants.Variants.initSent" href="#tf.convert.variants.Variants.initSent">initSent</a></code></li>
<li><code><a title="tf.convert.variants.Variants.resetApps" href="#tf.convert.variants.Variants.resetApps">resetApps</a></code></li>
<li><code><a title="tf.convert.variants.Variants.startApp" href="#tf.convert.variants.Variants.startApp">startApp</a></code></li>
<li><code><a title="tf.convert.variants.Variants.startSent" href="#tf.convert.variants.Variants.startSent">startSent</a></code></li>
<li><code><a title="tf.convert.variants.Variants.startSentLem" href="#tf.convert.variants.Variants.startSentLem">startSentLem</a></code></li>
<li><code><a title="tf.convert.variants.Variants.startSentRdg" href="#tf.convert.variants.Variants.startSentRdg">startSentRdg</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="../../tf/images/DANS-logo.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>