<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.convert.watm API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-GjqubOlYA6/wOZV7F31o2t4ogk4JGDGFa6XmL+BfAG0=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-qDPJ4nH38AgHyK3U6cvI6DBifA+7hPBo8mVoH6pyN9c=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.convert.watm</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L1-L992" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import collections
import json
import re

from tf.core.helpers import console
from tf.core.files import initTree, dirContents, expanduser as ex
from tf.core.timestamp import DEEP
from tf.parameters import OTYPE, OSLOTS
from tf.app import use


TT_NAME = &#34;watm&#34;

NS_TF = &#34;tf&#34;
NS_PAGEXML = &#34;pagexml&#34;
NS_TEI = &#34;tei&#34;
NS_NLP = &#34;nlp&#34;
NS_TT = &#34;tt&#34;
NS_NONE = &#34;tf&#34;

NS_FROM_OTYPE = dict(
    doc=NS_TF,
    page=NS_TF,
    file=NS_TF,
    folder=NS_TF,
    letter=NS_TF,
    chapter=NS_TF,
    chunk=NS_TF,
    word=NS_TF,
    char=NS_TF,
    token=NS_NLP,
    sentence=NS_NLP,
)
NS_FROM_FEAT = dict(
    otype=NS_TF,
    doc=NS_TF,
    page=NS_TF,
    line=NS_TF,
    after=NS_TF,
    rafter=NS_TF,
    str=NS_TF,
    rstr=NS_TF,
)

KIND_NODE = &#34;node&#34;
KIND_EDGE = &#34;edge&#34;
KIND_ELEM = &#34;element&#34;
KIND_PI = &#34;pi&#34;
KIND_ATTR = &#34;attribute&#34;
KIND_FMT = &#34;format&#34;
KIND_ANNO = &#34;anno&#34;

REL_RE = re.compile(r&#34;&#34;&#34;/tf\b&#34;&#34;&#34;)


def rep(status):
    return &#34;OK&#34; if status else &#34;XX&#34;


class WATM:
    def __init__(self, app, nsOrig, skipMeta=False, extra={}):
        self.app = app
        self.nsOrig = nsOrig
        self.extra = extra
        api = app.api
        F = api.F
        E = api.E

        self.L = api.L
        self.Es = api.Es
        self.F = F
        self.E = E
        self.Fs = api.Fs
        self.slotType = self.F.otype.slotType
        self.otypes = self.F.otype.all
        self.info = app.info
        self.repoLocation = app.repoLocation

        Fall = api.Fall
        Eall = api.Eall
        self.Fall = Fall
        self.Eall = Eall

        excludedFeatures = {OTYPE, OSLOTS, &#34;after&#34;, &#34;str&#34;}
        self.nodeFeatures = [f for f in Fall() if f not in excludedFeatures]
        self.edgeFeatures = [f for f in Eall() if f not in excludedFeatures]

        FAllSet = set(Fall())

        self.fotypev = F.otype.v
        self.eoslots = E.oslots.s
        self.emptyv = F.empty.v if &#34;empty&#34; in FAllSet else None
        self.strv = F.str.v if &#34;str&#34; in FAllSet else None
        self.rstrv = F.rstr.v if &#34;rstr&#34; in FAllSet else None
        self.afterv = F.after.v if &#34;after&#34; in FAllSet else None
        self.rafterv = F.rafter.v if &#34;rafter&#34; in FAllSet else None
        is_metav = F.is_meta.v if &#34;is_meta&#34; in FAllSet else None
        self.is_metav = is_metav

        if skipMeta and not is_metav:
            console(
                &#34;skipMeta=True has no effect because feature is_meta is not defined.&#34;,
                error=True,
            )
            skipMeta = False

        self.skipMeta = skipMeta

    def makeText(self):
        F = self.F
        slotType = self.slotType
        skipMeta = self.skipMeta

        emptyv = self.emptyv
        strv = self.strv
        rstrv = self.rstrv
        afterv = self.afterv
        rafterv = self.rafterv
        is_metav = self.is_metav

        text = []
        tlFromTf = {}

        self.text = text
        self.tlFromTf = tlFromTf

        for s in F.otype.s(slotType):
            if skipMeta and is_metav(s):
                continue

            after = rafterv(s) if rafterv else None

            if after is None:
                after = afterv(s) if afterv else None

            if after is None:
                after = &#34;&#34;

            if emptyv and emptyv(s):
                value = after
            else:
                string = rstrv(s) if rstrv else None

                if string is None:
                    string = strv(s) if strv else None

                if string is None:
                    string = &#34;&#34;

                value = f&#34;{string}{after}&#34;

            text.append(value)
            t = len(text) - 1
            tlFromTf[s] = t

    def mkAnno(self, kind, ns, body, target):
        &#34;&#34;&#34;Make an annotation and return its id.

        Parameters
        ----------
        kind: string
            The kind of annotation.
        ns: string
            The namespace of the annotation.
        body: string
            The body of the annotation.
        target: string  or tuple of strings
            The target of the annotation.
        &#34;&#34;&#34;
        annos = self.annos
        aId = f&#34;a{len(annos):&gt;08}&#34;
        annos.append((kind, aId, ns, body, target))
        return aId

    def makeAnno(self):
        Es = self.Es
        F = self.F
        Fs = self.Fs
        fotypev = self.fotypev
        eoslots = self.eoslots
        nodeFeatures = self.nodeFeatures
        edgeFeatures = self.edgeFeatures
        slotType = self.slotType
        otypes = self.otypes
        nsOrig = self.nsOrig
        skipMeta = self.skipMeta

        tlFromTf = self.tlFromTf

        is_metav = self.is_metav

        isTei = nsOrig == NS_TEI

        annos = []
        text = self.text
        self.annos = annos

        wrongTargets = []

        for otype in otypes:
            isSlot = otype == slotType

            for n in F.otype.s(otype):
                if isSlot:
                    if skipMeta and is_metav(n):
                        continue

                    t = tlFromTf[n]
                    target = f&#34;{t}-{t + 1}&#34;
                    self.mkAnno(KIND_NODE, NS_TF, n, target)
                else:
                    ws = eoslots(n)
                    if skipMeta and (is_metav(ws[0]) or is_metav(ws[-1])):
                        continue

                    start = tlFromTf[ws[0]]
                    end = tlFromTf[ws[-1]]
                    if end &lt; start:
                        wrongTargets.append((otype, start, end))

                    target = f&#34;{start}-{end + 1}&#34;
                    aId = (
                        self.mkAnno(KIND_PI, nsOrig, otype[1:], target)
                        if otype.startswith(&#34;?&#34;)
                        else self.mkAnno(
                            KIND_ELEM, NS_FROM_OTYPE.get(otype, nsOrig), otype, target
                        )
                    )
                    tlFromTf[n] = aId
                    self.mkAnno(KIND_NODE, NS_TF, n, aId)

        for feat in nodeFeatures:
            ns = Fs(feat).meta.get(&#34;conversionCode&#34;, NS_FROM_FEAT.get(feat, nsOrig))

            if ns is None:
                console(
                    f&#34;Node feature {feat} has no namespace, &#34;
                    f&#34;defaulting to {NS_NONE}&#34;,
                    error=True,
                )
                ns = NS_NONE

            isRend = False
            isNote = False

            if isTei:
                parts = feat.split(&#34;_&#34;, 2)
                isRend = len(parts) &gt;= 2 and parts[0] == &#34;rend&#34;
                isNote = len(parts) == 2 and parts[0] == &#34;is&#34; and parts[1] == &#34;note&#34;

            if isRend:
                for n, val in Fs(feat).items():
                    if not val or (skipMeta and is_metav(n)):
                        continue

                    prop = parts[1]
                    t = tlFromTf[n]
                    target = f&#34;{t}-{t + 1}&#34; if fotypev(n) == slotType else t
                    self.mkAnno(KIND_FMT, ns, prop, target)
            elif isNote:
                for n, val in Fs(feat).items():
                    if not val or (skipMeta and is_metav(n)):
                        continue

                    t = tlFromTf[n]
                    target = f&#34;{t}-{t + 1}&#34; if fotypev(n) == slotType else t
                    self.mkAnno(KIND_FMT, ns, &#34;note&#34;, target)
            else:
                for n, val in Fs(feat).items():
                    if skipMeta and is_metav(n):
                        continue

                    t = tlFromTf.get(n, None)

                    if t is None:
                        continue

                    target = f&#34;{t}-{t + 1}&#34; if fotypev(n) == slotType else t
                    aId = self.mkAnno(KIND_ATTR, ns, f&#34;{feat}={val}&#34;, target)

        for feat in edgeFeatures:
            ns = Es(feat).meta.get(&#34;conversionCode&#34;, NS_FROM_FEAT.get(feat, nsOrig))

            if ns is None:
                console(
                    f&#34;Edge feature {feat} has no conversion code, &#34;
                    f&#34;defaulting to {NS_NONE}&#34;,
                    error=True,
                )
                ns = NS_NONE

            for fromNode, toNodes in Es(feat).items():
                if skipMeta and is_metav(fromNode):
                    continue

                fromT = tlFromTf.get(fromNode, None)

                if fromT is None:
                    continue

                targetFrom = (
                    f&#34;{fromT}-{fromT + 1}&#34; if fotypev(fromNode) == slotType else fromT
                )

                if type(toNodes) is dict:
                    for toNode, val in toNodes.items():
                        if skipMeta and is_metav(toNode):
                            continue

                        toT = tlFromTf.get(toNode, None)

                        if toT is None:
                            continue

                        targetTo = (
                            f&#34;{toT}-{toT + 1}&#34; if fotypev(toNode) == slotType else toT
                        )
                        target = f&#34;{targetFrom}-&gt;{targetTo}&#34;
                        aId = self.mkAnno(KIND_EDGE, ns, f&#34;{feat}={val}&#34;, target)
                else:
                    for toNode in toNodes:
                        if skipMeta and is_metav(toNode):
                            continue

                        toT = tlFromTf.get(toNode, None)

                        if toT is None:
                            continue

                        target = f&#34;{fromT}-&gt;{toT}&#34;
                        aId = self.mkAnno(KIND_EDGE, ns, feat, target)

        extra = {}
        extra.update(self.extra)

        for n, value in extra.items():
            t = tlFromTf[n]
            target = f&#34;{t}-{t + 1}&#34; if fotypev(n) == slotType else t
            aId = self.mkAnno(KIND_ANNO, NS_TT, str(value), target)

        if len(wrongTargets):
            print(f&#34;WARNING: wrong targets, {len(wrongTargets)}x&#34;)
            for otype, start, end in wrongTargets:
                sega = text[start]
                segb = text[end - 1]
                print(f&#34;{otype:&gt;20} {start:&gt;6} `{sega}` &gt; {end - 1} `{segb}`&#34;)

    def writeAll(self):
        app = self.app
        text = self.text
        annos = self.annos

        baseDir = self.repoLocation
        relative = app.context.relative
        version = app.version
        wRelative = REL_RE.sub(f&#34;/{TT_NAME}/{version}/&#34;, relative, count=1)
        resultDir = f&#34;{baseDir}{wRelative}&#34;
        textFile = f&#34;{resultDir}/text.json&#34;

        self.textFile = textFile

        initTree(resultDir, fresh=True)

        with open(textFile, &#34;w&#34;) as fh:
            json.dump(dict(_ordered_segments=text), fh, ensure_ascii=False, indent=1)

        console(f&#34;Text file: {len(text):&gt;7} segments to {textFile}&#34;)

        annoStore = {}

        for kind, aId, ns, body, target in annos:
            annoStore[aId] = (kind, ns, body, target)

        aIdSorted = sorted(annoStore.keys())

        annoFile = f&#34;{resultDir}/anno.tsv&#34;

        if False:
            with open(annoFile, &#34;w&#34;) as fh:
                for aId in aIdSorted:
                    (kind, ns, body, target) = annoStore[aId]
                    fh.write(f&#34;{aId}\t{kind}\t{ns}\t{body}\t{target}\n&#34;)

        thisAnnoStore = {}
        thisA = 1
        annoFiles = []
        self.annoFiles = annoFiles

        LIMIT = 400000
        j = 0
        total = 0

        def writeThis():
            annoFile = f&#34;{resultDir}/anno-{thisA:&gt;01}.json&#34;
            annoFiles.append(annoFile)

            with open(annoFile, &#34;w&#34;) as fh:
                json.dump(thisAnnoStore, fh, ensure_ascii=False, indent=1)

            console(f&#34;{j:&gt;6} annotations written to {annoFile}&#34;)

        for aId in aIdSorted:
            if j &gt;= LIMIT:
                writeThis()
                thisA += 1
                thisAnnoStore = {}
                total += j
                j = 0

            thisAnnoStore[aId] = annoStore[aId]
            j += 1

        if len(thisAnnoStore):
            writeThis()
            total += j

        if len(annos) != total:
            console(f&#34;Sum of batches : {total:&gt;8}&#34;)
            console(f&#34;All annotations: {len(annoStore):&gt;8}&#34;)
            console(&#34;Mismatch in number of annotations&#34;, error=True)
        console(f&#34;Anno files: {len(annos):&gt;7} annotations to {len(annoFiles)} files&#34;)

    @staticmethod
    def compare(nTF, nWA):
        console(f&#34;\tTF: {nTF:&gt;6}\n\tWA: {nWA:&gt;6}&#34;, error=nTF != nWA)
        return nTF == nWA

    @staticmethod
    def strEqual(wa=None, tf=None):
        different = False
        for i, cTF in enumerate(tf):
            if i &gt;= len(wa):
                contextI = max((0, i - 10))
                console(f&#34;\tWA {i}: {wa[contextI:i]} &lt;END&gt;&#34;, error=True)
                console(f&#34;\tTF {i}: {tf[contextI:i]} &lt;&gt; {tf[i:i + 10]}&#34;, error=True)
                different = True
                break
            elif tf[i] != wa[i]:
                contextI = max((0, i - 10))
                console(
                    f&#34;\tWA {i}: {wa[contextI:i]} &lt;{wa[i]}&gt; {wa[i + 1:i + 11]}&#34;,
                    error=True,
                )
                console(
                    f&#34;\tTF {i}: {tf[contextI:i]} &lt;{tf[i]}&gt; {tf[i + 1:i + 11]}&#34;,
                    error=True,
                )
                different = True
                break

        if not different and len(wa) &gt; len(tf):
            i = len(tf)
            contextI = max((0, i - 10))
            console(f&#34;\tWA {i}: {wa[contextI:i]} &lt;&gt; {wa[i:i + 10]}&#34;, error=True)
            console(f&#34;\tTF {i}: {tf[contextI:i]} &lt;END&gt;&#34;, error=True)
            different = True

        sampleWA = f&#34;{wa[0:20]} ... {wa[-20:]}&#34;.replace(&#34;\n&#34;, &#34; &#34;)
        sampleTF = f&#34;{tf[0:20]} ... {tf[-20:]}&#34;.replace(&#34;\n&#34;, &#34; &#34;)
        console(f&#34;\tTF: {sampleTF:&gt;6}\n\tWA: {sampleWA:&gt;6}&#34;)
        return not different

    def testSetup(self):
        textFile = self.textFile
        annoFiles = self.annoFiles

        with open(textFile) as fh:
            text = json.load(fh)
            tokens = text[&#34;_ordered_segments&#34;]

        self.testTokens = tokens

        annotationById = {}
        annotations = []

        for annoFile in annoFiles:
            with open(annoFile) as fh:
                annos = json.load(fh)

                for aId, (kind, ns, body, target) in annos.items():
                    if &#34;-&gt;&#34; in target:
                        parts = target.split(&#34;-&gt;&#34;, 1)
                    else:
                        parts = [target]
                    newParts = []
                    for part in parts:
                        if &#34;-&#34; in part:
                            (start, end) = part.split(&#34;-&#34;, 1)
                            part = (int(start), int(end))
                        newParts.append(part)

                    target = newParts[0] if len(newParts) == 1 else tuple(newParts)

                    annotationById[aId] = (kind, body, target)
                    annotations.append((aId, kind, body, target))

        annotations = sorted(annotations)
        self.testAnnotations = annotations

    def testText(self):
        F = self.F
        skipMeta = self.skipMeta
        is_metav = self.is_metav
        tokens = self.testTokens
        text = self.text

        console(&#34;Testing the text ...&#34;)

        nTokensTF = sum(
            0 if skipMeta and is_metav(s) else 1 for s in range(1, F.otype.maxSlot + 1)
        )
        nTokensWA = len(tokens)
        nGood = self.compare(nTokensTF, nTokensWA)
        console(f&#34;{rep(nGood)} - Same number of tokens&#34;, error=not nGood)

        textWA = &#34;&#34;.join(tokens)
        textTF = &#34;&#34;.join(text)

        tGood = self.strEqual(wa=textWA, tf=textTF)
        console(f&#34;{rep(tGood)} - Same text&#34;, error=not tGood)

        return nGood and tGood

    def testElements(self):
        F = self.F
        fotypev = self.fotypev
        eoslots = self.eoslots
        skipMeta = self.skipMeta
        is_metav = self.is_metav
        annotations = self.testAnnotations

        console(&#34;Testing the elements ...&#34;)

        nElementsTF = 0
        nPisTF = 0

        for n in range(F.otype.maxSlot + 1, F.otype.maxNode + 1):
            nType = fotypev(n)
            isPi = nType.startswith(&#34;?&#34;)

            if isPi:
                nPisTF += 1

            slots = eoslots(n)
            b = slots[0]
            e = slots[-1]

            if skipMeta and (is_metav(b) or is_metav(e)):
                continue
            else:
                if not isPi:
                    nElementsTF += 1

        nElementsWA = sum(
            1 if kind == &#34;element&#34; else 0 for (aId, kind, body, target) in annotations
        )
        nPisWA = sum(
            1 if kind == &#34;pi&#34; else 0 for (aId, kind, body, target) in annotations
        )

        eGood = self.compare(nElementsTF, nElementsWA)
        console(f&#34;{rep(eGood)} - Same number of elements as nodes&#34;, error=not eGood)

        pGood = self.compare(nPisTF, nPisWA)
        console(
            f&#34;{rep(pGood)} - Same number of processing instructions&#34;, error=not pGood
        )

        # element annotations

        tfFromAid = {}

        element = 0
        pi = 0
        other = 0
        good = 0
        wrong = 0
        unmapped = 0

        for aId, kind, body, target in annotations:
            if kind == &#34;node&#34;:
                tfFromAid[target] = body

        self.tfFromAid = tfFromAid

        console(f&#34;\t{len(tfFromAid)} element annotations&#34;)

        for aId, kind, body, target in annotations:
            isElem = kind == &#34;element&#34;
            isPi = kind == &#34;pi&#34;

            if not isElem and not isPi:
                other += 1
                continue

            if isElem:
                element += 1
            else:
                pi += 1

            tag = body
            node = tfFromAid.get(aId, None)
            if node is None:
                unmapped += 1
                continue

            otype = fotypev(node)

            if isPi and tag == otype[1:] or not isPi and tag == otype:
                good += 1
            else:
                wrong += 1

        console(f&#34;\tElement : {element:&gt;5} x&#34;)
        console(f&#34;\tPi      : {pi:&gt;5} x&#34;)
        console(f&#34;\tOther   : {other:&gt;5} x&#34;)
        console(f&#34;\tGood    : {good:&gt;5} x&#34;)
        console(f&#34;\tWrong   : {wrong:&gt;5} x&#34;)
        console(f&#34;\tUnmapped: {unmapped:&gt;5} x&#34;)

        aGood = wrong == 0 and unmapped == 0
        console(f&#34;{rep(aGood)} - All element annotations OK&#34;, error=not aGood)

        return aGood and eGood and pGood

    def testAttributes(self):
        Fs = self.Fs
        Fall = self.Fall
        eoslots = self.eoslots
        skipMeta = self.skipMeta
        is_metav = self.is_metav
        annotations = self.testAnnotations
        tfFromAid = self.tfFromAid
        nsOrig = self.nsOrig

        isTei = nsOrig == NS_TEI

        console(&#34;Testing the attributes ...&#34;)

        attWA = []

        for aId, kind, body, target in annotations:
            if kind != &#34;attribute&#34;:
                continue
            node = tfFromAid[target]
            (att, value) = body.split(&#34;=&#34;, 1)
            attWA.append((node, att, value))

        attWA = sorted(attWA)

        console(f&#34;\t{len(attWA)} attribute values&#34;)

        good = 0
        wrong = []

        for node, att, valWA in attWA:
            valTF = str(Fs(att).v(node))
            if valWA == valTF:
                good += 1
            else:
                wrong.append((node, att, valWA, valTF))

        console(f&#34;\tGood:     {good:&gt;5} x&#34;)
        console(f&#34;\tWrong:    {len(wrong):&gt;5} x&#34;)
        consistent = len(wrong) == 0
        console(
            f&#34;{rep(consistent)} - annotations consistent with features&#34;,
            error=not consistent,
        )

        attTF = []

        for feat in Fall():
            if feat in {&#34;otype&#34;, &#34;str&#34;, &#34;after&#34;}:
                continue

            if skipMeta and feat == &#34;is_meta&#34;:
                continue

            if isTei and (
                (feat != &#34;is_meta&#34; and feat.startswith(&#34;is_&#34;))
                or feat.startswith(&#34;rend_&#34;)
            ):
                continue

            for node, valTF in Fs(feat).items():
                slots = eoslots(node)
                b = slots[0]
                e = slots[-1]

                if skipMeta and (is_metav(b) or is_metav(e)):
                    continue

                attTF.append((node, feat, str(valTF)))

        attTF = sorted(attTF)

        console(f&#34;\tWA attributes: {len(attWA)}&#34;)
        console(f&#34;\tTF attributes: {len(attTF)}&#34;)
        complete = attTF == attWA
        console(
            f&#34;{rep(complete)} - annotations complete w.r.t. features&#34;,
            error=not complete,
        )

        console(&#34;Testing the format attributes ...&#34;)

        fmtWA = []

        for aId, kind, body, target in annotations:
            if kind != &#34;format&#34;:
                continue
            if body == &#34;note&#34;:
                continue
            node = tfFromAid[target]
            fmtWA.append((node, body))

        fmtWA = sorted(fmtWA)
        fmtWaFreq = collections.Counter()

        for node, body in fmtWA:
            fmtWaFreq[body] += 1

        console(f&#34;\t{len(fmtWA)} format values&#34;)
        console(&#34;\tformatting attributes: &#34;)
        for fa, n in sorted(fmtWaFreq.items(), key=lambda x: (-x[1], x[0])):
            console(f&#34;\t\t{n:&gt;6} x {fa}&#34;)

        good = 0
        wrong = []

        for node, valWA in fmtWA:
            feat = f&#34;rend_{valWA}&#34;
            valTF = valWA if str(Fs(feat).v(node)) else None
            if valWA == valTF:
                good += 1
            else:
                wrong.append((node, feat, valWA, valTF))

        console(f&#34;\tGood:     {good:&gt;5} x&#34;)
        console(f&#34;\tWrong:    {len(wrong):&gt;5} x&#34;)
        fconsistent = len(wrong) == 0
        console(
            f&#34;{rep(fconsistent)} - format annotations consistent with features&#34;,
            error=not fconsistent,
        )

        fmtTF = []

        for feat in Fall():
            if not feat.startswith(&#34;rend_&#34;):
                continue

            value = feat.split(&#34;_&#34;, 2)[1]
            if value == &#34;note&#34;:
                continue

            for node, valTF in Fs(feat).items():
                slots = eoslots(node)
                b = slots[0]
                e = slots[-1]

                if skipMeta and (is_metav(b) or is_metav(e)):
                    continue

                fmtTF.append((node, value))

        fmtTF = sorted(fmtTF)

        console(f&#34;\tWA format attributes: {len(fmtWA)}&#34;)
        console(f&#34;\tTF format attributes: {len(fmtTF)}&#34;)
        fcomplete = fmtTF == fmtWA
        console(
            f&#34;{rep(complete)} - format annotations complete w.r.t. features&#34;,
            error=not fcomplete,
        )

        return consistent and complete and fconsistent and fcomplete

    def testEdges(self):
        Es = self.Es
        Eall = self.Eall
        annotations = self.testAnnotations

        console(&#34;Testing the edges ...&#34;)

        tfFromAidNodes = {}
        tfFromAidEdges = {}

        for aId, kind, body, target in annotations:
            if kind != &#34;node&#34;:
                continue
            if type(target) is tuple:
                (start, end) = target
                if start + 1 != end:
                    print(target)
                    break
                target = end
            tfFromAidNodes[target] = body

        for aId, kind, body, target in annotations:
            if kind != &#34;edge&#34;:
                continue

            (fro, to) = target
            fromNode = tfFromAidNodes[fro]
            toNode = tfFromAidNodes[to]
            parts = body.split(&#34;=&#34;, 1)
            (name, val) = (body, None) if len(parts) == 1 else parts
            tfFromAidEdges.setdefault(name, {}).setdefault(fromNode, {})[toNode] = val

        console(f&#34;\tFound: {len(tfFromAidNodes)} nodes&#34;)

        for edge, edgeData in sorted(tfFromAidEdges.items()):
            print(f&#34;\tFound edge {edge} with {len(edgeData)} starting nodes&#34;)

        allGood = True

        for edge in set(Eall()) | set(tfFromAidEdges):
            if edge == &#34;oslots&#34;:
                continue

            print(f&#34;Checking edge {edge}&#34;)

            good = True

            if edge not in set(Eall()):
                print(&#34;\tmissing in TF data&#34;)
                good = False

            if edge not in tfFromAidEdges:
                print(&#34;\tmissing in annotation data&#34;)
                good = False

            if not good:
                continue

            dataTF = dict(Es(edge).items())
            dataAid = tfFromAidEdges[edge]

            fromNodesTF = set(dataTF)
            fromNodesAid = set(dataAid)

            nFromTF = len(fromNodesTF)
            nFromAid = len(fromNodesAid)

            if fromNodesTF == fromNodesAid:
                console(f&#34;\tsame {nFromTF} fromNodes&#34;)
            else:
                console(f&#34;\tfrom nodes differ: {nFromTF} in TF, {nFromAid} in Aid&#34;)
                good = False

            diffs = []

            nToChecked = 0

            for f, toNodeInfoTF in dataTF.items():
                toNodeInfoAid = dataAid[f]
                if type(toNodeInfoTF) is dict:
                    toNodeInfoTF = {k: str(v) for (k, v) in toNodeInfoTF.items()}
                else:
                    toNodeInfoTF = {x: None for x in toNodeInfoTF}

                if toNodeInfoTF != toNodeInfoAid:
                    diffs.append((f, toNodeInfoTF, toNodeInfoAid))

                nToChecked += len(toNodeInfoTF)

            if len(diffs):
                good = False
                console(
                    f&#34;\tdifferences in toNodes for {len(diffs)} fromNodes&#34;, error=True
                )

                for f, toNodeInfoTF, toNodeInfoAid in sorted(diffs)[0:10]:
                    console(f&#34;\t\tfromNode {f}&#34;, error=True)

                    toNodesTF = set(toNodeInfoTF)
                    toNodesAid = set(toNodeInfoAid)

                    nToTF = len(toNodesTF)
                    nToAid = len(toNodesAid)

                    if toNodesTF == toNodesAid:
                        console(f&#34;\t\t\tsame {nToTF} toNodes&#34;)
                    else:
                        console(
                            f&#34;\t\t\ttoNodes differ: {nToTF} in TF, {nToAid} in Aid&#34;,
                            error=True,
                        )
                    for t in toNodesTF | toNodesAid:
                        doCompare = True
                        if t not in toNodesTF:
                            console(f&#34;\t\t\t\ttoNode {t} not in TF&#34;, error=True)
                            doCompare = False
                        else:
                            valTF = toNodeInfoTF[t]

                        if t not in toNodesAid:
                            console(f&#34;\t\t\t\ttoNode {t} not in Aid&#34;, error=True)
                            doCompare = False
                        else:
                            valAid = toNodeInfoAid[t]

                        if doCompare:
                            if valTF == valAid:
                                console(
                                    f&#34;\t\t\t\ttoNode{t} values agree: {repr(valTF)}&#34;
                                )
                            else:
                                console(
                                    f&#34;\t\t\t\ttoNode{t} values differ: &#34;
                                    f&#34;TF: {repr(valTF)} Aid: {repr(valAid)}&#34;,
                                    error=True,
                                )

            console(f&#34;\t{nToChecked} toNodes checked&#34;)
            console(&#34;\tOK&#34; if good else &#34;\tWRONG&#34;, error=not good)

            if not good:
                allGood = False

        console(f&#34;{rep(allGood)} - {&#39;All&#39; if allGood else &#39;Not all&#39;} edges agree&#34;)

        return allGood

    def testAll(self):
        self.testSetup()

        good = True

        if not self.testText():
            good = False

        if not self.testElements():
            good = False

        if not self.testAttributes():
            good = False

        if not self.testEdges():
            good = False

        console(&#34;Overall outcome ...&#34;)
        allRep = &#34;All&#34; if good else &#34;Not all&#34;
        console(f&#34;{rep(good)} - {allRep} tests passed&#34;, error=not good)

        return good


class WATMS:
    def __init__(self, org, repo, backend, nsOrig, skipMeta=False, extra={}):
        self.org = org
        self.repo = repo
        self.backend = backend
        self.nsOrig = nsOrig
        self.skipMeta = skipMeta
        self.extra = extra

        repoDir = ex(f&#34;~/{backend}/{org}/{repo}&#34;)
        tfDir = f&#34;{repoDir}/tf&#34;
        docs = dirContents(tfDir)[1]
        console(f&#34;Found {len(docs)} docs in {tfDir}&#34;)
        self.docs = docs

    def produce(self, doc=None):
        org = self.org
        repo = self.repo
        backend = self.backend
        nsOrig = self.nsOrig
        skipMeta = self.skipMeta
        extra = self.extra
        docs = self.docs

        chosenDoc = doc

        for doc in sorted(docs, key=lambda x: (x[0], int(x[1:]))):
            if chosenDoc is not None and chosenDoc != doc:
                continue

            console(f&#34;{doc:&gt;5} ... &#34;, newline=False)
            A = use(
                f&#34;{org}/{repo}:clone&#34;,
                relative=f&#34;tf/{doc}&#34;,
                checkout=&#34;clone&#34;,
                backend=backend,
                silent=DEEP,
            )
            WA = WATM(A, nsOrig, skipMeta=skipMeta, extra=extra)
            WA.makeText()
            WA.makeAnno()
            WA.writeAll()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.convert.watm.rep"><code class="name flex">
<span>def <span class="ident">rep</span></span>(<span>status)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L56-L57" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rep(status):
    return &#34;OK&#34; if status else &#34;XX&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.convert.watm.WATM"><code class="flex name class">
<span>class <span class="ident">WATM</span></span>
<span>(</span><span>app, nsOrig, skipMeta=False, extra={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L60-L948" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class WATM:
    def __init__(self, app, nsOrig, skipMeta=False, extra={}):
        self.app = app
        self.nsOrig = nsOrig
        self.extra = extra
        api = app.api
        F = api.F
        E = api.E

        self.L = api.L
        self.Es = api.Es
        self.F = F
        self.E = E
        self.Fs = api.Fs
        self.slotType = self.F.otype.slotType
        self.otypes = self.F.otype.all
        self.info = app.info
        self.repoLocation = app.repoLocation

        Fall = api.Fall
        Eall = api.Eall
        self.Fall = Fall
        self.Eall = Eall

        excludedFeatures = {OTYPE, OSLOTS, &#34;after&#34;, &#34;str&#34;}
        self.nodeFeatures = [f for f in Fall() if f not in excludedFeatures]
        self.edgeFeatures = [f for f in Eall() if f not in excludedFeatures]

        FAllSet = set(Fall())

        self.fotypev = F.otype.v
        self.eoslots = E.oslots.s
        self.emptyv = F.empty.v if &#34;empty&#34; in FAllSet else None
        self.strv = F.str.v if &#34;str&#34; in FAllSet else None
        self.rstrv = F.rstr.v if &#34;rstr&#34; in FAllSet else None
        self.afterv = F.after.v if &#34;after&#34; in FAllSet else None
        self.rafterv = F.rafter.v if &#34;rafter&#34; in FAllSet else None
        is_metav = F.is_meta.v if &#34;is_meta&#34; in FAllSet else None
        self.is_metav = is_metav

        if skipMeta and not is_metav:
            console(
                &#34;skipMeta=True has no effect because feature is_meta is not defined.&#34;,
                error=True,
            )
            skipMeta = False

        self.skipMeta = skipMeta

    def makeText(self):
        F = self.F
        slotType = self.slotType
        skipMeta = self.skipMeta

        emptyv = self.emptyv
        strv = self.strv
        rstrv = self.rstrv
        afterv = self.afterv
        rafterv = self.rafterv
        is_metav = self.is_metav

        text = []
        tlFromTf = {}

        self.text = text
        self.tlFromTf = tlFromTf

        for s in F.otype.s(slotType):
            if skipMeta and is_metav(s):
                continue

            after = rafterv(s) if rafterv else None

            if after is None:
                after = afterv(s) if afterv else None

            if after is None:
                after = &#34;&#34;

            if emptyv and emptyv(s):
                value = after
            else:
                string = rstrv(s) if rstrv else None

                if string is None:
                    string = strv(s) if strv else None

                if string is None:
                    string = &#34;&#34;

                value = f&#34;{string}{after}&#34;

            text.append(value)
            t = len(text) - 1
            tlFromTf[s] = t

    def mkAnno(self, kind, ns, body, target):
        &#34;&#34;&#34;Make an annotation and return its id.

        Parameters
        ----------
        kind: string
            The kind of annotation.
        ns: string
            The namespace of the annotation.
        body: string
            The body of the annotation.
        target: string  or tuple of strings
            The target of the annotation.
        &#34;&#34;&#34;
        annos = self.annos
        aId = f&#34;a{len(annos):&gt;08}&#34;
        annos.append((kind, aId, ns, body, target))
        return aId

    def makeAnno(self):
        Es = self.Es
        F = self.F
        Fs = self.Fs
        fotypev = self.fotypev
        eoslots = self.eoslots
        nodeFeatures = self.nodeFeatures
        edgeFeatures = self.edgeFeatures
        slotType = self.slotType
        otypes = self.otypes
        nsOrig = self.nsOrig
        skipMeta = self.skipMeta

        tlFromTf = self.tlFromTf

        is_metav = self.is_metav

        isTei = nsOrig == NS_TEI

        annos = []
        text = self.text
        self.annos = annos

        wrongTargets = []

        for otype in otypes:
            isSlot = otype == slotType

            for n in F.otype.s(otype):
                if isSlot:
                    if skipMeta and is_metav(n):
                        continue

                    t = tlFromTf[n]
                    target = f&#34;{t}-{t + 1}&#34;
                    self.mkAnno(KIND_NODE, NS_TF, n, target)
                else:
                    ws = eoslots(n)
                    if skipMeta and (is_metav(ws[0]) or is_metav(ws[-1])):
                        continue

                    start = tlFromTf[ws[0]]
                    end = tlFromTf[ws[-1]]
                    if end &lt; start:
                        wrongTargets.append((otype, start, end))

                    target = f&#34;{start}-{end + 1}&#34;
                    aId = (
                        self.mkAnno(KIND_PI, nsOrig, otype[1:], target)
                        if otype.startswith(&#34;?&#34;)
                        else self.mkAnno(
                            KIND_ELEM, NS_FROM_OTYPE.get(otype, nsOrig), otype, target
                        )
                    )
                    tlFromTf[n] = aId
                    self.mkAnno(KIND_NODE, NS_TF, n, aId)

        for feat in nodeFeatures:
            ns = Fs(feat).meta.get(&#34;conversionCode&#34;, NS_FROM_FEAT.get(feat, nsOrig))

            if ns is None:
                console(
                    f&#34;Node feature {feat} has no namespace, &#34;
                    f&#34;defaulting to {NS_NONE}&#34;,
                    error=True,
                )
                ns = NS_NONE

            isRend = False
            isNote = False

            if isTei:
                parts = feat.split(&#34;_&#34;, 2)
                isRend = len(parts) &gt;= 2 and parts[0] == &#34;rend&#34;
                isNote = len(parts) == 2 and parts[0] == &#34;is&#34; and parts[1] == &#34;note&#34;

            if isRend:
                for n, val in Fs(feat).items():
                    if not val or (skipMeta and is_metav(n)):
                        continue

                    prop = parts[1]
                    t = tlFromTf[n]
                    target = f&#34;{t}-{t + 1}&#34; if fotypev(n) == slotType else t
                    self.mkAnno(KIND_FMT, ns, prop, target)
            elif isNote:
                for n, val in Fs(feat).items():
                    if not val or (skipMeta and is_metav(n)):
                        continue

                    t = tlFromTf[n]
                    target = f&#34;{t}-{t + 1}&#34; if fotypev(n) == slotType else t
                    self.mkAnno(KIND_FMT, ns, &#34;note&#34;, target)
            else:
                for n, val in Fs(feat).items():
                    if skipMeta and is_metav(n):
                        continue

                    t = tlFromTf.get(n, None)

                    if t is None:
                        continue

                    target = f&#34;{t}-{t + 1}&#34; if fotypev(n) == slotType else t
                    aId = self.mkAnno(KIND_ATTR, ns, f&#34;{feat}={val}&#34;, target)

        for feat in edgeFeatures:
            ns = Es(feat).meta.get(&#34;conversionCode&#34;, NS_FROM_FEAT.get(feat, nsOrig))

            if ns is None:
                console(
                    f&#34;Edge feature {feat} has no conversion code, &#34;
                    f&#34;defaulting to {NS_NONE}&#34;,
                    error=True,
                )
                ns = NS_NONE

            for fromNode, toNodes in Es(feat).items():
                if skipMeta and is_metav(fromNode):
                    continue

                fromT = tlFromTf.get(fromNode, None)

                if fromT is None:
                    continue

                targetFrom = (
                    f&#34;{fromT}-{fromT + 1}&#34; if fotypev(fromNode) == slotType else fromT
                )

                if type(toNodes) is dict:
                    for toNode, val in toNodes.items():
                        if skipMeta and is_metav(toNode):
                            continue

                        toT = tlFromTf.get(toNode, None)

                        if toT is None:
                            continue

                        targetTo = (
                            f&#34;{toT}-{toT + 1}&#34; if fotypev(toNode) == slotType else toT
                        )
                        target = f&#34;{targetFrom}-&gt;{targetTo}&#34;
                        aId = self.mkAnno(KIND_EDGE, ns, f&#34;{feat}={val}&#34;, target)
                else:
                    for toNode in toNodes:
                        if skipMeta and is_metav(toNode):
                            continue

                        toT = tlFromTf.get(toNode, None)

                        if toT is None:
                            continue

                        target = f&#34;{fromT}-&gt;{toT}&#34;
                        aId = self.mkAnno(KIND_EDGE, ns, feat, target)

        extra = {}
        extra.update(self.extra)

        for n, value in extra.items():
            t = tlFromTf[n]
            target = f&#34;{t}-{t + 1}&#34; if fotypev(n) == slotType else t
            aId = self.mkAnno(KIND_ANNO, NS_TT, str(value), target)

        if len(wrongTargets):
            print(f&#34;WARNING: wrong targets, {len(wrongTargets)}x&#34;)
            for otype, start, end in wrongTargets:
                sega = text[start]
                segb = text[end - 1]
                print(f&#34;{otype:&gt;20} {start:&gt;6} `{sega}` &gt; {end - 1} `{segb}`&#34;)

    def writeAll(self):
        app = self.app
        text = self.text
        annos = self.annos

        baseDir = self.repoLocation
        relative = app.context.relative
        version = app.version
        wRelative = REL_RE.sub(f&#34;/{TT_NAME}/{version}/&#34;, relative, count=1)
        resultDir = f&#34;{baseDir}{wRelative}&#34;
        textFile = f&#34;{resultDir}/text.json&#34;

        self.textFile = textFile

        initTree(resultDir, fresh=True)

        with open(textFile, &#34;w&#34;) as fh:
            json.dump(dict(_ordered_segments=text), fh, ensure_ascii=False, indent=1)

        console(f&#34;Text file: {len(text):&gt;7} segments to {textFile}&#34;)

        annoStore = {}

        for kind, aId, ns, body, target in annos:
            annoStore[aId] = (kind, ns, body, target)

        aIdSorted = sorted(annoStore.keys())

        annoFile = f&#34;{resultDir}/anno.tsv&#34;

        if False:
            with open(annoFile, &#34;w&#34;) as fh:
                for aId in aIdSorted:
                    (kind, ns, body, target) = annoStore[aId]
                    fh.write(f&#34;{aId}\t{kind}\t{ns}\t{body}\t{target}\n&#34;)

        thisAnnoStore = {}
        thisA = 1
        annoFiles = []
        self.annoFiles = annoFiles

        LIMIT = 400000
        j = 0
        total = 0

        def writeThis():
            annoFile = f&#34;{resultDir}/anno-{thisA:&gt;01}.json&#34;
            annoFiles.append(annoFile)

            with open(annoFile, &#34;w&#34;) as fh:
                json.dump(thisAnnoStore, fh, ensure_ascii=False, indent=1)

            console(f&#34;{j:&gt;6} annotations written to {annoFile}&#34;)

        for aId in aIdSorted:
            if j &gt;= LIMIT:
                writeThis()
                thisA += 1
                thisAnnoStore = {}
                total += j
                j = 0

            thisAnnoStore[aId] = annoStore[aId]
            j += 1

        if len(thisAnnoStore):
            writeThis()
            total += j

        if len(annos) != total:
            console(f&#34;Sum of batches : {total:&gt;8}&#34;)
            console(f&#34;All annotations: {len(annoStore):&gt;8}&#34;)
            console(&#34;Mismatch in number of annotations&#34;, error=True)
        console(f&#34;Anno files: {len(annos):&gt;7} annotations to {len(annoFiles)} files&#34;)

    @staticmethod
    def compare(nTF, nWA):
        console(f&#34;\tTF: {nTF:&gt;6}\n\tWA: {nWA:&gt;6}&#34;, error=nTF != nWA)
        return nTF == nWA

    @staticmethod
    def strEqual(wa=None, tf=None):
        different = False
        for i, cTF in enumerate(tf):
            if i &gt;= len(wa):
                contextI = max((0, i - 10))
                console(f&#34;\tWA {i}: {wa[contextI:i]} &lt;END&gt;&#34;, error=True)
                console(f&#34;\tTF {i}: {tf[contextI:i]} &lt;&gt; {tf[i:i + 10]}&#34;, error=True)
                different = True
                break
            elif tf[i] != wa[i]:
                contextI = max((0, i - 10))
                console(
                    f&#34;\tWA {i}: {wa[contextI:i]} &lt;{wa[i]}&gt; {wa[i + 1:i + 11]}&#34;,
                    error=True,
                )
                console(
                    f&#34;\tTF {i}: {tf[contextI:i]} &lt;{tf[i]}&gt; {tf[i + 1:i + 11]}&#34;,
                    error=True,
                )
                different = True
                break

        if not different and len(wa) &gt; len(tf):
            i = len(tf)
            contextI = max((0, i - 10))
            console(f&#34;\tWA {i}: {wa[contextI:i]} &lt;&gt; {wa[i:i + 10]}&#34;, error=True)
            console(f&#34;\tTF {i}: {tf[contextI:i]} &lt;END&gt;&#34;, error=True)
            different = True

        sampleWA = f&#34;{wa[0:20]} ... {wa[-20:]}&#34;.replace(&#34;\n&#34;, &#34; &#34;)
        sampleTF = f&#34;{tf[0:20]} ... {tf[-20:]}&#34;.replace(&#34;\n&#34;, &#34; &#34;)
        console(f&#34;\tTF: {sampleTF:&gt;6}\n\tWA: {sampleWA:&gt;6}&#34;)
        return not different

    def testSetup(self):
        textFile = self.textFile
        annoFiles = self.annoFiles

        with open(textFile) as fh:
            text = json.load(fh)
            tokens = text[&#34;_ordered_segments&#34;]

        self.testTokens = tokens

        annotationById = {}
        annotations = []

        for annoFile in annoFiles:
            with open(annoFile) as fh:
                annos = json.load(fh)

                for aId, (kind, ns, body, target) in annos.items():
                    if &#34;-&gt;&#34; in target:
                        parts = target.split(&#34;-&gt;&#34;, 1)
                    else:
                        parts = [target]
                    newParts = []
                    for part in parts:
                        if &#34;-&#34; in part:
                            (start, end) = part.split(&#34;-&#34;, 1)
                            part = (int(start), int(end))
                        newParts.append(part)

                    target = newParts[0] if len(newParts) == 1 else tuple(newParts)

                    annotationById[aId] = (kind, body, target)
                    annotations.append((aId, kind, body, target))

        annotations = sorted(annotations)
        self.testAnnotations = annotations

    def testText(self):
        F = self.F
        skipMeta = self.skipMeta
        is_metav = self.is_metav
        tokens = self.testTokens
        text = self.text

        console(&#34;Testing the text ...&#34;)

        nTokensTF = sum(
            0 if skipMeta and is_metav(s) else 1 for s in range(1, F.otype.maxSlot + 1)
        )
        nTokensWA = len(tokens)
        nGood = self.compare(nTokensTF, nTokensWA)
        console(f&#34;{rep(nGood)} - Same number of tokens&#34;, error=not nGood)

        textWA = &#34;&#34;.join(tokens)
        textTF = &#34;&#34;.join(text)

        tGood = self.strEqual(wa=textWA, tf=textTF)
        console(f&#34;{rep(tGood)} - Same text&#34;, error=not tGood)

        return nGood and tGood

    def testElements(self):
        F = self.F
        fotypev = self.fotypev
        eoslots = self.eoslots
        skipMeta = self.skipMeta
        is_metav = self.is_metav
        annotations = self.testAnnotations

        console(&#34;Testing the elements ...&#34;)

        nElementsTF = 0
        nPisTF = 0

        for n in range(F.otype.maxSlot + 1, F.otype.maxNode + 1):
            nType = fotypev(n)
            isPi = nType.startswith(&#34;?&#34;)

            if isPi:
                nPisTF += 1

            slots = eoslots(n)
            b = slots[0]
            e = slots[-1]

            if skipMeta and (is_metav(b) or is_metav(e)):
                continue
            else:
                if not isPi:
                    nElementsTF += 1

        nElementsWA = sum(
            1 if kind == &#34;element&#34; else 0 for (aId, kind, body, target) in annotations
        )
        nPisWA = sum(
            1 if kind == &#34;pi&#34; else 0 for (aId, kind, body, target) in annotations
        )

        eGood = self.compare(nElementsTF, nElementsWA)
        console(f&#34;{rep(eGood)} - Same number of elements as nodes&#34;, error=not eGood)

        pGood = self.compare(nPisTF, nPisWA)
        console(
            f&#34;{rep(pGood)} - Same number of processing instructions&#34;, error=not pGood
        )

        # element annotations

        tfFromAid = {}

        element = 0
        pi = 0
        other = 0
        good = 0
        wrong = 0
        unmapped = 0

        for aId, kind, body, target in annotations:
            if kind == &#34;node&#34;:
                tfFromAid[target] = body

        self.tfFromAid = tfFromAid

        console(f&#34;\t{len(tfFromAid)} element annotations&#34;)

        for aId, kind, body, target in annotations:
            isElem = kind == &#34;element&#34;
            isPi = kind == &#34;pi&#34;

            if not isElem and not isPi:
                other += 1
                continue

            if isElem:
                element += 1
            else:
                pi += 1

            tag = body
            node = tfFromAid.get(aId, None)
            if node is None:
                unmapped += 1
                continue

            otype = fotypev(node)

            if isPi and tag == otype[1:] or not isPi and tag == otype:
                good += 1
            else:
                wrong += 1

        console(f&#34;\tElement : {element:&gt;5} x&#34;)
        console(f&#34;\tPi      : {pi:&gt;5} x&#34;)
        console(f&#34;\tOther   : {other:&gt;5} x&#34;)
        console(f&#34;\tGood    : {good:&gt;5} x&#34;)
        console(f&#34;\tWrong   : {wrong:&gt;5} x&#34;)
        console(f&#34;\tUnmapped: {unmapped:&gt;5} x&#34;)

        aGood = wrong == 0 and unmapped == 0
        console(f&#34;{rep(aGood)} - All element annotations OK&#34;, error=not aGood)

        return aGood and eGood and pGood

    def testAttributes(self):
        Fs = self.Fs
        Fall = self.Fall
        eoslots = self.eoslots
        skipMeta = self.skipMeta
        is_metav = self.is_metav
        annotations = self.testAnnotations
        tfFromAid = self.tfFromAid
        nsOrig = self.nsOrig

        isTei = nsOrig == NS_TEI

        console(&#34;Testing the attributes ...&#34;)

        attWA = []

        for aId, kind, body, target in annotations:
            if kind != &#34;attribute&#34;:
                continue
            node = tfFromAid[target]
            (att, value) = body.split(&#34;=&#34;, 1)
            attWA.append((node, att, value))

        attWA = sorted(attWA)

        console(f&#34;\t{len(attWA)} attribute values&#34;)

        good = 0
        wrong = []

        for node, att, valWA in attWA:
            valTF = str(Fs(att).v(node))
            if valWA == valTF:
                good += 1
            else:
                wrong.append((node, att, valWA, valTF))

        console(f&#34;\tGood:     {good:&gt;5} x&#34;)
        console(f&#34;\tWrong:    {len(wrong):&gt;5} x&#34;)
        consistent = len(wrong) == 0
        console(
            f&#34;{rep(consistent)} - annotations consistent with features&#34;,
            error=not consistent,
        )

        attTF = []

        for feat in Fall():
            if feat in {&#34;otype&#34;, &#34;str&#34;, &#34;after&#34;}:
                continue

            if skipMeta and feat == &#34;is_meta&#34;:
                continue

            if isTei and (
                (feat != &#34;is_meta&#34; and feat.startswith(&#34;is_&#34;))
                or feat.startswith(&#34;rend_&#34;)
            ):
                continue

            for node, valTF in Fs(feat).items():
                slots = eoslots(node)
                b = slots[0]
                e = slots[-1]

                if skipMeta and (is_metav(b) or is_metav(e)):
                    continue

                attTF.append((node, feat, str(valTF)))

        attTF = sorted(attTF)

        console(f&#34;\tWA attributes: {len(attWA)}&#34;)
        console(f&#34;\tTF attributes: {len(attTF)}&#34;)
        complete = attTF == attWA
        console(
            f&#34;{rep(complete)} - annotations complete w.r.t. features&#34;,
            error=not complete,
        )

        console(&#34;Testing the format attributes ...&#34;)

        fmtWA = []

        for aId, kind, body, target in annotations:
            if kind != &#34;format&#34;:
                continue
            if body == &#34;note&#34;:
                continue
            node = tfFromAid[target]
            fmtWA.append((node, body))

        fmtWA = sorted(fmtWA)
        fmtWaFreq = collections.Counter()

        for node, body in fmtWA:
            fmtWaFreq[body] += 1

        console(f&#34;\t{len(fmtWA)} format values&#34;)
        console(&#34;\tformatting attributes: &#34;)
        for fa, n in sorted(fmtWaFreq.items(), key=lambda x: (-x[1], x[0])):
            console(f&#34;\t\t{n:&gt;6} x {fa}&#34;)

        good = 0
        wrong = []

        for node, valWA in fmtWA:
            feat = f&#34;rend_{valWA}&#34;
            valTF = valWA if str(Fs(feat).v(node)) else None
            if valWA == valTF:
                good += 1
            else:
                wrong.append((node, feat, valWA, valTF))

        console(f&#34;\tGood:     {good:&gt;5} x&#34;)
        console(f&#34;\tWrong:    {len(wrong):&gt;5} x&#34;)
        fconsistent = len(wrong) == 0
        console(
            f&#34;{rep(fconsistent)} - format annotations consistent with features&#34;,
            error=not fconsistent,
        )

        fmtTF = []

        for feat in Fall():
            if not feat.startswith(&#34;rend_&#34;):
                continue

            value = feat.split(&#34;_&#34;, 2)[1]
            if value == &#34;note&#34;:
                continue

            for node, valTF in Fs(feat).items():
                slots = eoslots(node)
                b = slots[0]
                e = slots[-1]

                if skipMeta and (is_metav(b) or is_metav(e)):
                    continue

                fmtTF.append((node, value))

        fmtTF = sorted(fmtTF)

        console(f&#34;\tWA format attributes: {len(fmtWA)}&#34;)
        console(f&#34;\tTF format attributes: {len(fmtTF)}&#34;)
        fcomplete = fmtTF == fmtWA
        console(
            f&#34;{rep(complete)} - format annotations complete w.r.t. features&#34;,
            error=not fcomplete,
        )

        return consistent and complete and fconsistent and fcomplete

    def testEdges(self):
        Es = self.Es
        Eall = self.Eall
        annotations = self.testAnnotations

        console(&#34;Testing the edges ...&#34;)

        tfFromAidNodes = {}
        tfFromAidEdges = {}

        for aId, kind, body, target in annotations:
            if kind != &#34;node&#34;:
                continue
            if type(target) is tuple:
                (start, end) = target
                if start + 1 != end:
                    print(target)
                    break
                target = end
            tfFromAidNodes[target] = body

        for aId, kind, body, target in annotations:
            if kind != &#34;edge&#34;:
                continue

            (fro, to) = target
            fromNode = tfFromAidNodes[fro]
            toNode = tfFromAidNodes[to]
            parts = body.split(&#34;=&#34;, 1)
            (name, val) = (body, None) if len(parts) == 1 else parts
            tfFromAidEdges.setdefault(name, {}).setdefault(fromNode, {})[toNode] = val

        console(f&#34;\tFound: {len(tfFromAidNodes)} nodes&#34;)

        for edge, edgeData in sorted(tfFromAidEdges.items()):
            print(f&#34;\tFound edge {edge} with {len(edgeData)} starting nodes&#34;)

        allGood = True

        for edge in set(Eall()) | set(tfFromAidEdges):
            if edge == &#34;oslots&#34;:
                continue

            print(f&#34;Checking edge {edge}&#34;)

            good = True

            if edge not in set(Eall()):
                print(&#34;\tmissing in TF data&#34;)
                good = False

            if edge not in tfFromAidEdges:
                print(&#34;\tmissing in annotation data&#34;)
                good = False

            if not good:
                continue

            dataTF = dict(Es(edge).items())
            dataAid = tfFromAidEdges[edge]

            fromNodesTF = set(dataTF)
            fromNodesAid = set(dataAid)

            nFromTF = len(fromNodesTF)
            nFromAid = len(fromNodesAid)

            if fromNodesTF == fromNodesAid:
                console(f&#34;\tsame {nFromTF} fromNodes&#34;)
            else:
                console(f&#34;\tfrom nodes differ: {nFromTF} in TF, {nFromAid} in Aid&#34;)
                good = False

            diffs = []

            nToChecked = 0

            for f, toNodeInfoTF in dataTF.items():
                toNodeInfoAid = dataAid[f]
                if type(toNodeInfoTF) is dict:
                    toNodeInfoTF = {k: str(v) for (k, v) in toNodeInfoTF.items()}
                else:
                    toNodeInfoTF = {x: None for x in toNodeInfoTF}

                if toNodeInfoTF != toNodeInfoAid:
                    diffs.append((f, toNodeInfoTF, toNodeInfoAid))

                nToChecked += len(toNodeInfoTF)

            if len(diffs):
                good = False
                console(
                    f&#34;\tdifferences in toNodes for {len(diffs)} fromNodes&#34;, error=True
                )

                for f, toNodeInfoTF, toNodeInfoAid in sorted(diffs)[0:10]:
                    console(f&#34;\t\tfromNode {f}&#34;, error=True)

                    toNodesTF = set(toNodeInfoTF)
                    toNodesAid = set(toNodeInfoAid)

                    nToTF = len(toNodesTF)
                    nToAid = len(toNodesAid)

                    if toNodesTF == toNodesAid:
                        console(f&#34;\t\t\tsame {nToTF} toNodes&#34;)
                    else:
                        console(
                            f&#34;\t\t\ttoNodes differ: {nToTF} in TF, {nToAid} in Aid&#34;,
                            error=True,
                        )
                    for t in toNodesTF | toNodesAid:
                        doCompare = True
                        if t not in toNodesTF:
                            console(f&#34;\t\t\t\ttoNode {t} not in TF&#34;, error=True)
                            doCompare = False
                        else:
                            valTF = toNodeInfoTF[t]

                        if t not in toNodesAid:
                            console(f&#34;\t\t\t\ttoNode {t} not in Aid&#34;, error=True)
                            doCompare = False
                        else:
                            valAid = toNodeInfoAid[t]

                        if doCompare:
                            if valTF == valAid:
                                console(
                                    f&#34;\t\t\t\ttoNode{t} values agree: {repr(valTF)}&#34;
                                )
                            else:
                                console(
                                    f&#34;\t\t\t\ttoNode{t} values differ: &#34;
                                    f&#34;TF: {repr(valTF)} Aid: {repr(valAid)}&#34;,
                                    error=True,
                                )

            console(f&#34;\t{nToChecked} toNodes checked&#34;)
            console(&#34;\tOK&#34; if good else &#34;\tWRONG&#34;, error=not good)

            if not good:
                allGood = False

        console(f&#34;{rep(allGood)} - {&#39;All&#39; if allGood else &#39;Not all&#39;} edges agree&#34;)

        return allGood

    def testAll(self):
        self.testSetup()

        good = True

        if not self.testText():
            good = False

        if not self.testElements():
            good = False

        if not self.testAttributes():
            good = False

        if not self.testEdges():
            good = False

        console(&#34;Overall outcome ...&#34;)
        allRep = &#34;All&#34; if good else &#34;Not all&#34;
        console(f&#34;{rep(good)} - {allRep} tests passed&#34;, error=not good)

        return good</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="tf.convert.watm.WATM.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>nTF, nWA)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L423-L426" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def compare(nTF, nWA):
    console(f&#34;\tTF: {nTF:&gt;6}\n\tWA: {nWA:&gt;6}&#34;, error=nTF != nWA)
    return nTF == nWA</code></pre>
</details>
</dd>
<dt id="tf.convert.watm.WATM.strEqual"><code class="name flex">
<span>def <span class="ident">strEqual</span></span>(<span>wa=None, tf=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L428-L461" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def strEqual(wa=None, tf=None):
    different = False
    for i, cTF in enumerate(tf):
        if i &gt;= len(wa):
            contextI = max((0, i - 10))
            console(f&#34;\tWA {i}: {wa[contextI:i]} &lt;END&gt;&#34;, error=True)
            console(f&#34;\tTF {i}: {tf[contextI:i]} &lt;&gt; {tf[i:i + 10]}&#34;, error=True)
            different = True
            break
        elif tf[i] != wa[i]:
            contextI = max((0, i - 10))
            console(
                f&#34;\tWA {i}: {wa[contextI:i]} &lt;{wa[i]}&gt; {wa[i + 1:i + 11]}&#34;,
                error=True,
            )
            console(
                f&#34;\tTF {i}: {tf[contextI:i]} &lt;{tf[i]}&gt; {tf[i + 1:i + 11]}&#34;,
                error=True,
            )
            different = True
            break

    if not different and len(wa) &gt; len(tf):
        i = len(tf)
        contextI = max((0, i - 10))
        console(f&#34;\tWA {i}: {wa[contextI:i]} &lt;&gt; {wa[i:i + 10]}&#34;, error=True)
        console(f&#34;\tTF {i}: {tf[contextI:i]} &lt;END&gt;&#34;, error=True)
        different = True

    sampleWA = f&#34;{wa[0:20]} ... {wa[-20:]}&#34;.replace(&#34;\n&#34;, &#34; &#34;)
    sampleTF = f&#34;{tf[0:20]} ... {tf[-20:]}&#34;.replace(&#34;\n&#34;, &#34; &#34;)
    console(f&#34;\tTF: {sampleTF:&gt;6}\n\tWA: {sampleWA:&gt;6}&#34;)
    return not different</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tf.convert.watm.WATM.makeAnno"><code class="name flex">
<span>def <span class="ident">makeAnno</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L175-L346" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeAnno(self):
    Es = self.Es
    F = self.F
    Fs = self.Fs
    fotypev = self.fotypev
    eoslots = self.eoslots
    nodeFeatures = self.nodeFeatures
    edgeFeatures = self.edgeFeatures
    slotType = self.slotType
    otypes = self.otypes
    nsOrig = self.nsOrig
    skipMeta = self.skipMeta

    tlFromTf = self.tlFromTf

    is_metav = self.is_metav

    isTei = nsOrig == NS_TEI

    annos = []
    text = self.text
    self.annos = annos

    wrongTargets = []

    for otype in otypes:
        isSlot = otype == slotType

        for n in F.otype.s(otype):
            if isSlot:
                if skipMeta and is_metav(n):
                    continue

                t = tlFromTf[n]
                target = f&#34;{t}-{t + 1}&#34;
                self.mkAnno(KIND_NODE, NS_TF, n, target)
            else:
                ws = eoslots(n)
                if skipMeta and (is_metav(ws[0]) or is_metav(ws[-1])):
                    continue

                start = tlFromTf[ws[0]]
                end = tlFromTf[ws[-1]]
                if end &lt; start:
                    wrongTargets.append((otype, start, end))

                target = f&#34;{start}-{end + 1}&#34;
                aId = (
                    self.mkAnno(KIND_PI, nsOrig, otype[1:], target)
                    if otype.startswith(&#34;?&#34;)
                    else self.mkAnno(
                        KIND_ELEM, NS_FROM_OTYPE.get(otype, nsOrig), otype, target
                    )
                )
                tlFromTf[n] = aId
                self.mkAnno(KIND_NODE, NS_TF, n, aId)

    for feat in nodeFeatures:
        ns = Fs(feat).meta.get(&#34;conversionCode&#34;, NS_FROM_FEAT.get(feat, nsOrig))

        if ns is None:
            console(
                f&#34;Node feature {feat} has no namespace, &#34;
                f&#34;defaulting to {NS_NONE}&#34;,
                error=True,
            )
            ns = NS_NONE

        isRend = False
        isNote = False

        if isTei:
            parts = feat.split(&#34;_&#34;, 2)
            isRend = len(parts) &gt;= 2 and parts[0] == &#34;rend&#34;
            isNote = len(parts) == 2 and parts[0] == &#34;is&#34; and parts[1] == &#34;note&#34;

        if isRend:
            for n, val in Fs(feat).items():
                if not val or (skipMeta and is_metav(n)):
                    continue

                prop = parts[1]
                t = tlFromTf[n]
                target = f&#34;{t}-{t + 1}&#34; if fotypev(n) == slotType else t
                self.mkAnno(KIND_FMT, ns, prop, target)
        elif isNote:
            for n, val in Fs(feat).items():
                if not val or (skipMeta and is_metav(n)):
                    continue

                t = tlFromTf[n]
                target = f&#34;{t}-{t + 1}&#34; if fotypev(n) == slotType else t
                self.mkAnno(KIND_FMT, ns, &#34;note&#34;, target)
        else:
            for n, val in Fs(feat).items():
                if skipMeta and is_metav(n):
                    continue

                t = tlFromTf.get(n, None)

                if t is None:
                    continue

                target = f&#34;{t}-{t + 1}&#34; if fotypev(n) == slotType else t
                aId = self.mkAnno(KIND_ATTR, ns, f&#34;{feat}={val}&#34;, target)

    for feat in edgeFeatures:
        ns = Es(feat).meta.get(&#34;conversionCode&#34;, NS_FROM_FEAT.get(feat, nsOrig))

        if ns is None:
            console(
                f&#34;Edge feature {feat} has no conversion code, &#34;
                f&#34;defaulting to {NS_NONE}&#34;,
                error=True,
            )
            ns = NS_NONE

        for fromNode, toNodes in Es(feat).items():
            if skipMeta and is_metav(fromNode):
                continue

            fromT = tlFromTf.get(fromNode, None)

            if fromT is None:
                continue

            targetFrom = (
                f&#34;{fromT}-{fromT + 1}&#34; if fotypev(fromNode) == slotType else fromT
            )

            if type(toNodes) is dict:
                for toNode, val in toNodes.items():
                    if skipMeta and is_metav(toNode):
                        continue

                    toT = tlFromTf.get(toNode, None)

                    if toT is None:
                        continue

                    targetTo = (
                        f&#34;{toT}-{toT + 1}&#34; if fotypev(toNode) == slotType else toT
                    )
                    target = f&#34;{targetFrom}-&gt;{targetTo}&#34;
                    aId = self.mkAnno(KIND_EDGE, ns, f&#34;{feat}={val}&#34;, target)
            else:
                for toNode in toNodes:
                    if skipMeta and is_metav(toNode):
                        continue

                    toT = tlFromTf.get(toNode, None)

                    if toT is None:
                        continue

                    target = f&#34;{fromT}-&gt;{toT}&#34;
                    aId = self.mkAnno(KIND_EDGE, ns, feat, target)

    extra = {}
    extra.update(self.extra)

    for n, value in extra.items():
        t = tlFromTf[n]
        target = f&#34;{t}-{t + 1}&#34; if fotypev(n) == slotType else t
        aId = self.mkAnno(KIND_ANNO, NS_TT, str(value), target)

    if len(wrongTargets):
        print(f&#34;WARNING: wrong targets, {len(wrongTargets)}x&#34;)
        for otype, start, end in wrongTargets:
            sega = text[start]
            segb = text[end - 1]
            print(f&#34;{otype:&gt;20} {start:&gt;6} `{sega}` &gt; {end - 1} `{segb}`&#34;)</code></pre>
</details>
</dd>
<dt id="tf.convert.watm.WATM.makeText"><code class="name flex">
<span>def <span class="ident">makeText</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L109-L154" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeText(self):
    F = self.F
    slotType = self.slotType
    skipMeta = self.skipMeta

    emptyv = self.emptyv
    strv = self.strv
    rstrv = self.rstrv
    afterv = self.afterv
    rafterv = self.rafterv
    is_metav = self.is_metav

    text = []
    tlFromTf = {}

    self.text = text
    self.tlFromTf = tlFromTf

    for s in F.otype.s(slotType):
        if skipMeta and is_metav(s):
            continue

        after = rafterv(s) if rafterv else None

        if after is None:
            after = afterv(s) if afterv else None

        if after is None:
            after = &#34;&#34;

        if emptyv and emptyv(s):
            value = after
        else:
            string = rstrv(s) if rstrv else None

            if string is None:
                string = strv(s) if strv else None

            if string is None:
                string = &#34;&#34;

            value = f&#34;{string}{after}&#34;

        text.append(value)
        t = len(text) - 1
        tlFromTf[s] = t</code></pre>
</details>
</dd>
<dt id="tf.convert.watm.WATM.mkAnno"><code class="name flex">
<span>def <span class="ident">mkAnno</span></span>(<span>self, kind, ns, body, target)</span>
</code></dt>
<dd>
<div class="desc"><p>Make an annotation and return its id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code></dt>
<dd>The kind of annotation.</dd>
<dt><strong><code>ns</code></strong> :&ensp;<code>string</code></dt>
<dd>The namespace of the annotation.</dd>
<dt><strong><code>body</code></strong> :&ensp;<code>string</code></dt>
<dd>The body of the annotation.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>string</code>
or <code>tuple</code> of <code>strings</code></dt>
<dd>The target of the annotation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L156-L173" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mkAnno(self, kind, ns, body, target):
    &#34;&#34;&#34;Make an annotation and return its id.

    Parameters
    ----------
    kind: string
        The kind of annotation.
    ns: string
        The namespace of the annotation.
    body: string
        The body of the annotation.
    target: string  or tuple of strings
        The target of the annotation.
    &#34;&#34;&#34;
    annos = self.annos
    aId = f&#34;a{len(annos):&gt;08}&#34;
    annos.append((kind, aId, ns, body, target))
    return aId</code></pre>
</details>
</dd>
<dt id="tf.convert.watm.WATM.testAll"><code class="name flex">
<span>def <span class="ident">testAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L927-L948" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def testAll(self):
    self.testSetup()

    good = True

    if not self.testText():
        good = False

    if not self.testElements():
        good = False

    if not self.testAttributes():
        good = False

    if not self.testEdges():
        good = False

    console(&#34;Overall outcome ...&#34;)
    allRep = &#34;All&#34; if good else &#34;Not all&#34;
    console(f&#34;{rep(good)} - {allRep} tests passed&#34;, error=not good)

    return good</code></pre>
</details>
</dd>
<dt id="tf.convert.watm.WATM.testAttributes"><code class="name flex">
<span>def <span class="ident">testAttributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L626-L778" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def testAttributes(self):
    Fs = self.Fs
    Fall = self.Fall
    eoslots = self.eoslots
    skipMeta = self.skipMeta
    is_metav = self.is_metav
    annotations = self.testAnnotations
    tfFromAid = self.tfFromAid
    nsOrig = self.nsOrig

    isTei = nsOrig == NS_TEI

    console(&#34;Testing the attributes ...&#34;)

    attWA = []

    for aId, kind, body, target in annotations:
        if kind != &#34;attribute&#34;:
            continue
        node = tfFromAid[target]
        (att, value) = body.split(&#34;=&#34;, 1)
        attWA.append((node, att, value))

    attWA = sorted(attWA)

    console(f&#34;\t{len(attWA)} attribute values&#34;)

    good = 0
    wrong = []

    for node, att, valWA in attWA:
        valTF = str(Fs(att).v(node))
        if valWA == valTF:
            good += 1
        else:
            wrong.append((node, att, valWA, valTF))

    console(f&#34;\tGood:     {good:&gt;5} x&#34;)
    console(f&#34;\tWrong:    {len(wrong):&gt;5} x&#34;)
    consistent = len(wrong) == 0
    console(
        f&#34;{rep(consistent)} - annotations consistent with features&#34;,
        error=not consistent,
    )

    attTF = []

    for feat in Fall():
        if feat in {&#34;otype&#34;, &#34;str&#34;, &#34;after&#34;}:
            continue

        if skipMeta and feat == &#34;is_meta&#34;:
            continue

        if isTei and (
            (feat != &#34;is_meta&#34; and feat.startswith(&#34;is_&#34;))
            or feat.startswith(&#34;rend_&#34;)
        ):
            continue

        for node, valTF in Fs(feat).items():
            slots = eoslots(node)
            b = slots[0]
            e = slots[-1]

            if skipMeta and (is_metav(b) or is_metav(e)):
                continue

            attTF.append((node, feat, str(valTF)))

    attTF = sorted(attTF)

    console(f&#34;\tWA attributes: {len(attWA)}&#34;)
    console(f&#34;\tTF attributes: {len(attTF)}&#34;)
    complete = attTF == attWA
    console(
        f&#34;{rep(complete)} - annotations complete w.r.t. features&#34;,
        error=not complete,
    )

    console(&#34;Testing the format attributes ...&#34;)

    fmtWA = []

    for aId, kind, body, target in annotations:
        if kind != &#34;format&#34;:
            continue
        if body == &#34;note&#34;:
            continue
        node = tfFromAid[target]
        fmtWA.append((node, body))

    fmtWA = sorted(fmtWA)
    fmtWaFreq = collections.Counter()

    for node, body in fmtWA:
        fmtWaFreq[body] += 1

    console(f&#34;\t{len(fmtWA)} format values&#34;)
    console(&#34;\tformatting attributes: &#34;)
    for fa, n in sorted(fmtWaFreq.items(), key=lambda x: (-x[1], x[0])):
        console(f&#34;\t\t{n:&gt;6} x {fa}&#34;)

    good = 0
    wrong = []

    for node, valWA in fmtWA:
        feat = f&#34;rend_{valWA}&#34;
        valTF = valWA if str(Fs(feat).v(node)) else None
        if valWA == valTF:
            good += 1
        else:
            wrong.append((node, feat, valWA, valTF))

    console(f&#34;\tGood:     {good:&gt;5} x&#34;)
    console(f&#34;\tWrong:    {len(wrong):&gt;5} x&#34;)
    fconsistent = len(wrong) == 0
    console(
        f&#34;{rep(fconsistent)} - format annotations consistent with features&#34;,
        error=not fconsistent,
    )

    fmtTF = []

    for feat in Fall():
        if not feat.startswith(&#34;rend_&#34;):
            continue

        value = feat.split(&#34;_&#34;, 2)[1]
        if value == &#34;note&#34;:
            continue

        for node, valTF in Fs(feat).items():
            slots = eoslots(node)
            b = slots[0]
            e = slots[-1]

            if skipMeta and (is_metav(b) or is_metav(e)):
                continue

            fmtTF.append((node, value))

    fmtTF = sorted(fmtTF)

    console(f&#34;\tWA format attributes: {len(fmtWA)}&#34;)
    console(f&#34;\tTF format attributes: {len(fmtTF)}&#34;)
    fcomplete = fmtTF == fmtWA
    console(
        f&#34;{rep(complete)} - format annotations complete w.r.t. features&#34;,
        error=not fcomplete,
    )

    return consistent and complete and fconsistent and fcomplete</code></pre>
</details>
</dd>
<dt id="tf.convert.watm.WATM.testEdges"><code class="name flex">
<span>def <span class="ident">testEdges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L780-L925" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def testEdges(self):
    Es = self.Es
    Eall = self.Eall
    annotations = self.testAnnotations

    console(&#34;Testing the edges ...&#34;)

    tfFromAidNodes = {}
    tfFromAidEdges = {}

    for aId, kind, body, target in annotations:
        if kind != &#34;node&#34;:
            continue
        if type(target) is tuple:
            (start, end) = target
            if start + 1 != end:
                print(target)
                break
            target = end
        tfFromAidNodes[target] = body

    for aId, kind, body, target in annotations:
        if kind != &#34;edge&#34;:
            continue

        (fro, to) = target
        fromNode = tfFromAidNodes[fro]
        toNode = tfFromAidNodes[to]
        parts = body.split(&#34;=&#34;, 1)
        (name, val) = (body, None) if len(parts) == 1 else parts
        tfFromAidEdges.setdefault(name, {}).setdefault(fromNode, {})[toNode] = val

    console(f&#34;\tFound: {len(tfFromAidNodes)} nodes&#34;)

    for edge, edgeData in sorted(tfFromAidEdges.items()):
        print(f&#34;\tFound edge {edge} with {len(edgeData)} starting nodes&#34;)

    allGood = True

    for edge in set(Eall()) | set(tfFromAidEdges):
        if edge == &#34;oslots&#34;:
            continue

        print(f&#34;Checking edge {edge}&#34;)

        good = True

        if edge not in set(Eall()):
            print(&#34;\tmissing in TF data&#34;)
            good = False

        if edge not in tfFromAidEdges:
            print(&#34;\tmissing in annotation data&#34;)
            good = False

        if not good:
            continue

        dataTF = dict(Es(edge).items())
        dataAid = tfFromAidEdges[edge]

        fromNodesTF = set(dataTF)
        fromNodesAid = set(dataAid)

        nFromTF = len(fromNodesTF)
        nFromAid = len(fromNodesAid)

        if fromNodesTF == fromNodesAid:
            console(f&#34;\tsame {nFromTF} fromNodes&#34;)
        else:
            console(f&#34;\tfrom nodes differ: {nFromTF} in TF, {nFromAid} in Aid&#34;)
            good = False

        diffs = []

        nToChecked = 0

        for f, toNodeInfoTF in dataTF.items():
            toNodeInfoAid = dataAid[f]
            if type(toNodeInfoTF) is dict:
                toNodeInfoTF = {k: str(v) for (k, v) in toNodeInfoTF.items()}
            else:
                toNodeInfoTF = {x: None for x in toNodeInfoTF}

            if toNodeInfoTF != toNodeInfoAid:
                diffs.append((f, toNodeInfoTF, toNodeInfoAid))

            nToChecked += len(toNodeInfoTF)

        if len(diffs):
            good = False
            console(
                f&#34;\tdifferences in toNodes for {len(diffs)} fromNodes&#34;, error=True
            )

            for f, toNodeInfoTF, toNodeInfoAid in sorted(diffs)[0:10]:
                console(f&#34;\t\tfromNode {f}&#34;, error=True)

                toNodesTF = set(toNodeInfoTF)
                toNodesAid = set(toNodeInfoAid)

                nToTF = len(toNodesTF)
                nToAid = len(toNodesAid)

                if toNodesTF == toNodesAid:
                    console(f&#34;\t\t\tsame {nToTF} toNodes&#34;)
                else:
                    console(
                        f&#34;\t\t\ttoNodes differ: {nToTF} in TF, {nToAid} in Aid&#34;,
                        error=True,
                    )
                for t in toNodesTF | toNodesAid:
                    doCompare = True
                    if t not in toNodesTF:
                        console(f&#34;\t\t\t\ttoNode {t} not in TF&#34;, error=True)
                        doCompare = False
                    else:
                        valTF = toNodeInfoTF[t]

                    if t not in toNodesAid:
                        console(f&#34;\t\t\t\ttoNode {t} not in Aid&#34;, error=True)
                        doCompare = False
                    else:
                        valAid = toNodeInfoAid[t]

                    if doCompare:
                        if valTF == valAid:
                            console(
                                f&#34;\t\t\t\ttoNode{t} values agree: {repr(valTF)}&#34;
                            )
                        else:
                            console(
                                f&#34;\t\t\t\ttoNode{t} values differ: &#34;
                                f&#34;TF: {repr(valTF)} Aid: {repr(valAid)}&#34;,
                                error=True,
                            )

        console(f&#34;\t{nToChecked} toNodes checked&#34;)
        console(&#34;\tOK&#34; if good else &#34;\tWRONG&#34;, error=not good)

        if not good:
            allGood = False

    console(f&#34;{rep(allGood)} - {&#39;All&#39; if allGood else &#39;Not all&#39;} edges agree&#34;)

    return allGood</code></pre>
</details>
</dd>
<dt id="tf.convert.watm.WATM.testElements"><code class="name flex">
<span>def <span class="ident">testElements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L524-L624" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def testElements(self):
    F = self.F
    fotypev = self.fotypev
    eoslots = self.eoslots
    skipMeta = self.skipMeta
    is_metav = self.is_metav
    annotations = self.testAnnotations

    console(&#34;Testing the elements ...&#34;)

    nElementsTF = 0
    nPisTF = 0

    for n in range(F.otype.maxSlot + 1, F.otype.maxNode + 1):
        nType = fotypev(n)
        isPi = nType.startswith(&#34;?&#34;)

        if isPi:
            nPisTF += 1

        slots = eoslots(n)
        b = slots[0]
        e = slots[-1]

        if skipMeta and (is_metav(b) or is_metav(e)):
            continue
        else:
            if not isPi:
                nElementsTF += 1

    nElementsWA = sum(
        1 if kind == &#34;element&#34; else 0 for (aId, kind, body, target) in annotations
    )
    nPisWA = sum(
        1 if kind == &#34;pi&#34; else 0 for (aId, kind, body, target) in annotations
    )

    eGood = self.compare(nElementsTF, nElementsWA)
    console(f&#34;{rep(eGood)} - Same number of elements as nodes&#34;, error=not eGood)

    pGood = self.compare(nPisTF, nPisWA)
    console(
        f&#34;{rep(pGood)} - Same number of processing instructions&#34;, error=not pGood
    )

    # element annotations

    tfFromAid = {}

    element = 0
    pi = 0
    other = 0
    good = 0
    wrong = 0
    unmapped = 0

    for aId, kind, body, target in annotations:
        if kind == &#34;node&#34;:
            tfFromAid[target] = body

    self.tfFromAid = tfFromAid

    console(f&#34;\t{len(tfFromAid)} element annotations&#34;)

    for aId, kind, body, target in annotations:
        isElem = kind == &#34;element&#34;
        isPi = kind == &#34;pi&#34;

        if not isElem and not isPi:
            other += 1
            continue

        if isElem:
            element += 1
        else:
            pi += 1

        tag = body
        node = tfFromAid.get(aId, None)
        if node is None:
            unmapped += 1
            continue

        otype = fotypev(node)

        if isPi and tag == otype[1:] or not isPi and tag == otype:
            good += 1
        else:
            wrong += 1

    console(f&#34;\tElement : {element:&gt;5} x&#34;)
    console(f&#34;\tPi      : {pi:&gt;5} x&#34;)
    console(f&#34;\tOther   : {other:&gt;5} x&#34;)
    console(f&#34;\tGood    : {good:&gt;5} x&#34;)
    console(f&#34;\tWrong   : {wrong:&gt;5} x&#34;)
    console(f&#34;\tUnmapped: {unmapped:&gt;5} x&#34;)

    aGood = wrong == 0 and unmapped == 0
    console(f&#34;{rep(aGood)} - All element annotations OK&#34;, error=not aGood)

    return aGood and eGood and pGood</code></pre>
</details>
</dd>
<dt id="tf.convert.watm.WATM.testSetup"><code class="name flex">
<span>def <span class="ident">testSetup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L463-L498" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def testSetup(self):
    textFile = self.textFile
    annoFiles = self.annoFiles

    with open(textFile) as fh:
        text = json.load(fh)
        tokens = text[&#34;_ordered_segments&#34;]

    self.testTokens = tokens

    annotationById = {}
    annotations = []

    for annoFile in annoFiles:
        with open(annoFile) as fh:
            annos = json.load(fh)

            for aId, (kind, ns, body, target) in annos.items():
                if &#34;-&gt;&#34; in target:
                    parts = target.split(&#34;-&gt;&#34;, 1)
                else:
                    parts = [target]
                newParts = []
                for part in parts:
                    if &#34;-&#34; in part:
                        (start, end) = part.split(&#34;-&#34;, 1)
                        part = (int(start), int(end))
                    newParts.append(part)

                target = newParts[0] if len(newParts) == 1 else tuple(newParts)

                annotationById[aId] = (kind, body, target)
                annotations.append((aId, kind, body, target))

    annotations = sorted(annotations)
    self.testAnnotations = annotations</code></pre>
</details>
</dd>
<dt id="tf.convert.watm.WATM.testText"><code class="name flex">
<span>def <span class="ident">testText</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L500-L522" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def testText(self):
    F = self.F
    skipMeta = self.skipMeta
    is_metav = self.is_metav
    tokens = self.testTokens
    text = self.text

    console(&#34;Testing the text ...&#34;)

    nTokensTF = sum(
        0 if skipMeta and is_metav(s) else 1 for s in range(1, F.otype.maxSlot + 1)
    )
    nTokensWA = len(tokens)
    nGood = self.compare(nTokensTF, nTokensWA)
    console(f&#34;{rep(nGood)} - Same number of tokens&#34;, error=not nGood)

    textWA = &#34;&#34;.join(tokens)
    textTF = &#34;&#34;.join(text)

    tGood = self.strEqual(wa=textWA, tf=textTF)
    console(f&#34;{rep(tGood)} - Same text&#34;, error=not tGood)

    return nGood and tGood</code></pre>
</details>
</dd>
<dt id="tf.convert.watm.WATM.writeAll"><code class="name flex">
<span>def <span class="ident">writeAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L348-L421" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def writeAll(self):
    app = self.app
    text = self.text
    annos = self.annos

    baseDir = self.repoLocation
    relative = app.context.relative
    version = app.version
    wRelative = REL_RE.sub(f&#34;/{TT_NAME}/{version}/&#34;, relative, count=1)
    resultDir = f&#34;{baseDir}{wRelative}&#34;
    textFile = f&#34;{resultDir}/text.json&#34;

    self.textFile = textFile

    initTree(resultDir, fresh=True)

    with open(textFile, &#34;w&#34;) as fh:
        json.dump(dict(_ordered_segments=text), fh, ensure_ascii=False, indent=1)

    console(f&#34;Text file: {len(text):&gt;7} segments to {textFile}&#34;)

    annoStore = {}

    for kind, aId, ns, body, target in annos:
        annoStore[aId] = (kind, ns, body, target)

    aIdSorted = sorted(annoStore.keys())

    annoFile = f&#34;{resultDir}/anno.tsv&#34;

    if False:
        with open(annoFile, &#34;w&#34;) as fh:
            for aId in aIdSorted:
                (kind, ns, body, target) = annoStore[aId]
                fh.write(f&#34;{aId}\t{kind}\t{ns}\t{body}\t{target}\n&#34;)

    thisAnnoStore = {}
    thisA = 1
    annoFiles = []
    self.annoFiles = annoFiles

    LIMIT = 400000
    j = 0
    total = 0

    def writeThis():
        annoFile = f&#34;{resultDir}/anno-{thisA:&gt;01}.json&#34;
        annoFiles.append(annoFile)

        with open(annoFile, &#34;w&#34;) as fh:
            json.dump(thisAnnoStore, fh, ensure_ascii=False, indent=1)

        console(f&#34;{j:&gt;6} annotations written to {annoFile}&#34;)

    for aId in aIdSorted:
        if j &gt;= LIMIT:
            writeThis()
            thisA += 1
            thisAnnoStore = {}
            total += j
            j = 0

        thisAnnoStore[aId] = annoStore[aId]
        j += 1

    if len(thisAnnoStore):
        writeThis()
        total += j

    if len(annos) != total:
        console(f&#34;Sum of batches : {total:&gt;8}&#34;)
        console(f&#34;All annotations: {len(annoStore):&gt;8}&#34;)
        console(&#34;Mismatch in number of annotations&#34;, error=True)
    console(f&#34;Anno files: {len(annos):&gt;7} annotations to {len(annoFiles)} files&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tf.convert.watm.WATMS"><code class="flex name class">
<span>class <span class="ident">WATMS</span></span>
<span>(</span><span>org, repo, backend, nsOrig, skipMeta=False, extra={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L951-L992" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class WATMS:
    def __init__(self, org, repo, backend, nsOrig, skipMeta=False, extra={}):
        self.org = org
        self.repo = repo
        self.backend = backend
        self.nsOrig = nsOrig
        self.skipMeta = skipMeta
        self.extra = extra

        repoDir = ex(f&#34;~/{backend}/{org}/{repo}&#34;)
        tfDir = f&#34;{repoDir}/tf&#34;
        docs = dirContents(tfDir)[1]
        console(f&#34;Found {len(docs)} docs in {tfDir}&#34;)
        self.docs = docs

    def produce(self, doc=None):
        org = self.org
        repo = self.repo
        backend = self.backend
        nsOrig = self.nsOrig
        skipMeta = self.skipMeta
        extra = self.extra
        docs = self.docs

        chosenDoc = doc

        for doc in sorted(docs, key=lambda x: (x[0], int(x[1:]))):
            if chosenDoc is not None and chosenDoc != doc:
                continue

            console(f&#34;{doc:&gt;5} ... &#34;, newline=False)
            A = use(
                f&#34;{org}/{repo}:clone&#34;,
                relative=f&#34;tf/{doc}&#34;,
                checkout=&#34;clone&#34;,
                backend=backend,
                silent=DEEP,
            )
            WA = WATM(A, nsOrig, skipMeta=skipMeta, extra=extra)
            WA.makeText()
            WA.makeAnno()
            WA.writeAll()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.convert.watm.WATMS.produce"><code class="name flex">
<span>def <span class="ident">produce</span></span>(<span>self, doc=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae0f2b6b7bb018584d0e16b9da1c4d4bc31ad4aa/tf/convert/watm.py#L966-L992" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def produce(self, doc=None):
    org = self.org
    repo = self.repo
    backend = self.backend
    nsOrig = self.nsOrig
    skipMeta = self.skipMeta
    extra = self.extra
    docs = self.docs

    chosenDoc = doc

    for doc in sorted(docs, key=lambda x: (x[0], int(x[1:]))):
        if chosenDoc is not None and chosenDoc != doc:
            continue

        console(f&#34;{doc:&gt;5} ... &#34;, newline=False)
        A = use(
            f&#34;{org}/{repo}:clone&#34;,
            relative=f&#34;tf/{doc}&#34;,
            checkout=&#34;clone&#34;,
            backend=backend,
            silent=DEEP,
        )
        WA = WATM(A, nsOrig, skipMeta=skipMeta, extra=extra)
        WA.makeText()
        WA.makeAnno()
        WA.writeAll()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.convert" href="index.html">tf.convert</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.convert.watm.rep" href="#tf.convert.watm.rep">rep</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.convert.watm.WATM" href="#tf.convert.watm.WATM">WATM</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.convert.watm.WATM.compare" href="#tf.convert.watm.WATM.compare">compare</a></code></li>
<li><code><a title="tf.convert.watm.WATM.makeAnno" href="#tf.convert.watm.WATM.makeAnno">makeAnno</a></code></li>
<li><code><a title="tf.convert.watm.WATM.makeText" href="#tf.convert.watm.WATM.makeText">makeText</a></code></li>
<li><code><a title="tf.convert.watm.WATM.mkAnno" href="#tf.convert.watm.WATM.mkAnno">mkAnno</a></code></li>
<li><code><a title="tf.convert.watm.WATM.strEqual" href="#tf.convert.watm.WATM.strEqual">strEqual</a></code></li>
<li><code><a title="tf.convert.watm.WATM.testAll" href="#tf.convert.watm.WATM.testAll">testAll</a></code></li>
<li><code><a title="tf.convert.watm.WATM.testAttributes" href="#tf.convert.watm.WATM.testAttributes">testAttributes</a></code></li>
<li><code><a title="tf.convert.watm.WATM.testEdges" href="#tf.convert.watm.WATM.testEdges">testEdges</a></code></li>
<li><code><a title="tf.convert.watm.WATM.testElements" href="#tf.convert.watm.WATM.testElements">testElements</a></code></li>
<li><code><a title="tf.convert.watm.WATM.testSetup" href="#tf.convert.watm.WATM.testSetup">testSetup</a></code></li>
<li><code><a title="tf.convert.watm.WATM.testText" href="#tf.convert.watm.WATM.testText">testText</a></code></li>
<li><code><a title="tf.convert.watm.WATM.writeAll" href="#tf.convert.watm.WATM.writeAll">writeAll</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tf.convert.watm.WATMS" href="#tf.convert.watm.WATMS">WATMS</a></code></h4>
<ul class="">
<li><code><a title="tf.convert.watm.WATMS.produce" href="#tf.convert.watm.WATMS.produce">produce</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>