<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.server.start API documentation</title>
<meta name="description" content="Start kernel and webserver â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.server.start</code></h1>
</header>
<section id="section-intro">
<h1 id="start-kernel-and-webserver">Start kernel and webserver</h1>
<p>What the <code>text-fabric</code> script does is the same as:</p>
<pre><code class="language-sh">python3 -m tf.server.start
</code></pre>
<p>During start up the following happens:</p>
<dl>
<dt>Kill previous processes</dt>
<dd>The system is searched for non-terminated incarnations of the processes
it wants to start up.
If they are encountered, they will be killed, so that they cannot prevent
a successful start up.</dd>
<dt>Start TF kernel</dt>
<dd>A <code><a title="tf.server.kernel" href="kernel.html">tf.server.kernel</a></code> is started.
This process loads the bulk of the TF data, so it can take a while.
When it has loaded the data, it sends out a message that loading is done,
which is picked up by the script.</dd>
<dt>Start TF web server</dt>
<dd>
<p>A short while after receiving the "data loading done" message,
the TF web server is started.</p>
<div class="admonition hint">
<p class="admonition-title">Debug mode</p>
<p>If you have passed <code>-d</code> to the <code>text-fabric</code> script,
the <strong>Flask</strong> web server will be started in debug and reload mode.
That means that if you modify <code>web.py</code> or a module it imports,
the web server will reload itself automatically.
When you refresh the browser you see the changes.
If you have changed templates, the css, or the javascript,
you should do a "refresh from origin".</p>
</div>
</dd>
<dt>Load web page</dt>
<dd>After a short while, the default web browser will be started
with a url and port at which the
web server will listen. You see your browser being started up
and the TF page being loaded.</dd>
<dt>Wait</dt>
<dd>The script now waits till the web server is finished.
You finish it by pressing Ctrl-C, and if you have used the <code>-d</code> flag,
you have to press it twice.</dd>
<dt>Terminate the TF kernel"</dt>
<dd>At this point, the <code>text-fabric</code> script will terminate the TF kernel.</dd>
<dt>Clean up</dt>
<dd>
<p>Now all processes that have started up have been killed.</p>
<p>If something went wrong in this sequence, chances are that a process keeps running.
It will be terminated next time you call the <code>text-fabric</code>.</p>
</dd>
</dl>
<div class="admonition hint">
<p class="admonition-title">You can kill too</p>
<p>If you run</p>
</div>
<pre><code class="language-sh">text-fabric -k
</code></pre>
<p>all tf-browser-related processes will be killed.</p>
<pre><code class="language-sh">text-fabric -k ddd
</code></pre>
<p>will kill all such processes as far as they are for data source <code>ddd</code>.</p>
<h2 id="additional-arguments">Additional arguments</h2>
<p>You can direct the loading of corpus data by means of additional arguments,
analogously to the <code>use()</code> command, documented in <code><a title="tf.about.usefunc" href="../about/usefunc.html">tf.about.usefunc</a></code>.</p>
<p>The main argument specifies the data source in the same way as the
first argument of the <code>use()</code> function:</p>
<ul>
<li><code>org/repo</code></li>
<li><code>org/repo:specifier</code></li>
<li><code>app:path/to/app</code></li>
<li><code>data:path/to/data</code></li>
</ul>
<p>The following arguments of the <code>use()</code> function can be used on the command line,
prepended with <code>--</code>:</p>
<ul>
<li><code>--checkout</code></li>
<li><code>--mod</code></li>
<li><code>--set</code></li>
<li><code>--locations</code></li>
<li><code>--modules</code></li>
<li><code>--version</code></li>
</ul>
<h2 id="implementation-notes">Implementation notes</h2>
<p>Different corpora will use different ports for the kernel and webserver communication.</p>
<p>The ports are computed from the arguments with which text-fabric is called.</p>
<p>That is done by the <a href="https://docs.python.org/3.7/library/zlib.html#zlib.crc32">crc32</a> function.
There is no guarantee that collisions occur,
and that the ports computed this way are free.
So we will look for the first available port after this.</p>
<p>On the whole, the following things are fairly well taken care of:</p>
<ul>
<li>Invocations of text-fabric with different arguments lead to different ports</li>
<li>Repeated invocations of text-fabric with the same arguments lead to the same ports.</li>
</ul>
<p>In particular, the following invocations lead to different ports:</p>
<pre><code class="language-sh">text-fabric annotation/banks
</code></pre>
<p>and</p>
<pre><code>text-fabric annotation/banks:clone
</code></pre>
<p>and likewise for all other arguments.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae8c1106e0d61c84aa0b70837767a8e81b878a1f/tf/server/start.py#L1-L417" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Start kernel and webserver

What the `text-fabric` script does is the same as:

```sh
python3 -m tf.server.start
```

During start up the following happens:

Kill previous processes
:   The system is searched for non-terminated incarnations of the processes
    it wants to start up.
    If they are encountered, they will be killed, so that they cannot prevent
    a successful start up.

Start TF kernel
:   A `tf.server.kernel` is started.
    This process loads the bulk of the TF data, so it can take a while.
    When it has loaded the data, it sends out a message that loading is done,
    which is picked up by the script.

Start TF web server
:   A short while after receiving the &#34;data loading done&#34; message,
    the TF web server is started.

    !!! hint &#34;Debug mode&#34;
        If you have passed `-d` to the `text-fabric` script,
        the **Flask** web server will be started in debug and reload mode.
        That means that if you modify `web.py` or a module it imports,
        the web server will reload itself automatically.
        When you refresh the browser you see the changes.
        If you have changed templates, the css, or the javascript,
        you should do a &#34;refresh from origin&#34;.

Load web page
:   After a short while, the default web browser will be started
    with a url and port at which the
    web server will listen. You see your browser being started up
    and the TF page being loaded.

Wait
:   The script now waits till the web server is finished.
    You finish it by pressing Ctrl-C, and if you have used the `-d` flag,
    you have to press it twice.

Terminate the TF kernel&#34;
:   At this point, the `text-fabric` script will terminate the TF kernel.

Clean up
:   Now all processes that have started up have been killed.

    If something went wrong in this sequence, chances are that a process keeps running.
    It will be terminated next time you call the `text-fabric`.

!!! hint &#34;You can kill too&#34;
    If you run

```sh
text-fabric -k
```

all tf-browser-related processes will be killed.

```sh
text-fabric -k ddd
```

will kill all such processes as far as they are for data source `ddd`.

## Additional arguments

You can direct the loading of corpus data by means of additional arguments,
analogously to the `use()` command, documented in `tf.about.usefunc`.

The main argument specifies the data source in the same way as the
first argument of the `use()` function:

*   `org/repo`
*   `org/repo:specifier`
*   `app:path/to/app`
*   `data:path/to/data`

The following arguments of the `use()` function can be used on the command line,
prepended with `--`:

*   `--checkout`
*   `--mod`
*   `--set`
*   `--locations`
*   `--modules`
*   `--version`

## Implementation notes

Different corpora will use different ports for the kernel and webserver communication.

The ports are computed from the arguments with which text-fabric is called.

That is done by the [crc32](https://docs.python.org/3.7/library/zlib.html#zlib.crc32) function.
There is no guarantee that collisions occur,
and that the ports computed this way are free.
So we will look for the first available port after this.

On the whole, the following things are fairly well taken care of:

*   Invocations of text-fabric with different arguments lead to different ports
*   Repeated invocations of text-fabric with the same arguments lead to the same ports.

In particular, the following invocations lead to different ports:

```sh
text-fabric annotation/banks
```

and

```
text-fabric annotation/banks:clone
```

and likewise for all other arguments.

&#34;&#34;&#34;

import sys
import os
from platform import system

import psutil
import webbrowser
from time import sleep
from subprocess import PIPE, Popen

from ..core.helpers import console
from ..parameters import NAME, VERSION, PROTOCOL, HOST

from .command import (
    argKill,
    argShow,
    argNoweb,
    argApp,
    getPort,
    repSlug,
)
from .kernel import TF_DONE, TF_ERROR

HELP = &#34;&#34;&#34;
USAGE

text-fabric --help
text-fabric -v
text-fabric -k [org/repo]
text-fabric -p [org/repo]

text-fabric org/repo
text-fabric app:/path/to/app --locations=locations-string [--modules=modules-string]

where all args are optional and args have one of these forms:

  -noweb
  --checkout=specifier
  --mod=modules
  --set=file
  --modules=modules-string
  --locations=locations-string
  --version=version

EFFECT

See https://annotation.github.io/text-fabric/tf/server/start.html

If an org/repo is given and the -k and -p flags are not passed,
a TF kernel for that org/repo is started.
When the TF kernel is ready, a web server is started
serving a website that exposes the data through
a query interface.

The default browser will be opened, except when -noweb is passed.

MISCELLANEOUS

-noweb Do not start the default browser

CLEAN UP

If you press Ctrl-C the web server is stopped, and after that the TF kernel
as well.
Normally, you do not have to do any clean up.
But if the termination is done in an irregular way, you may end up with
stray processes.

-p  Show mode. If a data source is given, the TF kernel and web server for that
    data source are shown.
    Without a data source, all local webinterface related processes are shown.
-k  Kill mode. If a data source is given, the TF kernel and web server for that
    data source are killed.
    Without a data source, all local webinterface related processes are killed.
&#34;&#34;&#34;

FLAGS = set(
    &#34;&#34;&#34;
    -noweb
&#34;&#34;&#34;.strip().split()
)

BANNER = f&#34;This is {NAME} {VERSION}&#34;


def filterProcess(proc):
    procName = proc.info[&#34;name&#34;]
    commandName = &#34;&#34; if procName is None else procName.lower()

    kind = None
    slug = None

    trigger = &#34;python&#34;
    if commandName.endswith(trigger) or commandName.endswith(f&#34;{trigger}.exe&#34;):
        parts = [p for p in proc.cmdline() if p not in FLAGS]
        if parts:
            parts = parts[1:]
        if parts and parts[0] == &#34;-m&#34;:
            parts = parts[1:]
        if not parts:
            return False
        (call, *args) = parts

        trigger = &#34;text-fabric&#34;
        if call.endswith(trigger) or call.endswith(f&#34;{trigger}.exe&#34;):
            if any(arg in {&#34;-k&#34;, &#34;-p&#34;} for arg in args):
                return False
            slug = argApp(parts)[1]
            ports = ()
            kind = &#34;text-fabric&#34;
        else:
            if call == &#34;tf.server.kernel&#34;:
                kind = &#34;kernel&#34;
            elif call == &#34;tf.server.web&#34;:
                kind = &#34;web&#34;
            elif call.endswith(&#34;web.py&#34;):
                kind = &#34;web&#34;
            else:
                return False
            (slug, *ports) = args

        return (kind, slug, *ports)
    return False


def indexProcesses():
    tfProcesses = {}
    for proc in psutil.process_iter(attrs=[&#34;pid&#34;, &#34;name&#34;]):
        test = filterProcess(proc)
        if test:
            (kind, pSlug, *ports) = test
            tfProcesses.setdefault(pSlug, {}).setdefault(kind, []).append(
                (proc.info[&#34;pid&#34;], *ports)
            )
    return tfProcesses


def showProcesses(tfProcesses, slug, term=False, kill=False):
    item = (&#34;killed&#34; if kill else &#34;terminated&#34;) if term else &#34;&#34;
    if item:
        item = f&#34;: {item}&#34;
    myself = os.getpid()
    for (pSlug, kinds) in tfProcesses.items():
        if slug is None or (slug == pSlug):
            checkKinds = (&#34;kernel&#34;, &#34;web&#34;, &#34;text-fabric&#34;)
            rSlug = repSlug(pSlug)
            for kind in checkKinds:
                pidPorts = kinds.get(kind, [])
                for pidPort in pidPorts:
                    pid = pidPort[0]
                    port = pidPort[-1] if len(pidPort) &gt; 1 else None
                    portRep = &#34;&#34; if port is None else f&#34;: {port:&gt;5}&#34;
                    if pid == myself:
                        continue
                    processRep = f&#34;{kind:&lt;12} % {pid:&gt;5}{portRep:&gt;7}&#34;
                    try:
                        proc = psutil.Process(pid=pid)
                        if term:
                            if kill:
                                proc.kill()
                            else:
                                proc.terminate()
                        console(f&#34;{processRep} {rSlug}{item}&#34;)
                    except psutil.NoSuchProcess:
                        if term:
                            console(
                                f&#34;{processRep} {rSlug}: already {item}&#34;, error=True,
                            )


def connectPort(tfProcesses, kind, pos, slug):
    pInfo = tfProcesses.get(slug, {}).get(kind, None)
    return pInfo[0][pos] if pInfo else None


def main(cargs=sys.argv):
    console(BANNER)
    if len(cargs) &gt;= 2 and any(
        arg in {&#34;--help&#34;, &#34;-help&#34;, &#34;-h&#34;, &#34;?&#34;, &#34;-?&#34;} for arg in cargs[1:]
    ):
        console(HELP)
        return
    if len(cargs) &gt;= 2 and any(
        arg == &#34;-v&#34; for arg in cargs[1:]
    ):
        return

    isWin = system().lower().startswith(&#34;win&#34;)
    pythonExe = &#34;python&#34; if isWin else &#34;python3&#34;

    kill = argKill(cargs)
    show = argShow(cargs)

    (appName, slug, newPortKernel, newPortWeb) = argApp(cargs)

    if appName is None and not kill and not show:
        return

    noweb = argNoweb(cargs)

    tfProcesses = indexProcesses()

    if kill or show:
        if appName is False:
            return
        showProcesses(tfProcesses, None if appName is None else slug, term=kill)
        return

    stopped = False
    portKernel = connectPort(tfProcesses, &#34;kernel&#34;, 1, slug)
    portWeb = None

    processKernel = None
    processWeb = None

    if portKernel:
        console(f&#34;Connecting to running kernel via {portKernel}&#34;)
    else:
        portKernel = getPort(portBase=newPortKernel)
        console(f&#34;Starting new kernel listening on {portKernel}&#34;)
        if portKernel != newPortKernel:
            console(f&#34;\twhich is the first free port after {newPortKernel}&#34;)
        processKernel = Popen(
            [pythonExe, &#34;-m&#34;, &#34;tf.server.kernel&#34;, slug, str(portKernel)],
            stdout=PIPE,
            bufsize=1,
            encoding=&#34;utf-8&#34;,
        )
        console(f&#34;Loading data for {appName}. Please wait ...&#34;)
        for line in processKernel.stdout:
            sys.stdout.write(line)
            if line.rstrip() == TF_ERROR:
                return
            if line.rstrip() == TF_DONE:
                break
        sleep(1)
        stopped = processKernel.poll()

    if not stopped:
        portWeb = connectPort(tfProcesses, &#34;web&#34;, 2, slug)
        if portWeb:
            console(f&#34;Connecting to running webserver via {portWeb}&#34;)
        else:
            portWeb = getPort(portBase=newPortWeb)
            console(f&#34;Starting new webserver listening on {portWeb}&#34;)
            if portWeb != newPortWeb:
                console(f&#34;\twhich is the first free port after {newPortWeb}&#34;)
            processWeb = Popen(
                [
                    pythonExe,
                    &#34;-m&#34;,
                    &#34;tf.server.web&#34;,
                    slug,
                    str(portKernel),
                    str(portWeb),
                ],
                bufsize=0,
                encoding=&#34;utf8&#34;,
            )

    if not noweb:
        sleep(2)
        stopped = (not portWeb or (processWeb and processWeb.poll())) or (
            not portKernel or (processKernel and processKernel.poll())
        )
        if not stopped:
            console(f&#34;Opening {appName} in browser&#34;)
            webbrowser.open(
                f&#34;{PROTOCOL}{HOST}:{portWeb}&#34;, new=2, autoraise=True,
            )

    stopped = (not portWeb or (processWeb and processWeb.poll())) or (
        not portKernel or (processKernel and processKernel.poll())
    )
    if not stopped:
        try:
            console(&#34;Press &lt;Ctrl+C&gt; to stop the TF browser&#34;)
            if processKernel:
                for line in processKernel.stdout:
                    sys.stdout.write(line)
        except KeyboardInterrupt:
            console(&#34;&#34;)
            if processWeb:
                processWeb.terminate()
                console(&#34;TF web server has stopped&#34;)
            if processKernel:
                processKernel.terminate()
                console(&#34;TF kernel has stopped&#34;)


if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.server.start.connectPort"><code class="name flex">
<span>def <span class="ident">connectPort</span></span>(<span>tfProcesses, kind, pos, slug)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae8c1106e0d61c84aa0b70837767a8e81b878a1f/tf/server/start.py#L296-L298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def connectPort(tfProcesses, kind, pos, slug):
    pInfo = tfProcesses.get(slug, {}).get(kind, None)
    return pInfo[0][pos] if pInfo else None</code></pre>
</details>
</dd>
<dt id="tf.server.start.filterProcess"><code class="name flex">
<span>def <span class="ident">filterProcess</span></span>(<span>proc)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae8c1106e0d61c84aa0b70837767a8e81b878a1f/tf/server/start.py#L211-L248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def filterProcess(proc):
    procName = proc.info[&#34;name&#34;]
    commandName = &#34;&#34; if procName is None else procName.lower()

    kind = None
    slug = None

    trigger = &#34;python&#34;
    if commandName.endswith(trigger) or commandName.endswith(f&#34;{trigger}.exe&#34;):
        parts = [p for p in proc.cmdline() if p not in FLAGS]
        if parts:
            parts = parts[1:]
        if parts and parts[0] == &#34;-m&#34;:
            parts = parts[1:]
        if not parts:
            return False
        (call, *args) = parts

        trigger = &#34;text-fabric&#34;
        if call.endswith(trigger) or call.endswith(f&#34;{trigger}.exe&#34;):
            if any(arg in {&#34;-k&#34;, &#34;-p&#34;} for arg in args):
                return False
            slug = argApp(parts)[1]
            ports = ()
            kind = &#34;text-fabric&#34;
        else:
            if call == &#34;tf.server.kernel&#34;:
                kind = &#34;kernel&#34;
            elif call == &#34;tf.server.web&#34;:
                kind = &#34;web&#34;
            elif call.endswith(&#34;web.py&#34;):
                kind = &#34;web&#34;
            else:
                return False
            (slug, *ports) = args

        return (kind, slug, *ports)
    return False</code></pre>
</details>
</dd>
<dt id="tf.server.start.indexProcesses"><code class="name flex">
<span>def <span class="ident">indexProcesses</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae8c1106e0d61c84aa0b70837767a8e81b878a1f/tf/server/start.py#L251-L260" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def indexProcesses():
    tfProcesses = {}
    for proc in psutil.process_iter(attrs=[&#34;pid&#34;, &#34;name&#34;]):
        test = filterProcess(proc)
        if test:
            (kind, pSlug, *ports) = test
            tfProcesses.setdefault(pSlug, {}).setdefault(kind, []).append(
                (proc.info[&#34;pid&#34;], *ports)
            )
    return tfProcesses</code></pre>
</details>
</dd>
<dt id="tf.server.start.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>cargs=['/Library/Frameworks/Python.framework/Versions/3.10/bin/pdoc3', '--force', '--html', '--output-dir', 'site', '--template-dir', 'tf/docs/templates', 'tf'])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae8c1106e0d61c84aa0b70837767a8e81b878a1f/tf/server/start.py#L301-L413" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def main(cargs=sys.argv):
    console(BANNER)
    if len(cargs) &gt;= 2 and any(
        arg in {&#34;--help&#34;, &#34;-help&#34;, &#34;-h&#34;, &#34;?&#34;, &#34;-?&#34;} for arg in cargs[1:]
    ):
        console(HELP)
        return
    if len(cargs) &gt;= 2 and any(
        arg == &#34;-v&#34; for arg in cargs[1:]
    ):
        return

    isWin = system().lower().startswith(&#34;win&#34;)
    pythonExe = &#34;python&#34; if isWin else &#34;python3&#34;

    kill = argKill(cargs)
    show = argShow(cargs)

    (appName, slug, newPortKernel, newPortWeb) = argApp(cargs)

    if appName is None and not kill and not show:
        return

    noweb = argNoweb(cargs)

    tfProcesses = indexProcesses()

    if kill or show:
        if appName is False:
            return
        showProcesses(tfProcesses, None if appName is None else slug, term=kill)
        return

    stopped = False
    portKernel = connectPort(tfProcesses, &#34;kernel&#34;, 1, slug)
    portWeb = None

    processKernel = None
    processWeb = None

    if portKernel:
        console(f&#34;Connecting to running kernel via {portKernel}&#34;)
    else:
        portKernel = getPort(portBase=newPortKernel)
        console(f&#34;Starting new kernel listening on {portKernel}&#34;)
        if portKernel != newPortKernel:
            console(f&#34;\twhich is the first free port after {newPortKernel}&#34;)
        processKernel = Popen(
            [pythonExe, &#34;-m&#34;, &#34;tf.server.kernel&#34;, slug, str(portKernel)],
            stdout=PIPE,
            bufsize=1,
            encoding=&#34;utf-8&#34;,
        )
        console(f&#34;Loading data for {appName}. Please wait ...&#34;)
        for line in processKernel.stdout:
            sys.stdout.write(line)
            if line.rstrip() == TF_ERROR:
                return
            if line.rstrip() == TF_DONE:
                break
        sleep(1)
        stopped = processKernel.poll()

    if not stopped:
        portWeb = connectPort(tfProcesses, &#34;web&#34;, 2, slug)
        if portWeb:
            console(f&#34;Connecting to running webserver via {portWeb}&#34;)
        else:
            portWeb = getPort(portBase=newPortWeb)
            console(f&#34;Starting new webserver listening on {portWeb}&#34;)
            if portWeb != newPortWeb:
                console(f&#34;\twhich is the first free port after {newPortWeb}&#34;)
            processWeb = Popen(
                [
                    pythonExe,
                    &#34;-m&#34;,
                    &#34;tf.server.web&#34;,
                    slug,
                    str(portKernel),
                    str(portWeb),
                ],
                bufsize=0,
                encoding=&#34;utf8&#34;,
            )

    if not noweb:
        sleep(2)
        stopped = (not portWeb or (processWeb and processWeb.poll())) or (
            not portKernel or (processKernel and processKernel.poll())
        )
        if not stopped:
            console(f&#34;Opening {appName} in browser&#34;)
            webbrowser.open(
                f&#34;{PROTOCOL}{HOST}:{portWeb}&#34;, new=2, autoraise=True,
            )

    stopped = (not portWeb or (processWeb and processWeb.poll())) or (
        not portKernel or (processKernel and processKernel.poll())
    )
    if not stopped:
        try:
            console(&#34;Press &lt;Ctrl+C&gt; to stop the TF browser&#34;)
            if processKernel:
                for line in processKernel.stdout:
                    sys.stdout.write(line)
        except KeyboardInterrupt:
            console(&#34;&#34;)
            if processWeb:
                processWeb.terminate()
                console(&#34;TF web server has stopped&#34;)
            if processKernel:
                processKernel.terminate()
                console(&#34;TF kernel has stopped&#34;)</code></pre>
</details>
</dd>
<dt id="tf.server.start.showProcesses"><code class="name flex">
<span>def <span class="ident">showProcesses</span></span>(<span>tfProcesses, slug, term=False, kill=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ae8c1106e0d61c84aa0b70837767a8e81b878a1f/tf/server/start.py#L263-L293" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showProcesses(tfProcesses, slug, term=False, kill=False):
    item = (&#34;killed&#34; if kill else &#34;terminated&#34;) if term else &#34;&#34;
    if item:
        item = f&#34;: {item}&#34;
    myself = os.getpid()
    for (pSlug, kinds) in tfProcesses.items():
        if slug is None or (slug == pSlug):
            checkKinds = (&#34;kernel&#34;, &#34;web&#34;, &#34;text-fabric&#34;)
            rSlug = repSlug(pSlug)
            for kind in checkKinds:
                pidPorts = kinds.get(kind, [])
                for pidPort in pidPorts:
                    pid = pidPort[0]
                    port = pidPort[-1] if len(pidPort) &gt; 1 else None
                    portRep = &#34;&#34; if port is None else f&#34;: {port:&gt;5}&#34;
                    if pid == myself:
                        continue
                    processRep = f&#34;{kind:&lt;12} % {pid:&gt;5}{portRep:&gt;7}&#34;
                    try:
                        proc = psutil.Process(pid=pid)
                        if term:
                            if kill:
                                proc.kill()
                            else:
                                proc.terminate()
                        console(f&#34;{processRep} {rSlug}{item}&#34;)
                    except psutil.NoSuchProcess:
                        if term:
                            console(
                                f&#34;{processRep} {rSlug}: already {item}&#34;, error=True,
                            )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#start-kernel-and-webserver">Start kernel and webserver</a><ul>
<li><a href="#additional-arguments">Additional arguments</a></li>
<li><a href="#implementation-notes">Implementation notes</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.server" href="index.html">tf.server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.server.start.connectPort" href="#tf.server.start.connectPort">connectPort</a></code></li>
<li><code><a title="tf.server.start.filterProcess" href="#tf.server.start.filterProcess">filterProcess</a></code></li>
<li><code><a title="tf.server.start.indexProcesses" href="#tf.server.start.indexProcesses">indexProcesses</a></code></li>
<li><code><a title="tf.server.start.main" href="#tf.server.start.main">main</a></code></li>
<li><code><a title="tf.server.start.showProcesses" href="#tf.server.start.showProcesses">showProcesses</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="../../tf/images/DANS-logo.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>